<!DOCTYPE html>
<html lang="en">
<head> 
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Order Analysis Tool - Complete with Picked Up by Another Rider</title>
    <style>
        /* Modern CSS Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #411517 0%, #2a0e10 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 24px;
            box-shadow: 0 25px 70px rgba(0,0,0,0.4);
            overflow: hidden;
            position: relative;
        }
        
        .container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 6px;
            background: linear-gradient(90deg, #ff5900 0%, #ff8c42 100%);
            z-index: 2;
        }
        
        /* Header Section */
        .header {
            background: linear-gradient(135deg, #ff5900 0%, #ff8c42 100%);
            color: white;
            padding: 40px 30px 30px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }
        
        .header::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: rgba(255,255,255,0.2);
        }
        
        .header-content {
            position: relative;
            z-index: 1;
        }
        
        .header h1 {
            font-size: 2.8rem;
            font-weight: 800;
            margin-bottom: 8px;
            letter-spacing: -0.5px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .header p {
            font-size: 1.1rem;
            opacity: 0.95;
            font-weight: 400;
            margin-top: 5px;
        }
        
        .header-icon {
            font-size: 3rem;
            margin-bottom: 15px;
            display: block;
        }
        
        /* Main Content */
        .content {
            padding: 30px;
            background: linear-gradient(to bottom, #fafafa 0%, #ffffff 100%);
        }
        
        /* Input Section */
        .input-section {
            margin-bottom: 30px;
        }
        
        .input-label {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            font-size: 1.3rem;
            font-weight: 600;
            color: #411517;
            padding-left: 5px;
        }
        
        .input-label svg {
            width: 24px;
            height: 24px;
            fill: #ff5900;
        }
        
        .input-wrapper {
            position: relative;
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 8px 30px rgba(65, 21, 23, 0.12);
            border: 2px solid #e8e8e8;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .input-wrapper:hover {
            border-color: #ff8c42;
            box-shadow: 0 12px 40px rgba(255, 89, 0, 0.15);
        }
        
        .input-wrapper:focus-within {
            border-color: #ff5900;
            box-shadow: 0 12px 40px rgba(255, 89, 0, 0.2);
        }
        
        textarea {
            width: 100%;
            height: 280px;
            padding: 25px;
            border: none;
            background: white;
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            font-size: 15px;
            line-height: 1.6;
            resize: vertical;
            color: #333;
        }
        
        textarea:focus {
            outline: none;
        }
        
        textarea::placeholder {
            color: #888;
            font-size: 15px;
            font-weight: 400;
        }
        
        /* Split Deliveries Text Areas Container */
        .split-textareas-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(400px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .split-textarea-wrapper {
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 8px 30px rgba(65, 21, 23, 0.12);
            border: 2px solid #e8e8e8;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .split-textarea-wrapper:hover {
            border-color: #ff8c42;
            box-shadow: 0 12px 40px rgba(255, 89, 0, 0.15);
        }
        
        .split-textarea-header {
            background: linear-gradient(135deg, #f8f9fa 0%, #f0f2f4 100%);
            padding: 12px 20px;
            border-bottom: 1px solid #e8e8e8;
            font-weight: 600;
            color: #411517;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .split-textarea-wrapper textarea {
            height: 200px;
            border-radius: 0;
        }
        
        /* Checkbox Styling */
        .checkbox-container {
            margin-top: 20px;
            padding: 15px;
            background: rgba(255, 89, 0, 0.05);
            border-radius: 12px;
            border: 1px solid rgba(255, 89, 0, 0.2);
            display: flex;
            align-items: center;
            gap: 12px;
            transition: all 0.3s ease;
        }
        
        .checkbox-container:hover {
            background: rgba(255, 89, 0, 0.1);
            border-color: rgba(255, 89, 0, 0.3);
        }
        
        .checkbox-container input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
            accent-color: #ff5900;
        }
        
        .checkbox-container label {
            display: inline;
            margin: 0;
            font-weight: 500;
            cursor: pointer;
            color: #411517;
            font-size: 0.95rem;
            flex: 1;
        }
        
        /* Auto Popup Checkbox */
        .checkbox-container.auto-popup {
            background: rgba(159, 122, 234, 0.05);
            border: 1px solid rgba(159, 122, 234, 0.2);
        }
        
        .checkbox-container.auto-popup:hover {
            background: rgba(159, 122, 234, 0.1);
            border-color: rgba(159, 122, 234, 0.3);
        }
        
        /* Button Section */
        .button-section {
            text-align: center;
            margin: 40px 0 30px;
            padding: 0 20px;
        }
        
        .analyze-btn {
            background: linear-gradient(135deg, #411517 0%, #5a1f22 100%);
            color: white;
            border: none;
            padding: 22px 60px;
            font-size: 1.2rem;
            font-weight: 600;
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 15px 35px rgba(65, 21, 23, 0.3);
            display: inline-flex;
            align-items: center;
            gap: 12px;
            letter-spacing: 0.5px;
            position: relative;
            overflow: hidden;
        }
        
        .analyze-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            transition: 0.6s;
        }
        
        .analyze-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 20px 40px rgba(65, 21, 23, 0.4);
        }
        
        .analyze-btn:hover::before {
            left: 100%;
        }
        
        .analyze-btn:active {
            transform: translateY(-1px);
        }
        
        .analyze-btn:disabled {
            opacity: 0.7;
            cursor: not-allowed;
            transform: none;
        }
        
        .btn-icon {
            font-size: 1.4rem;
        }
        
        /* Loading State */
        .loading {
            text-align: center;
            margin: 20px 0;
            padding: 20px;
            display: none;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255, 89, 0, 0.1);
            border-top-color: #ff5900;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Error Message */
        .error {
            background: linear-gradient(135deg, #fed7d7 0%, #feb2b2 100%);
            color: #9b2c2c;
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0;
            border: 1px solid #fc8181;
            display: none;
            align-items: center;
            gap: 12px;
        }
        
        /* Result Container */
        .result-container {
            display: none;
            animation: slideUp 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* Result Header */
        .result-header {
            background: linear-gradient(135deg, #f8f9fa 0%, #f0f2f4 100%);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            border: 1px solid #e8e9ea;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 20px;
        }
        
        .result-title h2 {
            font-size: 1.8rem;
            font-weight: 700;
            color: #411517;
            margin-bottom: 5px;
        }
        
        .result-title p {
            color: #666;
            font-size: 0.95rem;
            display: none; /* Hide "Column Z equivalent calculation" */
        }
        
        .final-result {
            padding: 20px 40px;
            border-radius: 16px;
            font-size: 1.8rem;
            font-weight: 800;
            text-align: center;
            min-width: 220px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
        }
        
        .final-result:hover {
            transform: scale(1.03);
        }
        
        .result-before-pdt {
            background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
            color: white;
        }
        
        .result-vendor-late {
            background: linear-gradient(135deg, #ed8936 0%, #dd6b20 100%);
            color: white;
        }
        
        .result-rider-late {
            background: linear-gradient(135deg, #f56565 0%, #e53e3e 100%);
            color: white;
        }
        
        .result-long-dispatch {
            background: linear-gradient(135deg, #4299e1 0%, #3182ce 100%);
            color: white;
        }
        
        .result-on-time {
            background: linear-gradient(135deg, #a0aec0 0%, #718096 100%);
            color: white;
        }
        
        .result-picked-up-another-rider {
            background: linear-gradient(135deg, #9f7aea 0%, #805ad5 100%);
            color: white;
        }
        
        /* Basic Information - Horizontal Layout */
        .basic-info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .info-card {
            background: white;
            border-radius: 16px;
            padding: 25px;
            border: 1px solid #e8e9ea;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.05);
        }
        
        .info-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            border-color: #ff8c42;
        }
        
        .info-label {
            font-size: 0.9rem;
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .info-label::before {
            content: '';
            width: 6px;
            height: 6px;
            background: #ff5900;
            border-radius: 50%;
            display: inline-block;
        }
        
        .info-value {
            font-size: 1.4rem;
            font-weight: 700;
            color: #411517;
            margin-bottom: 5px;
        }
        
        .info-time {
            color: #ff5900;
            font-family: 'SF Mono', monospace;
            font-weight: 600;
        }
        
        .info-seconds {
            color: #4299e1;
            font-family: 'SF Mono', monospace;
            font-weight: 600;
        }
        
        .info-boolean {
            display: inline-block;
            padding: 6px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 600;
            margin-top: 5px;
        }
        
        .info-boolean-true {
            background: rgba(72, 187, 120, 0.1);
            color: #2f855a;
        }
        
        .info-boolean-false {
            background: rgba(245, 101, 101, 0.1);
            color: #c53030;
        }
        
        .info-note {
            font-size: 0.8rem;
            color: #718096;
            margin-top: 5px;
            font-style: italic;
        }
        
        /* Hidden Sections */
        .hidden-section {
            display: none !important;
        }
        
        /* Modern Popup/Modal Styling */
        .popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 20px;
            animation: fadeIn 0.3s ease;
            backdrop-filter: blur(5px);
        }
        
        .popup-container {
            background: white;
            border-radius: 24px;
            width: 100%;
            max-width: 800px;
            max-height: 90vh;
            overflow: hidden;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.3);
            animation: slideUpPopup 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            flex-direction: column;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes slideUpPopup {
            from {
                opacity: 0;
                transform: translateY(30px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
        
        .popup-header {
            background: linear-gradient(135deg, #805ad5 0%, #9f7aea 100%);
            color: white;
            padding: 25px 30px;
            position: relative;
        }
        
        .popup-header h3 {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .popup-header p {
            font-size: 0.95rem;
            opacity: 0.9;
            margin-top: 5px;
        }
        
        .popup-close {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            color: white;
            font-size: 1.2rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }
        
        .popup-close:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: rotate(90deg);
        }
        
        .popup-content {
            padding: 30px;
            overflow-y: auto;
            flex: 1;
            background: linear-gradient(to bottom, #fafafa 0%, #ffffff 100%);
        }
        
        .queued-stage-list {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .queued-stage-item {
            background: white;
            border-radius: 12px;
            padding: 20px;
            border: 1px solid #e8e9ea;
            transition: all 0.3s ease;
            display: flex;
            align-items: flex-start;
            gap: 15px;
        }
        
        .queued-stage-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.08);
            border-color: #9f7aea;
        }
        
        .queued-stage-checkbox {
            display: flex;
            align-items: center;
            margin-top: 4px;
        }
        
        .queued-stage-checkbox input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
            accent-color: #805ad5;
        }
        
        .queued-stage-details {
            flex: 1;
        }
        
        .queued-stage-timestamp {
            font-size: 1.1rem;
            font-weight: 600;
            color: #411517;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .queued-stage-label {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 10px;
        }
        
        .queued-stage-label label {
            font-weight: 500;
            color: #666;
            cursor: pointer;
            font-size: 0.9rem;
        }
        
        .popup-footer {
            padding: 20px 30px;
            background: white;
            border-top: 1px solid #e8e9ea;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .popup-summary {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }
        
        .summary-item {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .summary-label {
            font-size: 0.8rem;
            color: #666;
            font-weight: 500;
        }
        
        .summary-value {
            font-size: 1.1rem;
            font-weight: 700;
            color: #411517;
        }
        
        .summary-value-seconds {
            color: #4299e1;
            font-family: 'SF Mono', monospace;
        }
        
        .popup-actions {
            display: flex;
            gap: 10px;
        }
        
        .popup-btn {
            padding: 12px 24px;
            border-radius: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            border: none;
            font-size: 0.95rem;
        }
        
        .popup-btn-primary {
            background: linear-gradient(135deg, #805ad5 0%, #9f7aea 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(128, 90, 213, 0.2);
        }
        
        .popup-btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(128, 90, 213, 0.3);
        }
        
        .popup-btn-secondary {
            background: #f8f9fa;
            color: #666;
            border: 1px solid #e8e9ea;
        }
        
        .popup-btn-secondary:hover {
            background: #f0f2f4;
            transform: translateY(-2px);
        }
        
        .no-queued-stages {
            text-align: center;
            padding: 40px 20px;
            color: #666;
        }
        
        .no-queued-stages p {
            margin-bottom: 10px;
        }
        
        /* Split Deliveries Number Selection */
        .number-selection-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 15px;
            margin: 20px 0;
        }
        
        .number-btn {
            background: white;
            border: 2px solid #e8e9ea;
            border-radius: 12px;
            padding: 20px 10px;
            font-size: 1.2rem;
            font-weight: 700;
            color: #411517;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }
        
        .number-btn:hover {
            background: #f8f9fa;
            border-color: #ff8c42;
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(255, 89, 0, 0.15);
        }
        
        .number-btn.selected {
            background: linear-gradient(135deg, #ff5900 0%, #ff8c42 100%);
            color: white;
            border-color: #ff5900;
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(255, 89, 0, 0.3);
        }
        
        .number-input-container {
            margin: 25px 0;
            text-align: center;
        }
        
        .number-input-container label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            color: #411517;
        }
        
        .number-input {
            width: 150px;
            padding: 15px;
            border: 2px solid #e8e9ea;
            border-radius: 12px;
            font-size: 1.2rem;
            font-weight: 600;
            text-align: center;
            color: #411517;
            transition: all 0.3s ease;
        }
        
        .number-input:focus {
            outline: none;
            border-color: #ff5900;
            box-shadow: 0 4px 15px rgba(255, 89, 0, 0.15);
        }
        
        .number-input-error {
            color: #e53e3e;
            font-size: 0.9rem;
            margin-top: 8px;
            display: none;
        }
        
        /* Split Deliveries Summary */
        .split-deliveries-summary {
            margin-top: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 16px;
            border: 1px solid #e8e9ea;
        }
        
        .split-deliveries-summary h4 {
            font-size: 1.2rem;
            font-weight: 700;
            color: #411517;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .delivery-results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
        }
        
        .delivery-result-card {
            background: white;
            border-radius: 12px;
            padding: 15px;
            border: 1px solid #e8e9ea;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .delivery-result-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.08);
        }
        
        .delivery-result-card.picked-up-clickable {
            border: 2px solid #9f7aea;
            background: rgba(159, 122, 234, 0.05);
        }
        
        .delivery-result-card.picked-up-clickable:hover {
            border-color: #805ad5;
            background: rgba(159, 122, 234, 0.1);
        }
        
        .delivery-result-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid #e8e9ea;
        }
        
        .delivery-number {
            font-weight: 700;
            color: #411517;
            font-size: 1.1rem;
        }
        
        .delivery-status {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
        }
        
        .delivery-status-before-pdt {
            background: rgba(72, 187, 120, 0.1);
            color: #2f855a;
        }
        
        .delivery-status-vendor-late {
            background: rgba(237, 137, 54, 0.1);
            color: #dd6b20;
        }
        
        .delivery-status-rider-late {
            background: rgba(245, 101, 101, 0.1);
            color: #c53030;
        }
        
        .delivery-status-long-dispatch {
            background: rgba(66, 153, 225, 0.1);
            color: #3182ce;
        }
        
        .delivery-status-on-time {
            background: rgba(160, 174, 192, 0.1);
            color: #718096;
        }
        
        .delivery-status-picked-up-another-rider {
            background: rgba(159, 122, 234, 0.1);
            color: #805ad5;
        }
        
        .delivery-details {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            font-size: 0.85rem;
        }
        
        .delivery-detail {
            display: flex;
            flex-direction: column;
        }
        
        .delivery-detail-label {
            font-weight: 600;
            color: #666;
            margin-bottom: 2px;
        }
        
        .delivery-detail-value {
            font-weight: 700;
            color: #411517;
        }
        
        .delivery-delay-values {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #e8e9ea;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .delay-badge {
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
            background: #f8f9fa;
            border: 1px solid #e8e9ea;
        }
        
        /* Tab Navigation for Multi-Delivery Popup */
        .delivery-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 20px;
            border-bottom: 1px solid #e8e9ea;
            padding-bottom: 10px;
            overflow-x: auto;
        }
        
        .delivery-tab {
            padding: 10px 20px;
            background: #f8f9fa;
            border: 1px solid #e8e9ea;
            border-radius: 8px 8px 0 0;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .delivery-tab:hover {
            background: #f0f2f4;
        }
        
        .delivery-tab.active {
            background: #805ad5;
            color: white;
            border-color: #805ad5;
        }
        
        .delivery-tab.active .tab-badge {
            background: rgba(255, 255, 255, 0.3);
            color: white;
        }
        
        .tab-badge {
            background: #e8e9ea;
            color: #666;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
        }
        
        .delivery-info-header {
            margin-bottom: 20px;
            padding: 15px;
            background: white;
            border-radius: 12px;
            border: 1px solid #e8e9ea;
        }
        
        .delivery-info-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 10px;
        }
        
        .delivery-info-item {
            display: flex;
            flex-direction: column;
        }
        
        .delivery-info-label {
            font-size: 0.8rem;
            color: #666;
            font-weight: 500;
            margin-bottom: 2px;
        }
        
        .delivery-info-value {
            font-size: 1rem;
            font-weight: 600;
            color: #411517;
        }
        
        /* Responsive Design */
        @media (max-width: 1024px) {
            .basic-info-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .split-textareas-container {
                grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            }
            
            .number-selection-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }
        
        @media (max-width: 768px) {
            .container {
                border-radius: 16px;
            }
            
            .header {
                padding: 30px 20px;
            }
            
            .header h1 {
                font-size: 2.2rem;
            }
            
            .content {
                padding: 20px;
            }
            
            .result-header {
                flex-direction: column;
                text-align: center;
                padding: 25px;
            }
            
            .final-result {
                min-width: 100%;
                padding: 15px 20px;
            }
            
            .basic-info-grid {
                grid-template-columns: 1fr;
            }
            
            .analyze-btn {
                width: 100%;
                justify-content: center;
                padding: 20px;
            }
            
            textarea {
                height: 240px;
                padding: 20px;
            }
            
            .split-textarea-wrapper textarea {
                height: 180px;
            }
            
            .split-textareas-container {
                grid-template-columns: 1fr;
            }
            
            .popup-container {
                max-width: 95%;
            }
            
            .popup-header {
                padding: 20px;
            }
            
            .popup-content {
                padding: 20px;
            }
            
            .popup-footer {
                padding: 15px 20px;
                flex-direction: column;
                align-items: stretch;
            }
            
            .popup-summary {
                justify-content: space-between;
            }
            
            .popup-actions {
                width: 100%;
                justify-content: center;
            }
            
            .number-selection-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .delivery-results-grid {
                grid-template-columns: 1fr;
            }
            
            .delivery-tabs {
                flex-wrap: wrap;
            }
            
            .delivery-tab {
                flex: 1;
                min-width: 120px;
                text-align: center;
                justify-content: center;
            }
        }
        
        @media (max-width: 480px) {
            body {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 1.8rem;
            }
            
            .input-label {
                font-size: 1.1rem;
            }
            
            .info-card {
                padding: 20px;
            }
            
            .info-value {
                font-size: 1.2rem;
            }
            
            .queued-stage-item {
                padding: 15px;
                flex-direction: column;
                gap: 10px;
            }
            
            .number-selection-grid {
                grid-template-columns: repeat(3, 1fr);
            }
            
            .number-btn {
                padding: 15px 5px;
                font-size: 1.1rem;
            }
            
            .delivery-tabs {
                flex-direction: column;
            }
            
            .delivery-tab {
                width: 100%;
                border-radius: 8px;
                margin-bottom: 5px;
            }
        }
        
        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 10px;
        }
        
        ::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 5px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #ff5900 0%, #411517 100%);
            border-radius: 5px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, #ff8c42 0%, #5a1f22 100%);
        }
        
        /* Selection */
        ::selection {
            background: rgba(255, 89, 0, 0.3);
            color: #411517;
        }
        
        /* Focus */
        *:focus {
            outline: 2px solid #ff5900;
            outline-offset: 2px;
        }
        
        /* Animation for card entrance */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .info-card {
            animation: fadeIn 0.5s ease forwards;
        }

        /* =========================================== */
        /* ADDED CSS FOR VISIBILITY CHANGES */
        /* =========================================== */

        /* 1Ô∏è‚É£ Hide the "Automatically show Picked up by Another Rider analysis popup" checkbox */
        .checkbox-container.auto-popup {
            display: none !important;
        }

        /* 2Ô∏è‚É£ Hide the entire Split Deliveries Analysis section */
        #splitDeliveriesSummary {
            display: none !important;
        }

        /* 3Ô∏è‚É£ Hide specific fields in SINGLE delivery picked up popup */
        #pickedUpPopup .popup-summary {
            display: none !important;
        }

        /* 4Ô∏è‚É£ Hide specific fields in MULTIPLE deliveries picked up popup */
        #pickedUpPopup .delivery-info-header {
            display: none !important;
        }

        /* 5Ô∏è‚É£ Prevent user switching between deliveries - Hide tabs */
        #deliveryTabs {
            display: none !important;
        }

        /* 6Ô∏è‚É£ Remove Apply Changes notification (hide alert) */
        /* Note: Alert is a browser function, but we can't remove it without JS changes */
        /* However, we can add a style to visually hide alerts if they appear in DOM */

        /* Additional: Hide queued stages list header in multi-delivery popup */
        #pickedUpPopup .popup-header p {
            display: none !important;
        }

        /* 7Ô∏è‚É£ Cancel button already has proper behavior, just ensure it's visible */

        /* 8Ô∏è‚É£ Visual Styling Harmonization */
        /* Update popup header to match main theme */
        #pickedUpPopup .popup-header {
            background: linear-gradient(135deg, #ff5900 0%, #ff8c42 100%) !important;
        }

        #splitDeliveriesPopup .popup-header {
            background: linear-gradient(135deg, #ff5900 0%, #ff8c42 100%) !important;
        }

        /* Update popup button colors to match theme */
        #pickedUpPopup .popup-btn-primary {
            background: linear-gradient(135deg, #411517 0%, #5a1f22 100%) !important;
            box-shadow: 0 4px 15px rgba(65, 21, 23, 0.2) !important;
        }

        #pickedUpPopup .popup-btn-primary:hover {
            box-shadow: 0 8px 20px rgba(65, 21, 23, 0.3) !important;
        }

        #splitDeliveriesPopup .popup-btn-primary {
            background: linear-gradient(135deg, #411517 0%, #5a1f22 100%) !important;
            box-shadow: 0 4px 15px rgba(65, 21, 23, 0.2) !important;
        }

        #splitDeliveriesPopup .popup-btn-primary:hover {
            box-shadow: 0 8px 20px rgba(65, 21, 23, 0.3) !important;
        }

        /* Harmonize queued stage items */
        .queued-stage-item:hover {
            border-color: #ff8c42 !important;
        }

        .queued-stage-checkbox input[type="checkbox"] {
            accent-color: #ff5900 !important;
        }

        /* Ensure hidden elements maintain layout */
        .hidden-element {
            visibility: hidden;
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* Ensure buttons and interactive elements remain functional even when hidden */
        [style*="display: none"] {
            /* This ensures elements with display:none are still in DOM but not visible */
        }

        /* =========================================== */
        /* NEW CSS FOR REQUESTED CHANGES */
        /* =========================================== */

        /* 1Ô∏è‚É£ Delivery Indicator Styling */
        .delivery-indicator {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 12px;
            padding: 12px 20px;
            margin: 15px 0;
            border: 2px solid #e8e9ea;
            color: #411517;
            font-weight: 600;
            text-align: center;
            font-size: 1.1rem;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
            display: none; /* Hidden by default, shown via JavaScript */
            align-items: center;
            justify-content: center;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .delivery-indicator .indicator-label {
            color: #666;
            font-weight: 500;
            font-size: 0.95rem;
        }
        
        .delivery-indicator .indicator-value {
            background: linear-gradient(135deg, #ff5900 0%, #ff8c42 100%);
            color: white;
            padding: 6px 16px;
            border-radius: 20px;
            font-weight: 700;
            font-size: 1.1rem;
            min-width: 80px;
            display: inline-block;
        }
        
        .delivery-indicator .indicator-separator {
            color: #999;
            margin: 0 4px;
        }

        /* 2Ô∏è‚É£ Hide any alert notifications visually */
        .alert-notification,
        .toast-notification,
        .notification-banner {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
            height: 0 !important;
            padding: 0 !important;
            margin: 0 !important;
            overflow: hidden !important;
        }

        /* Style to override any browser alert display */
        body::after {
            display: none !important;
        }

        /* =========================================== */
        /* END OF NEW CSS */
        /* =========================================== */
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="header-content">
                <div class="header-icon">üìä</div>
                <h1>Late Owner Analysis Tool</h1>
                <p>Created by talabat SSC Analytics Team</p>
            </div>
        </div>
        
        <div class="content">
            <!-- Input Section -->
            <div class="input-section">
                <div class="input-label">
                    <svg viewBox="0 0 24 24">
                        <path d="M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-4.86 8.86l-3 3.87L9 13.14 6 17h12l-3.86-5.14z"/>
                    </svg>
                    Paste Order Details
                </div>
                
                <!-- Single Input Wrapper (default) -->
                <div class="input-wrapper" id="singleInputWrapper">
                    <textarea 
                        id="orderDetails" 
                        placeholder="Make sure to expand the rider delivery to get the timeline events&#10;then press CTRL + A >> Copy >> Paste"
                        spellcheck="false">
                    </textarea>
                </div>
                
                <!-- Split Deliveries Text Areas Container (hidden by default) -->
                <div class="split-textareas-container" id="splitTextareasContainer" style="display: none;">
                    <!-- Dynamic text areas will be generated here -->
                </div>
                
                <!-- Checkbox for Local Shop AE -->
                <div class="checkbox-container">
                    <input type="checkbox" id="localShopAE">
                    <label for="localShopAE">Local Shop AE</label>
                </div>
                
                <!-- Checkbox for Split Deliveries -->
                <div class="checkbox-container">
                    <input type="checkbox" id="splitDeliveries">
                    <label for="splitDeliveries">Split Deliveries</label>
                </div>
                
                <!-- Checkbox for Auto Show Popup -->
                <div class="checkbox-container auto-popup">
                    <input type="checkbox" id="autoShowPopup" checked>
                    <label for="autoShowPopup">Automatically show Picked up by Another Rider analysis popup</label>
                </div>
            </div>
            
            <!-- Error Message -->
            <div class="error" id="errorMessage"></div>
            
            <!-- Loading State -->
            <div class="loading" id="loading">
                <div class="spinner"></div>
                <p>Analyzing order details...</p>
            </div>
            
            <!-- Button Section -->
            <div class="button-section">
                <button class="analyze-btn" id="analyzeBtn" onclick="analyzeOrder()">
                    <span class="btn-icon">üöÄ</span>
                    <span>Analyze Order</span>
                </button>
            </div>
            
            <!-- Results Container -->
            <div class="result-container" id="resultContainer">
                <!-- Result Header -->
                <div class="result-header">
                    <div class="result-title">
                        <h2>Analysis Result</h2>
                        <p>Column Z equivalent calculation</p>
                    </div>
                    <div class="final-result" id="finalResult"></div>
                </div>
                
                <!-- Split Deliveries Summary (hidden by default) -->
                <div class="split-deliveries-summary" id="splitDeliveriesSummary" style="display: none;">
                    <h4>üì¶ Split Deliveries Analysis</h4>
                    <div class="delivery-results-grid" id="deliveryResultsGrid">
                        <!-- Delivery results will be populated here -->
                    </div>
                </div>
                
                <!-- Basic Information - Horizontal Cards -->
                <div class="basic-info-grid" id="basicInfoGrid">
                    <!-- Cards will be populated here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Modern Popup for Split Deliveries Number Selection -->
    <div class="popup-overlay" id="splitDeliveriesPopup" style="display: none;">
        <div class="popup-container">
            <div class="popup-header">
                <button class="popup-close" onclick="closeSplitDeliveriesPopup()">√ó</button>
                <h3>üì¶ Split Deliveries</h3>
                <p>How many deliveries do you want to analyze?</p>
            </div>
            <div class="popup-content">
                <div class="number-selection-grid" id="numberSelectionGrid">
                    <!-- Number buttons will be generated here -->
                </div>
                <div class="number-input-container">
                    <label for="deliveryCountInput">Or enter a number (2-10):</label>
                    <input type="number" id="deliveryCountInput" class="number-input" min="2" max="10" value="2">
                    <div class="number-input-error" id="numberInputError">Please enter a number between 2 and 10</div>
                </div>
            </div>
            <div class="popup-footer">
                <div class="popup-summary">
                    <div class="summary-item">
                        <span class="summary-label">Selected</span>
                        <span class="summary-value" id="selectedCountDisplay">0</span>
                    </div>
                </div>
                <div class="popup-actions">
                    <button class="popup-btn popup-btn-secondary" onclick="closeSplitDeliveriesPopup()">Cancel</button>
                    <button class="popup-btn popup-btn-primary" onclick="confirmSplitDeliveries()">Confirm</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Modern Popup for Picked up by another rider analysis - UPDATED FOR MULTI-DELIVERY -->
    <div class="popup-overlay" id="pickedUpPopup" style="display: none;">
        <div class="popup-container">
            <div class="popup-header">
                <button class="popup-close" onclick="closePopup()">√ó</button>
                <!-- 3Ô∏è‚É£ Page Title Updated -->
                <h3>Additional Validation Is Required</h3>
                <p>Review Queued stages for all deliveries with Picked up by another rider result</p>
                
                <!-- 1Ô∏è‚É£ Delivery Indicator Added -->
                <div class="delivery-indicator" id="deliveryIndicator">
                    <span class="indicator-label">Viewing Delivery</span>
                    <span class="indicator-value">
                        <span id="currentDeliveryDisplay">1</span>
                        <span class="indicator-separator">/</span>
                        <span id="totalDeliveriesDisplay">1</span>
                    </span>
                </div>
                
                <!-- Delivery Tabs for Multiple Deliveries -->
                <div class="delivery-tabs" id="deliveryTabs">
                    <!-- Tabs will be generated here dynamically -->
                </div>
            </div>
            <div class="popup-content">
                <!-- Delivery Info Header -->
                <div class="delivery-info-header" id="deliveryInfoHeader" style="display: none;">
                    <div class="delivery-info-row">
                        <div class="delivery-info-item">
                            <span class="delivery-info-label">Delivery</span>
                            <span class="delivery-info-value" id="currentDeliveryNumber">#1</span>
                        </div>
                        <div class="delivery-info-item">
                            <span class="delivery-info-label">Order ID</span>
                            <span class="delivery-info-value" id="currentDeliveryOrderId">N/A</span>
                        </div>
                        <div class="delivery-info-item">
                            <span class="delivery-info-label">Status</span>
                            <span class="delivery-info-value" id="currentDeliveryStatus">Picked up by another rider</span>
                        </div>
                        <div class="delivery-info-item">
                            <span class="delivery-info-label">Queued Stages</span>
                            <span class="delivery-info-value" id="currentDeliveryQueuedCount">0</span>
                        </div>
                    </div>
                </div>
                
                <div class="queued-stage-list" id="queuedStageList">
                    <!-- Queued stages will be populated here -->
                </div>
            </div>
            <div class="popup-footer">
                <div class="popup-summary">
                    <div class="summary-item">
                        <span class="summary-label">Total Picked up by another rider</span>
                        <span class="summary-value summary-value-seconds" id="summaryTotalPickedUp">0s</span>
                    </div>
                    <div class="summary-item">
                        <span class="summary-label">Vendor Delay (V)</span>
                        <span class="summary-value summary-value-seconds" id="summaryVendorDelay">0s</span>
                    </div>
                    <div class="summary-item">
                        <span class="summary-label">System Late (U)</span>
                        <span class="summary-value summary-value-seconds" id="summarySystemLate">0s</span>
                    </div>
                    <div class="summary-item">
                        <span class="summary-label">Total Rider Delay (X+W)</span>
                        <span class="summary-value summary-value-seconds" id="summaryTotalRiderDelay">0s</span>
                    </div>
                </div>
                <div class="popup-actions">
                    <button class="popup-btn popup-btn-secondary" onclick="closePopup()">Cancel</button>
                    <button class="popup-btn popup-btn-primary" onclick="applyPopupChanges()">Apply Changes</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        let debugData = {};
        let pickedUpAnalysisData = {
            patterns: [],
            originalCalculations: {},
            adjustedCalculations: {},
            checkedPatterns: new Set()
        };
        
        // Split Deliveries Variables
        let splitDeliveriesData = {
            isSplitActive: false,
            numberOfDeliveries: 0,
            deliveries: [],
            deliveryResults: [],
            finalResult: null
        };
        
        // Variable to track which split delivery is being edited
        let currentEditingDeliveryIndex = null;
        
        // Variable for multi-delivery popup
        let multiDeliveryPopupData = {
            deliveries: [], // Array of delivery indices with "Picked up by another rider"
            currentTabIndex: 0
        };
        
        // Function to show split deliveries popup
        function showSplitDeliveriesPopup() {
            const popup = document.getElementById('splitDeliveriesPopup');
            const numberGrid = document.getElementById('numberSelectionGrid');
            const selectedCountDisplay = document.getElementById('selectedCountDisplay');
            const deliveryCountInput = document.getElementById('deliveryCountInput');
            
            // Generate number buttons
            numberGrid.innerHTML = '';
            for (let i = 2; i <= 10; i++) {
                const button = document.createElement('button');
                button.className = 'number-btn';
                button.textContent = i;
                button.onclick = () => selectDeliveryCount(i);
                numberGrid.appendChild(button);
            }
            
            // Set default selection
            selectDeliveryCount(2);
            
            // Show popup
            popup.style.display = 'flex';
            document.body.style.overflow = 'hidden';
        }
        
        // Function to select delivery count
        function selectDeliveryCount(count) {
            const buttons = document.querySelectorAll('.number-btn');
            buttons.forEach(btn => {
                btn.classList.remove('selected');
                if (parseInt(btn.textContent) === count) {
                    btn.classList.add('selected');
                }
            });
            
            const selectedCountDisplay = document.getElementById('selectedCountDisplay');
            const deliveryCountInput = document.getElementById('deliveryCountInput');
            
            selectedCountDisplay.textContent = count;
            deliveryCountInput.value = count;
            
            // Clear any error
            document.getElementById('numberInputError').style.display = 'none';
        }
        
        // Function to close split deliveries popup
        function closeSplitDeliveriesPopup() {
            const popup = document.getElementById('splitDeliveriesPopup');
            popup.style.display = 'none';
            document.body.style.overflow = 'auto';
            
            // Uncheck the checkbox if popup is closed without confirming
            document.getElementById('splitDeliveries').checked = false;
        }
        
        // Function to confirm split deliveries count
        function confirmSplitDeliveries() {
            const deliveryCountInput = document.getElementById('deliveryCountInput');
            const count = parseInt(deliveryCountInput.value);
            const errorDiv = document.getElementById('numberInputError');
            
            // Validate input
            if (isNaN(count) || count < 2 || count > 10) {
                errorDiv.style.display = 'block';
                return;
            }
            
            // Set split deliveries data
            splitDeliveriesData.isSplitActive = true;
            splitDeliveriesData.numberOfDeliveries = count;
            
            // Generate text areas
            generateSplitTextAreas(count);
            
            // Close popup
            closeSplitDeliveriesPopup();
        }
        
        // Function to generate split text areas
        function generateSplitTextAreas(count) {
            const singleInputWrapper = document.getElementById('singleInputWrapper');
            const splitContainer = document.getElementById('splitTextareasContainer');
            
            // Hide single input, show split container
            singleInputWrapper.style.display = 'none';
            splitContainer.style.display = 'grid';
            
            // Clear existing text areas
            splitContainer.innerHTML = '';
            
            // Generate new text areas
            for (let i = 0; i < count; i++) {
                const textareaWrapper = document.createElement('div');
                textareaWrapper.className = 'split-textarea-wrapper';
                textareaWrapper.innerHTML = `
                    <div class="split-textarea-header">
                        <span>Delivery ${i + 1}</span>
                        <span class="delivery-status delivery-status-on-time" id="deliveryStatus${i}">Not analyzed</span>
                    </div>
                    <textarea 
                        id="orderDetails${i}" 
                        placeholder="Paste order details for Delivery ${i + 1}&#10;Make sure to expand the rider delivery to get the timeline events"
                        spellcheck="false">
                    </textarea>
                `;
                splitContainer.appendChild(textareaWrapper);
            }
            
            // Clear any previous results
            clearSplitResults();
        }
        
        // Function to clear split results
        function clearSplitResults() {
            splitDeliveriesData.deliveries = [];
            splitDeliveriesData.deliveryResults = [];
            splitDeliveriesData.finalResult = null;
            
            // Hide split deliveries summary
            document.getElementById('splitDeliveriesSummary').style.display = 'none';
        }
        
        // Function to handle split deliveries checkbox change
        function handleSplitDeliveriesChange() {
            const splitCheckbox = document.getElementById('splitDeliveries');
            const singleInputWrapper = document.getElementById('singleInputWrapper');
            const splitContainer = document.getElementById('splitTextareasContainer');
            
            if (splitCheckbox.checked) {
                showSplitDeliveriesPopup();
            } else {
                // Reset to single input mode
                splitDeliveriesData.isSplitActive = false;
                splitDeliveriesData.numberOfDeliveries = 0;
                splitContainer.style.display = 'none';
                singleInputWrapper.style.display = 'block';
                
                // Clear split results
                clearSplitResults();
            }
        }
        
        // Function to get order details based on split mode
        function getOrderDetailsForAnalysis() {
            const isSplitActive = splitDeliveriesData.isSplitActive;
            
            if (!isSplitActive) {
                // Single delivery mode
                return [{
                    text: document.getElementById('orderDetails').value.trim(),
                    index: 0
                }];
            } else {
                // Split deliveries mode
                const deliveries = [];
                for (let i = 0; i < splitDeliveriesData.numberOfDeliveries; i++) {
                    deliveries.push({
                        text: document.getElementById(`orderDetails${i}`).value.trim(),
                        index: i
                    });
                }
                return deliveries;
            }
        }
        
        // Updated analyzeOrder function to handle split deliveries
        function analyzeOrder() {
            const errorDiv = document.getElementById('errorMessage');
            const loadingDiv = document.getElementById('loading');
            const resultContainer = document.getElementById('resultContainer');
            const analyzeBtn = document.getElementById('analyzeBtn');
            
            // Get checkbox state
            const isLocalShopAE = document.getElementById('localShopAE').checked;
            const isSplitActive = splitDeliveriesData.isSplitActive;
            const autoShowPopup = document.getElementById('autoShowPopup').checked;
            
            // Get order details based on mode
            const deliveries = getOrderDetailsForAnalysis();
            
            // Reset UI
            errorDiv.style.display = 'none';
            resultContainer.style.display = 'none';
            
            // Validate input
            if (isSplitActive) {
                // Check if all deliveries have data
                const emptyDeliveries = deliveries.filter(d => !d.text);
                if (emptyDeliveries.length > 0) {
                    errorDiv.textContent = `Please paste order details for all deliveries. Missing: ${emptyDeliveries.map(d => `Delivery ${d.index + 1}`).join(', ')}`;
                    errorDiv.style.display = 'flex';
                    return;
                }
            } else {
                // Single delivery validation
                if (!deliveries[0].text) {
                    errorDiv.textContent = 'Please paste order details in the text area';
                    errorDiv.style.display = 'flex';
                    return;
                }
            }
            
            // Show loading
            loadingDiv.style.display = 'block';
            analyzeBtn.disabled = true;
            analyzeBtn.innerHTML = '<span class="btn-icon">‚è≥</span><span>Processing...</span>';
            
            // Process deliveries with delay to show loading
            setTimeout(() => {
                try {
                    if (isSplitActive) {
                        processSplitDeliveries(deliveries, isLocalShopAE, autoShowPopup);
                    } else {
                        processSingleDelivery(deliveries[0], isLocalShopAE, autoShowPopup);
                    }
                    
                    // Show result
                    resultContainer.style.display = 'block';
                    
                } catch (error) {
                    errorDiv.textContent = 'Error processing details: ' + error.message;
                    errorDiv.style.display = 'flex';
                    console.error('Processing error:', error);
                } finally {
                    // Hide loading
                    loadingDiv.style.display = 'none';
                    analyzeBtn.disabled = false;
                    analyzeBtn.innerHTML = '<span class="btn-icon">üöÄ</span><span>Analyze Order</span>';
                }
            }, 500);
        }
        
        // Function to process single delivery
        function processSingleDelivery(delivery, isLocalShopAE, autoShowPopup) {
            const result = processOrderDetails(delivery.text, isLocalShopAE);
            debugData = result;
            
            // Check for incomplete order data
            if (!result.columns.F || result.columns.F === '' || result.columns.F === 'N/A') {
                throw new Error('Incomplete order data - Could not find Queued At time');
            }
            
            // Calculate picked up by another rider
            const pickedUpResult = calculatePickedUpByAnotherRider(delivery.text);
            
            // Store picked up analysis data
            pickedUpAnalysisData.patterns = pickedUpResult.patterns;
            
            // Get original calculations
            const originalVendorDelay = parseFloat(result.columns.V.replace('s', '') || 0);
            const originalSystemLate = parseFloat(result.columns.U.replace('s', '') || 0);
            const originalRiderBeforePickup = parseFloat(result.columns.X.replace('s', '') || 0);
            const originalRiderAfterPickup = parseFloat(result.columns.W.replace('s', '') || 0);
            const originalTotalPickedUp = pickedUpResult.totalSeconds;
            const originalTotalRiderDelay = originalRiderBeforePickup + originalRiderAfterPickup;
            const originalLongDispatch = Math.max(0, originalSystemLate - originalTotalPickedUp);
            
            pickedUpAnalysisData.originalCalculations = {
                totalPickedUp: originalTotalPickedUp,
                vendorDelay: originalVendorDelay,
                systemLate: originalSystemLate,
                longDispatch: originalLongDispatch,
                totalRiderDelay: originalTotalRiderDelay,
                riderBeforePickup: originalRiderBeforePickup,
                riderAfterPickup: originalRiderAfterPickup,
                originalZResult: result.columns.Z
            };
            
            // Initialize adjusted calculations
            pickedUpAnalysisData.adjustedCalculations = { ...pickedUpAnalysisData.originalCalculations };
            pickedUpAnalysisData.checkedPatterns = new Set();
            
            // Update result display
            updateResultDisplay(result);
            
            // Check if we need to do Long Dispatch comparison
            const finalZResult = checkLongDispatchComparison(result, pickedUpResult);
            
            // Update final result if changed by comparison
            if (finalZResult !== result.columns.Z) {
                updateFinalResult(finalZResult);
                result.columns.Z = finalZResult;
            }
            
            // Check if result is "Picked up by another rider" and show popup automatically if enabled
            if (autoShowPopup && (finalZResult === "Picked up by another rider" || finalZResult.includes("Picked up by another rider"))) {
                setTimeout(() => {
                    showPickedUpPopup();
                }, 300);
            }
        }
        
        // Function to process split deliveries
        function processSplitDeliveries(deliveries, isLocalShopAE, autoShowPopup) {
            // Reset delivery results
            splitDeliveriesData.deliveryResults = [];
            
            // Process each delivery
            deliveries.forEach((delivery, index) => {
                try {
                    const result = processOrderDetails(delivery.text, isLocalShopAE);
                    
                    // Check for incomplete order data
                    if (!result.columns.F || result.columns.F === '' || result.columns.F === 'N/A') {
                        throw new Error(`Delivery ${index + 1}: Incomplete order data - Could not find Queued At time`);
                    }
                    
                    // Calculate picked up by another rider
                    const pickedUpResult = calculatePickedUpByAnotherRider(delivery.text);
                    
                    // Store picked up analysis data for this delivery
                    const originalVendorDelay = parseFloat(result.columns.V.replace('s', '') || 0);
                    const originalSystemLate = parseFloat(result.columns.U.replace('s', '') || 0);
                    const originalRiderBeforePickup = parseFloat(result.columns.X.replace('s', '') || 0);
                    const originalRiderAfterPickup = parseFloat(result.columns.W.replace('s', '') || 0);
                    const originalTotalPickedUp = pickedUpResult.totalSeconds || 0;
                    const originalTotalRiderDelay = originalRiderBeforePickup + originalRiderAfterPickup;
                    const originalLongDispatch = Math.max(0, originalSystemLate - originalTotalPickedUp);
                    
                    // Check Long Dispatch comparison
                    const finalZResult = checkLongDispatchComparison(result, pickedUpResult);
                    result.columns.Z = finalZResult;
                    
                    // Calculate adjusted delays based on the Long Dispatch comparison
                    let longDispatchDelay = parseFloat(result.columns.U.replace('s', '') || 0);
                    let pickedUpDelay = pickedUpResult.totalSeconds || 0;
                    
                    // If result is "Picked up by another rider", adjust long dispatch to 0
                    // If result is "Long Dispatch", adjust picked up to 0
                    if (finalZResult === "Picked up by another rider") {
                        // Long dispatch should be set to 0 when it's picked up by another rider
                        longDispatchDelay = 0;
                    } else if (finalZResult === "Long Dispatch") {
                        // Picked up should be set to 0 when it's long dispatch
                        pickedUpDelay = 0;
                    }
                    
                    // Store delivery result with picked up analysis data
                    splitDeliveriesData.deliveryResults.push({
                        index: index,
                        result: result,
                        pickedUpResult: pickedUpResult,
                        delays: {
                            vendorLate: parseFloat(result.columns.V.replace('s', '') || 0),
                            riderLate: parseFloat(result.columns.X.replace('s', '') || 0) + parseFloat(result.columns.W.replace('s', '') || 0),
                            longDispatch: longDispatchDelay, // Use adjusted value
                            pickedUp: pickedUpDelay // Use adjusted value
                        },
                        pickedUpAnalysisData: {
                            patterns: pickedUpResult.patterns,
                            originalCalculations: {
                                totalPickedUp: originalTotalPickedUp,
                                vendorDelay: originalVendorDelay,
                                systemLate: originalSystemLate,
                                longDispatch: originalLongDispatch,
                                totalRiderDelay: originalTotalRiderDelay,
                                riderBeforePickup: originalRiderBeforePickup,
                                riderAfterPickup: originalRiderAfterPickup,
                                originalZResult: result.columns.Z
                            },
                            adjustedCalculations: {
                                totalPickedUp: originalTotalPickedUp,
                                vendorDelay: originalVendorDelay,
                                systemLate: originalSystemLate,
                                longDispatch: originalLongDispatch,
                                totalRiderDelay: originalTotalRiderDelay,
                                riderBeforePickup: originalRiderBeforePickup,
                                riderAfterPickup: originalRiderAfterPickup,
                                originalZResult: result.columns.Z
                            },
                            checkedPatterns: new Set()
                        }
                    });
                    
                    // Update delivery status
                    updateDeliveryStatus(index, result.columns.Z);
                    
                } catch (error) {
                    // Mark delivery as error
                    updateDeliveryStatus(index, 'Error: ' + error.message);
                    throw error;
                }
            });
            
            // Calculate final result based on highest delay
            calculateFinalSplitResult();
            
            // Update display
            updateSplitDeliveriesSummary();
            updateFinalResult(splitDeliveriesData.finalResult);
            
            // Check if we should show popup automatically - UPDATED FOR MULTI-DELIVERY
            if (autoShowPopup) {
                // Find ALL deliveries with "Picked up by another rider" result
                const pickedUpDeliveries = [];
                
                for (let i = 0; i < splitDeliveriesData.deliveryResults.length; i++) {
                    const deliveryResult = splitDeliveriesData.deliveryResults[i];
                    if (deliveryResult.result.columns.Z === "Picked up by another rider" || 
                        deliveryResult.result.columns.Z.includes("Picked up by another rider")) {
                        pickedUpDeliveries.push(i);
                    }
                }
                
                // Show popup automatically if there are deliveries with "Picked up by another rider"
                if (pickedUpDeliveries.length > 0) {
                    setTimeout(() => {
                        showMultiDeliveryPickedUpPopup(pickedUpDeliveries);
                    }, 800);
                }
            }
        }
        
        // NEW FUNCTION: Show popup for multiple deliveries with Picked up by another rider
        function showMultiDeliveryPickedUpPopup(deliveryIndices) {
            // Store the delivery indices for the popup
            multiDeliveryPopupData.deliveries = deliveryIndices;
            multiDeliveryPopupData.currentTabIndex = 0;
            
            // Generate tabs for each delivery
            const deliveryTabs = document.getElementById('deliveryTabs');
            deliveryTabs.innerHTML = '';
            
            deliveryIndices.forEach((deliveryIndex, tabIndex) => {
                const deliveryResult = splitDeliveriesData.deliveryResults[deliveryIndex];
                const tab = document.createElement('div');
                tab.className = `delivery-tab ${tabIndex === 0 ? 'active' : ''}`;
                tab.dataset.tabIndex = tabIndex;
                tab.dataset.deliveryIndex = deliveryIndex;
                tab.innerHTML = `
                    <span>Delivery ${deliveryIndex + 1}</span>
                    <span class="tab-badge">${deliveryResult.pickedUpResult.patterns.length} stages</span>
                `;
                tab.onclick = () => switchDeliveryTab(tabIndex, deliveryIndex);
                deliveryTabs.appendChild(tab);
            });
            
            // Load the first delivery's data
            switchDeliveryTab(0, deliveryIndices[0]);
            
            // Show the popup
            const popup = document.getElementById('pickedUpPopup');
            popup.style.display = 'flex';
            document.body.style.overflow = 'hidden';
            
            // Show the delivery info header
            document.getElementById('deliveryInfoHeader').style.display = 'block';
            
            // 1Ô∏è‚É£ Update delivery indicator
            updateDeliveryIndicator(tabIndex, deliveryIndices.length);
        }
        
        // NEW FUNCTION: Update delivery indicator
        function updateDeliveryIndicator(currentIndex, totalDeliveries) {
            const deliveryIndicator = document.getElementById('deliveryIndicator');
            const currentDisplay = document.getElementById('currentDeliveryDisplay');
            const totalDisplay = document.getElementById('totalDeliveriesDisplay');
            
            if (deliveryIndicator) {
                deliveryIndicator.style.display = 'flex';
                currentDisplay.textContent = currentIndex + 1;
                totalDisplay.textContent = totalDeliveries;
            }
        }
        
        // NEW FUNCTION: Switch between delivery tabs
        function switchDeliveryTab(tabIndex, deliveryIndex) {
            // Update active tab
            const tabs = document.querySelectorAll('.delivery-tab');
            tabs.forEach(tab => {
                tab.classList.remove('active');
                if (parseInt(tab.dataset.tabIndex) === tabIndex) {
                    tab.classList.add('active');
                }
            });
            
            // Update current tab index
            multiDeliveryPopupData.currentTabIndex = tabIndex;
            
            // Load the delivery data
            const deliveryResult = splitDeliveriesData.deliveryResults[deliveryIndex];
            currentEditingDeliveryIndex = deliveryIndex;
            
            // Load the delivery's picked up analysis data
            pickedUpAnalysisData = {
                patterns: deliveryResult.pickedUpAnalysisData.patterns,
                originalCalculations: { ...deliveryResult.pickedUpAnalysisData.originalCalculations },
                adjustedCalculations: { ...deliveryResult.pickedUpAnalysisData.adjustedCalculations },
                checkedPatterns: new Set([...deliveryResult.pickedUpAnalysisData.checkedPatterns])
            };
            
            // Update delivery info header
            document.getElementById('currentDeliveryNumber').textContent = `#${deliveryIndex + 1}`;
            document.getElementById('currentDeliveryOrderId').textContent = deliveryResult.result.columns.B || 'N/A';
            document.getElementById('currentDeliveryStatus').textContent = deliveryResult.result.columns.Z;
            document.getElementById('currentDeliveryQueuedCount').textContent = deliveryResult.pickedUpResult.patterns.length;
            
            // Update the queued stages list
            updateQueuedStagesList();
            
            // Update popup summary
            updatePopupSummary();
            
            // 1Ô∏è‚É£ Update delivery indicator
            updateDeliveryIndicator(tabIndex, multiDeliveryPopupData.deliveries.length);
        }
        
        // UPDATED FUNCTION: Update queued stages list
        function updateQueuedStagesList() {
            const queuedStageList = document.getElementById('queuedStageList');
            
            // Clear previous content
            queuedStageList.innerHTML = '';
            
            if (pickedUpAnalysisData.patterns.length === 0) {
                queuedStageList.innerHTML = `
                    <div class="no-queued-stages">
                        <p>No Queued stages found in Accepted ‚Üí Queued patterns.</p>
                        <p>The order analysis will proceed with the original calculations.</p>
                    </div>
                `;
            } else {
                // Create checkboxes for each queued stage
                pickedUpAnalysisData.patterns.forEach((pattern, index) => {
                    const stageItem = document.createElement('div');
                    stageItem.className = 'queued-stage-item';
                    const isChecked = pickedUpAnalysisData.checkedPatterns.has(index);
                    stageItem.innerHTML = `
                        <div class="queued-stage-checkbox">
                            <input type="checkbox" 
                                   id="queuedStage${index}" 
                                   data-index="${index}"
                                   data-duration="${pattern.durationSeconds}"
                                   onchange="updateCalculations(${index})"
                                   ${isChecked ? 'checked' : ''}>
                        </div>
                        <div class="queued-stage-details">
                            <div class="queued-stage-timestamp">
                                <span>‚è∞</span>
                                <span>Queued at: ${pattern.queuedTime}</span>
                            </div>
                            <div class="queued-stage-label">
                                <label for="queuedStage${index}">
                                    Is it a late preparation? (Duration: ${pattern.durationMinutes} min)
                                </label>
                            </div>
                        </div>
                    `;
                    queuedStageList.appendChild(stageItem);
                });
            }
        }
        
        // Function to update delivery status
        function updateDeliveryStatus(index, status) {
            const statusElement = document.getElementById(`deliveryStatus${index}`);
            if (statusElement) {
                statusElement.textContent = status;
                
                // Update status class
                statusElement.className = 'delivery-status ';
                if (status.includes('Before PDT')) {
                    statusElement.classList.add('delivery-status-before-pdt');
                } else if (status.includes('Vendor Late')) {
                    statusElement.classList.add('delivery-status-vendor-late');
                } else if (status.includes('Rider Late')) {
                    statusElement.classList.add('delivery-status-rider-late');
                } else if (status.includes('Long Dispatch')) {
                    statusElement.classList.add('delivery-status-long-dispatch');
                } else if (status.includes('Picked up by another rider')) {
                    statusElement.classList.add('delivery-status-picked-up-another-rider');
                } else if (status.includes('Error')) {
                    statusElement.classList.add('delivery-status-rider-late'); // Use rider late style for errors
                } else {
                    statusElement.classList.add('delivery-status-on-time');
                }
            }
        }
        
        // Function to calculate final result for split deliveries
        function calculateFinalSplitResult() {
            if (splitDeliveriesData.deliveryResults.length === 0) {
                splitDeliveriesData.finalResult = "On Time";
                return;
            }
            
            // Find the highest delay across all deliveries
            let maxDelay = 0;
            let maxDelayType = '';
            let deliveryWithMaxDelay = null;
            
            // Check each delivery
            splitDeliveriesData.deliveryResults.forEach(deliveryResult => {
                const delays = deliveryResult.delays;
                
                // Check each delay type
                const delayTypes = [
                    { type: 'Vendor Late', value: delays.vendorLate },
                    { type: 'Rider Late', value: delays.riderLate },
                    { type: 'Long Dispatch', value: delays.longDispatch },
                    { type: 'Picked up by another rider', value: delays.pickedUp }
                ];
                
                delayTypes.forEach(delay => {
                    if (delay.value > maxDelay) {
                        maxDelay = delay.value;
                        maxDelayType = delay.type;
                        deliveryWithMaxDelay = deliveryResult.index;
                    }
                });
            });
            
            // Determine final result
            if (maxDelay > 0) {
                splitDeliveriesData.finalResult = maxDelayType;
            } else {
                // Check if any delivery is "Before PDT"
                const beforePDTDelivery = splitDeliveriesData.deliveryResults.find(d => 
                    d.result.columns.Z === "Before PDT"
                );
                
                if (beforePDTDelivery) {
                    splitDeliveriesData.finalResult = "Before PDT";
                } else {
                    splitDeliveriesData.finalResult = "On Time";
                }
            }
            
            console.log(`Split Deliveries Final Result: ${splitDeliveriesData.finalResult} (max delay: ${maxDelay}s from Delivery ${deliveryWithMaxDelay + 1})`);
        }
        
        // Function to update split deliveries summary
        function updateSplitDeliveriesSummary() {
            const summaryDiv = document.getElementById('splitDeliveriesSummary');
            const resultsGrid = document.getElementById('deliveryResultsGrid');
            
            // Show summary
            summaryDiv.style.display = 'block';
            
            // Generate results grid
            resultsGrid.innerHTML = '';
            
            splitDeliveriesData.deliveryResults.forEach(deliveryResult => {
                const result = deliveryResult.result;
                const delays = deliveryResult.delays;
                const isPickedUp = result.columns.Z.includes("Picked up by another rider");
                
                const card = document.createElement('div');
                card.className = `delivery-result-card ${isPickedUp ? 'picked-up-clickable' : ''}`;
                card.dataset.index = deliveryResult.index;
                
                if (isPickedUp) {
                    card.onclick = () => showMultiDeliveryPickedUpPopup([deliveryResult.index]);
                }
                
                card.innerHTML = `
                    <div class="delivery-result-header">
                        <div class="delivery-number">Delivery ${deliveryResult.index + 1}</div>
                        <div class="delivery-status ${getStatusClass(result.columns.Z)}">${result.columns.Z}</div>
                    </div>
                    <div class="delivery-details">
                        <div class="delivery-detail">
                            <span class="delivery-detail-label">Order ID</span>
                            <span class="delivery-detail-value">${result.columns.B || 'N/A'}</span>
                        </div>
                        <div class="delivery-detail">
                            <span class="delivery-detail-label">Country</span>
                            <span class="delivery-detail-value">${result.columns.C || 'N/A'}</span>
                        </div>
                        <div class="delivery-detail">
                            <span class="delivery-detail-label">Order Date</span>
                            <span class="delivery-detail-value">${result.columns.D || 'N/A'}</span>
                        </div>
                        <div class="delivery-detail">
                            <span class="delivery-detail-label">Order Time</span>
                            <span class="delivery-detail-value">${result.columns.E || 'N/A'}</span>
                        </div>
                    </div>
                    <div class="delivery-delay-values">
                        <span class="delay-badge">Vendor: ${delays.vendorLate}s</span>
                        <span class="delay-badge">Rider: ${delays.riderLate}s</span>
                        <span class="delay-badge">Long Dispatch: ${delays.longDispatch}s</span>
                        <span class="delay-badge">Picked Up: ${delays.pickedUp}s</span>
                    </div>
                    ${isPickedUp ? '<div class="info-note" style="margin-top: 8px; font-size: 0.8rem; color: #805ad5;">Click to analyze picked up by another rider details</div>' : ''}
                `;
                resultsGrid.appendChild(card);
            });
            
            // Update final result display
            updateFinalResult(splitDeliveriesData.finalResult);
            
            // Update basic info grid with summary
            updateBasicInfoGridForSplit();
        }
        
        // Helper function to get status class
        function getStatusClass(status) {
            if (status.includes('Before PDT')) return 'delivery-status-before-pdt';
            if (status.includes('Vendor Late')) return 'delivery-status-vendor-late';
            if (status.includes('Rider Late')) return 'delivery-status-rider-late';
            if (status.includes('Long Dispatch')) return 'delivery-status-long-dispatch';
            if (status.includes('Picked up by another rider')) return 'delivery-status-picked-up-another-rider';
            if (status.includes('Error')) return 'delivery-status-rider-late';
            return 'delivery-status-on-time';
        }
        
        // Function to update basic info grid for split deliveries
        function updateBasicInfoGridForSplit() {
            const basicInfoGrid = document.getElementById('basicInfoGrid');
            
            let cardsHTML = '';
            
            // Show split deliveries summary info
            const summaryCards = [
                {
                    label: 'Split Deliveries',
                    value: splitDeliveriesData.numberOfDeliveries,
                    icon: 'üì¶'
                },
                {
                    label: 'Final Result',
                    value: splitDeliveriesData.finalResult,
                    icon: 'üèÜ'
                },
                {
                    label: 'Deliveries Analyzed',
                    value: splitDeliveriesData.deliveryResults.length,
                    icon: '‚úÖ'
                }
            ];
            
            summaryCards.forEach(card => {
                cardsHTML += `
                    <div class="info-card">
                        <div class="info-label">
                            <span>${card.icon}</span>
                            ${card.label}
                        </div>
                        <div class="info-value">
                            ${card.value}
                        </div>
                    </div>
                `;
            });
            
            basicInfoGrid.innerHTML = cardsHTML;
        }
        
        // Function: Show modern popup for picked up by another rider analysis for split delivery
        function showPickedUpPopupForSplitDelivery(deliveryIndex) {
            currentEditingDeliveryIndex = deliveryIndex;
            const deliveryResult = splitDeliveriesData.deliveryResults[deliveryIndex];
            
            // Load the delivery's picked up analysis data
            pickedUpAnalysisData = {
                patterns: deliveryResult.pickedUpAnalysisData.patterns,
                originalCalculations: { ...deliveryResult.pickedUpAnalysisData.originalCalculations },
                adjustedCalculations: { ...deliveryResult.pickedUpAnalysisData.adjustedCalculations },
                checkedPatterns: new Set([...deliveryResult.pickedUpAnalysisData.checkedPatterns])
            };
            
            showPickedUpPopup();
        }
        
        // UPDATED FUNCTION: Show picked up popup (for single delivery)
        function showPickedUpPopup() {
            const popup = document.getElementById('pickedUpPopup');
            
            // Hide tabs and delivery info header for single delivery
            document.getElementById('deliveryTabs').style.display = 'none';
            document.getElementById('deliveryInfoHeader').style.display = 'none';
            
            // Hide delivery indicator for single delivery
            document.getElementById('deliveryIndicator').style.display = 'none';
            
            // Update the queued stages list
            updateQueuedStagesList();
            
            // Update summary with current values
            updatePopupSummary();
            
            // Show popup
            popup.style.display = 'flex';
            
            // Prevent body scroll
            document.body.style.overflow = 'hidden';
        }
        
        // Function: Close popup
        function closePopup() {
            const popup = document.getElementById('pickedUpPopup');
            popup.style.display = 'none';
            document.body.style.overflow = 'auto';
            
            // Reset current editing index
            currentEditingDeliveryIndex = null;
            
            // Reset multi-delivery data
            multiDeliveryPopupData.deliveries = [];
            multiDeliveryPopupData.currentTabIndex = 0;
            
            // Reset tabs and header visibility
            document.getElementById('deliveryTabs').style.display = 'flex';
            document.getElementById('deliveryInfoHeader').style.display = 'block';
            
            // Hide delivery indicator
            document.getElementById('deliveryIndicator').style.display = 'none';
            
            // Restore original calculations when closing without applying
            restoreOriginalCalculations();
        }
        
        // Function: Update calculations when checkbox is checked/unchecked
        function updateCalculations(patternIndex) {
            const checkbox = document.querySelector(`#queuedStage${patternIndex}`);
            const pattern = pickedUpAnalysisData.patterns[patternIndex];
            
            if (checkbox.checked) {
                pickedUpAnalysisData.checkedPatterns.add(patternIndex);
                // Add pattern duration to vendor delay
                pickedUpAnalysisData.adjustedCalculations.vendorDelay += pattern.durationSeconds;
                // Subtract pattern duration from total picked up
                pickedUpAnalysisData.adjustedCalculations.totalPickedUp -= pattern.durationSeconds;
                // ALSO subtract pattern duration from system late (U)
                pickedUpAnalysisData.adjustedCalculations.systemLate -= pattern.durationSeconds;
            } else {
                pickedUpAnalysisData.checkedPatterns.delete(patternIndex);
                // Remove pattern duration from vendor delay
                pickedUpAnalysisData.adjustedCalculations.vendorDelay -= pattern.durationSeconds;
                // Add pattern duration back to total picked up
                pickedUpAnalysisData.adjustedCalculations.totalPickedUp += pattern.durationSeconds;
                // ALSO add pattern duration back to system late (U)
                pickedUpAnalysisData.adjustedCalculations.systemLate += pattern.durationSeconds;
            }
            
            // Ensure values don't go negative
            if (pickedUpAnalysisData.adjustedCalculations.totalPickedUp < 0) {
                pickedUpAnalysisData.adjustedCalculations.totalPickedUp = 0;
            }
            if (pickedUpAnalysisData.adjustedCalculations.vendorDelay < 0) {
                pickedUpAnalysisData.adjustedCalculations.vendorDelay = 0;
            }
            if (pickedUpAnalysisData.adjustedCalculations.systemLate < 0) {
                pickedUpAnalysisData.adjustedCalculations.systemLate = 0;
            }
            
            // Recalculate Long Dispatch using ADJUSTED System Late value
            const adjustedSystemLate = pickedUpAnalysisData.adjustedCalculations.systemLate || 0;
            const totalPickedUp = pickedUpAnalysisData.adjustedCalculations.totalPickedUp || 0;
            
            let longDispatch = adjustedSystemLate - totalPickedUp;
            if (isNaN(longDispatch) || longDispatch < 0) {
                longDispatch = 0;
            }
            
            pickedUpAnalysisData.adjustedCalculations.longDispatch = longDispatch;
            
            // Update popup summary
            updatePopupSummary();
            
            // Live update the main result display
            liveUpdateResultDisplay();
        }
        
        // Function: Update popup summary
        function updatePopupSummary() {
            // Format values to avoid NaN display
            const formatValue = (value) => {
                const num = Math.round(value || 0);
                return isNaN(num) ? '0s' : num + 's';
            };
            
            document.getElementById('summaryTotalPickedUp').textContent = 
                formatValue(pickedUpAnalysisData.adjustedCalculations.totalPickedUp);
            document.getElementById('summaryVendorDelay').textContent = 
                formatValue(pickedUpAnalysisData.adjustedCalculations.vendorDelay);
            document.getElementById('summarySystemLate').textContent = 
                formatValue(pickedUpAnalysisData.adjustedCalculations.systemLate);
            document.getElementById('summaryTotalRiderDelay').textContent = 
                formatValue(pickedUpAnalysisData.adjustedCalculations.totalRiderDelay);
        }
        
        // Function: Live update result display
        function liveUpdateResultDisplay() {
            // Update the main result display with adjusted values
            const finalResultDiv = document.getElementById('finalResult');
            
            // Get all delay values for comparison - ensure they're numbers
            const vendorDelay = Number(pickedUpAnalysisData.adjustedCalculations.vendorDelay) || 0;
            const systemLate = Number(pickedUpAnalysisData.adjustedCalculations.systemLate) || 0;
            const longDispatch = Number(pickedUpAnalysisData.adjustedCalculations.longDispatch) || 0;
            const totalRiderDelay = Number(pickedUpAnalysisData.adjustedCalculations.totalRiderDelay) || 0;
            const totalPickedUp = Number(pickedUpAnalysisData.adjustedCalculations.totalPickedUp) || 0;
            
            console.log("=== Live Update Calculations ===");
            console.log("Total Picked Up:", totalPickedUp, "type:", typeof totalPickedUp);
            console.log("Vendor Delay:", vendorDelay, "type:", typeof vendorDelay);
            console.log("System Late (adjusted):", systemLate, "type:", typeof systemLate);
            console.log("Long Dispatch:", longDispatch, "type:", typeof longDispatch);
            console.log("Total Rider Delay:", totalRiderDelay, "type:", typeof totalRiderDelay);
            
            // Find the maximum value among ALL delay types
            const delayValues = {
                'Picked up by another rider': totalPickedUp,
                'Vendor Late': vendorDelay,
                'Long Dispatch': longDispatch,
                'Rider Late': totalRiderDelay
            };
            
            console.log("Delay values for comparison:", delayValues);
            
            // Find the maximum value
            let maxDelay = -1;
            let maxDelayType = '';
            
            for (const [type, value] of Object.entries(delayValues)) {
                const numValue = Number(value) || 0;
                if (numValue > maxDelay) {
                    maxDelay = numValue;
                    maxDelayType = type;
                }
            }
            
            console.log("Maximum delay:", maxDelayType, "with", maxDelay, "seconds");
            
            // Determine final result based on highest delay
            let newZResult = "On Time";
            
            if (maxDelay > 0) {
                // SIMPLE LOGIC: The highest delay type wins
                newZResult = maxDelayType;
                
                console.log("Result:", newZResult, "(highest delay)");
            }
            
            console.log("Final result determined:", newZResult);
            
            // Update final result display
            updateFinalResult(newZResult);
        }
        
        // UPDATED FUNCTION: Apply changes for popup (handles both single and multi-delivery)
        function applyPopupChanges() {
            if (multiDeliveryPopupData.deliveries.length > 0) {
                // Apply changes for current tab in multi-delivery popup
                const currentTabIndex = multiDeliveryPopupData.currentTabIndex;
                const deliveryIndex = multiDeliveryPopupData.deliveries[currentTabIndex];
                
                // Apply changes for this delivery
                applyPopupChangesForSplitDelivery(deliveryIndex);
                
                // Check if there are more deliveries to process
                if (currentTabIndex < multiDeliveryPopupData.deliveries.length - 1) {
                    // Switch to next tab
                    const nextTabIndex = currentTabIndex + 1;
                    const nextDeliveryIndex = multiDeliveryPopupData.deliveries[nextTabIndex];
                    switchDeliveryTab(nextTabIndex, nextDeliveryIndex);
                    
                    // 2Ô∏è‚É£ Remove/hide the notification - Commented out the alert
                    // No toast, alert, banner, or message should appear
                    // alert(`Changes applied to Delivery ${deliveryIndex + 1}. Now editing Delivery ${nextDeliveryIndex + 1}.`);
                } else {
                    // All deliveries processed, close popup
                    // 2Ô∏è‚É£ Remove/hide the notification - Commented out the alert
                    // alert(`Changes applied to all ${multiDeliveryPopupData.deliveries.length} deliveries.`);
                    closePopup();
                }
            } else if (currentEditingDeliveryIndex !== null) {
                // Apply changes for single split delivery
                applyPopupChangesForSplitDelivery(currentEditingDeliveryIndex);
                closePopup();
            } else {
                // Apply changes for single delivery
                applyPopupChangesForSingleDelivery();
                closePopup();
            }
        }
        
        // Function: Apply changes for single delivery
        function applyPopupChangesForSingleDelivery() {
            // Update the main calculations with adjusted values
            if (debugData && debugData.columns) {
                // Update vendor delay (V)
                const newVendorDelay = Math.round(pickedUpAnalysisData.adjustedCalculations.vendorDelay || 0);
                debugData.columns.V = newVendorDelay + "s";
                
                // Update system late (U) if it was adjusted (for display only)
                const newSystemLate = Math.round(pickedUpAnalysisData.adjustedCalculations.systemLate || 0);
                debugData.columns.U = newSystemLate + "s";
                
                // Update formulas to reflect changes
                const vendorIndex = debugData.formulas.findIndex(f => f.includes('V: Vendor Late Duration'));
                if (vendorIndex !== -1) {
                    const originalFormula = debugData.formulas[vendorIndex];
                    debugData.formulas[vendorIndex] = originalFormula.replace(
                        / = \d+s$/,
                        ` = ${debugData.columns.V} (adjusted for late preparation)`
                    );
                }
                
                const systemLateIndex = debugData.formulas.findIndex(f => f.includes('U: System Late Duration'));
                if (systemLateIndex !== -1) {
                    const originalFormula = debugData.formulas[systemLateIndex];
                    debugData.formulas[systemLateIndex] = originalFormula.replace(
                        / = \d+s$/,
                        ` = ${debugData.columns.U} (adjusted for late preparation)`
                    );
                }
                
                // Force recalculation of Z result based on highest delay
                const vendorDelay = pickedUpAnalysisData.adjustedCalculations.vendorDelay || 0;
                const longDispatch = pickedUpAnalysisData.adjustedCalculations.longDispatch || 0;
                const totalRiderDelay = pickedUpAnalysisData.adjustedCalculations.totalRiderDelay || 0;
                const totalPickedUp = pickedUpAnalysisData.adjustedCalculations.totalPickedUp || 0;
                
                // Find the maximum value among ALL delay types
                const delayValues = {
                    'Picked up by another rider': totalPickedUp,
                    'Vendor Late': vendorDelay,
                    'Long Dispatch': longDispatch,
                    'Rider Late': totalRiderDelay
                };
                
                let maxDelay = 0;
                let finalZResult = "On Time";
                
                for (const [type, value] of Object.entries(delayValues)) {
                    const numValue = Number(value) || 0;
                    if (numValue > maxDelay) {
                        maxDelay = numValue;
                        finalZResult = type;
                    }
                }
                
                // SIMPLE RULE: Highest delay type wins (no special cases)
                debugData.columns.Z = finalZResult;
                
                // Update display
                updateResultDisplay(debugData);
            }
        }
        
        // Function: Apply changes for split delivery
        function applyPopupChangesForSplitDelivery(deliveryIndex) {
            const deliveryResult = splitDeliveriesData.deliveryResults[deliveryIndex];
            
            // Update the delivery's picked up analysis data
            deliveryResult.pickedUpAnalysisData.adjustedCalculations = { ...pickedUpAnalysisData.adjustedCalculations };
            deliveryResult.pickedUpAnalysisData.checkedPatterns = new Set([...pickedUpAnalysisData.checkedPatterns]);
            
            // Update the result columns with adjusted values
            const result = deliveryResult.result;
            
            // Update vendor delay (V)
            const newVendorDelay = Math.round(pickedUpAnalysisData.adjustedCalculations.vendorDelay || 0);
            result.columns.V = newVendorDelay + "s";
            
            // Update system late (U) if it was adjusted
            const newSystemLate = Math.round(pickedUpAnalysisData.adjustedCalculations.systemLate || 0);
            result.columns.U = newSystemLate + "s";
            
            // Recalculate the Z result for this delivery
            const vendorDelay = pickedUpAnalysisData.adjustedCalculations.vendorDelay || 0;
            const longDispatch = pickedUpAnalysisData.adjustedCalculations.longDispatch || 0;
            const totalRiderDelay = pickedUpAnalysisData.adjustedCalculations.totalRiderDelay || 0;
            const totalPickedUp = pickedUpAnalysisData.adjustedCalculations.totalPickedUp || 0;
            
            // Find the maximum value among ALL delay types
            const delayValues = {
                'Picked up by another rider': totalPickedUp,
                'Vendor Late': vendorDelay,
                'Long Dispatch': longDispatch,
                'Rider Late': totalRiderDelay
            };
            
            let maxDelay = 0;
            let finalZResult = "On Time";
            
            for (const [type, value] of Object.entries(delayValues)) {
                const numValue = Number(value) || 0;
                if (numValue > maxDelay) {
                    maxDelay = numValue;
                    finalZResult = type;
                }
            }
            
            // Update the result
            result.columns.Z = finalZResult;
            
            // Update the delivery's delays
            deliveryResult.delays.vendorLate = vendorDelay;
            deliveryResult.delays.pickedUp = totalPickedUp;
            
            // If result changed to something other than "Picked up by another rider", set pickedUp to 0
            if (!finalZResult.includes("Picked up by another rider")) {
                deliveryResult.delays.pickedUp = 0;
            }
            
            // Update delivery status
            updateDeliveryStatus(deliveryIndex, finalZResult);
            
            // Recalculate final split result
            calculateFinalSplitResult();
            
            // Update split deliveries summary
            updateSplitDeliveriesSummary();
            
            // Update final result display
            updateFinalResult(splitDeliveriesData.finalResult);
        }
        
        // Function: Restore original calculations
        function restoreOriginalCalculations() {
            // Reset checked patterns
            pickedUpAnalysisData.checkedPatterns.forEach(patternIndex => {
                const checkbox = document.querySelector(`#queuedStage${patternIndex}`);
                if (checkbox) {
                    checkbox.checked = false;
                }
            });
            
            // Reset calculations to original
            pickedUpAnalysisData.checkedPatterns = new Set();
            pickedUpAnalysisData.adjustedCalculations = {
                ...pickedUpAnalysisData.originalCalculations
            };
            
            // Update display with original values
            if (currentEditingDeliveryIndex !== null) {
                // For split delivery, update that specific delivery's display
                const deliveryResult = splitDeliveriesData.deliveryResults[currentEditingDeliveryIndex];
                updateResultDisplay(deliveryResult.result);
            } else {
                // For single delivery, update the main display
                updateResultDisplay(debugData);
            }
        }
        
        // Function: Calculate picked up by another rider (kept for calculations)
        function calculatePickedUpByAnotherRider(text) {
            console.log("=== Calculating Picked up by another rider ===");
            
            const result = {
                totalSeconds: 0,
                patterns: [],
                breakdown: []
            };
            
            // Parse time string to minutes since midnight
            function parseTimeToMinutes(timeStr) {
                if (!timeStr) return null;
                
                const cleaned = timeStr.trim().toLowerCase().replace(/\s+(am|pm)/, '$1');
                const timeMatch = cleaned.match(/^(\d{1,2}):(\d{2})\s*(am|pm)$/);
                
                if (!timeMatch) {
                    console.log('No time match for visibility:', timeStr);
                    return null;
                }
                
                let hours = parseInt(timeMatch[1]);
                const minutes = parseInt(timeMatch[2]);
                const period = timeMatch[3];
                
                // Convert to 24-hour format
                if (period === 'pm') {
                    if (hours < 12) hours += 12;
                } else if (period === 'am') {
                    if (hours === 12) hours = 0;
                }
                
                return hours * 60 + minutes;
            }
            
            // Convert minutes to seconds
            function minutesToSeconds(minutes) {
                return minutes * 60;
            }
            
            // Find all lines with times and events
            const lines = text.split('\n');
            const events = [];
            
            // Collect all events with their times
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                // Look for time patterns like "9:00 PM" at the beginning of a line
                const timeMatch = line.match(/^(\d{1,2}:\d{2}\s*[APM]{2})/i);
                if (timeMatch) {
                    const timeStr = timeMatch[1];
                    const timeMinutes = parseTimeToMinutes(timeStr);
                    
                    // Check if next line has an event
                    if (i + 1 < lines.length) {
                        const nextLine = lines[i + 1].trim();
                        if (nextLine && !nextLine.match(/^\d{1,2}:\d{2}\s*[APM]{2}/i)) {
                            // This is an event line
                            events.push({
                                timeStr: timeStr,
                                timeMinutes: timeMinutes,
                                event: nextLine,
                                lineIndex: i
                            });
                            i++; // Skip the event line
                        }
                    }
                }
            }
            
            console.log("Found events:", events.length);
            
            // Find Accepted ‚Üí Queued patterns
            for (let i = 0; i < events.length; i++) {
                const currentEvent = events[i];
                
                // Look for "Accepted" events
                if (currentEvent.event.includes("Accepted") && !currentEvent.event.includes("Courier Notified")) {
                    console.log(`Found Accepted at ${currentEvent.timeStr}`);
                    
                    // Look for the next "Queued" event (could be after other events)
                    let queuedFound = false;
                    let j = i + 1;
                    
                    while (j < events.length && !queuedFound) {
                        if (events[j].event.includes("Queued") && 
                            !events[j].event.includes("Delivery Enqueued")) { // Skip initial "Queued" event
                            
                            console.log(`Found subsequent Queued at ${events[j].timeStr}`);
                            
                            // Calculate time difference
                            if (currentEvent.timeMinutes !== null && events[j].timeMinutes !== null) {
                                // Handle midnight crossing (if queued time is earlier than accepted time)
                                let timeDiffMinutes;
                                if (events[j].timeMinutes >= currentEvent.timeMinutes) {
                                    timeDiffMinutes = events[j].timeMinutes - currentEvent.timeMinutes;
                                } else {
                                    // Queued is on the next day (after midnight)
                                    timeDiffMinutes = (24 * 60 - currentEvent.timeMinutes) + events[j].timeMinutes;
                                }
                                
                                const timeDiffSeconds = minutesToSeconds(timeDiffMinutes);
                                
                                result.patterns.push({
                                    acceptedTime: currentEvent.timeStr,
                                    queuedTime: events[j].timeStr,
                                    durationMinutes: timeDiffMinutes,
                                    durationSeconds: timeDiffSeconds,
                                    acceptedEvent: currentEvent.event,
                                    queuedEvent: events[j].event
                                });
                                
                                result.totalSeconds += timeDiffSeconds;
                                queuedFound = true;
                                
                                console.log(`Pattern ${result.patterns.length}: ${currentEvent.timeStr} ‚Üí ${events[j].timeStr} = ${timeDiffMinutes} min = ${timeDiffSeconds} sec`);
                            }
                        }
                        j++;
                    }
                }
            }
            
            // Create breakdown for display
            if (result.patterns.length > 0) {
                result.breakdown = result.patterns.map((pattern, index) => {
                    return {
                        patternNumber: index + 1,
                        acceptedTime: pattern.acceptedTime,
                        queuedTime: pattern.queuedTime,
                        duration: `${pattern.durationMinutes} min (${pattern.durationSeconds} sec)`,
                        calculation: `${pattern.acceptedTime} ‚Üí ${pattern.queuedTime} = ${pattern.durationMinutes} √ó 60 = ${pattern.durationSeconds} sec`
                    };
                });
            }
            
            console.log("Picked up by another rider calculation complete:", result);
            return result;
        }
        
        // Function: Check Long Dispatch comparison (kept for calculations)
        function checkLongDispatchComparison(orderResult, pickedUpResult) {
            console.log("=== Checking Long Dispatch Comparison ===");
            
            const originalZResult = orderResult.columns.Z;
            const systemLateSeconds = parseFloat(orderResult.columns.U.replace('s', '') || 0);
            const pickedUpTotalSeconds = pickedUpResult.totalSeconds || 0;
            
            console.log("Original Z Result:", originalZResult);
            console.log("System Late (U):", systemLateSeconds, "seconds");
            console.log("Picked up by another rider:", pickedUpTotalSeconds, "seconds");
            
            // Only do comparison if original result is Long Dispatch
            if (originalZResult.includes("Long Dispatch") || originalZResult === "Long Dispatch") {
                console.log("Original result is Long Dispatch, performing comparison...");
                
                // Calculate: (System Late Duration - Picked up by another rider)
                const comparisonValue = systemLateSeconds - pickedUpTotalSeconds;
                
                console.log("Comparison value (U - Picked up):", comparisonValue);
                console.log("Picked up value:", pickedUpTotalSeconds);
                
                // Check condition: if (U - Picked up) > Picked up
                if (comparisonValue > pickedUpTotalSeconds) {
                    console.log("Condition met: (U - Picked up) > Picked up");
                    console.log(`${comparisonValue} > ${pickedUpTotalSeconds}`);
                    console.log("Result remains: Long Dispatch");
                    
                    return originalZResult; // Remain as Long Dispatch
                } else {
                    console.log("Condition NOT met: (U - Picked up) ‚â§ Picked up");
                    console.log(`${comparisonValue} ‚â§ ${pickedUpTotalSeconds}`);
                    console.log("Result changed to: Picked up by another rider");
                    
                    return "Picked up by another rider";
                }
            } else {
                console.log("Original result is not Long Dispatch, no comparison needed");
                return originalZResult;
            }
        }
        
        // Function: Update final result display with new result
        function updateFinalResult(finalResult) {
            const finalResultDiv = document.getElementById('finalResult');
            finalResultDiv.textContent = finalResult;
            
            // Update styling based on new result
            finalResultDiv.className = 'final-result ';
            
            if (finalResult === "Before PDT") {
                finalResultDiv.classList.add('result-before-pdt');
            } else if (finalResult.includes("Vendor Late")) {
                finalResultDiv.classList.add('result-vendor-late');
            } else if (finalResult.includes("Rider Late")) {
                finalResultDiv.classList.add('result-rider-late');
            } else if (finalResult.includes("Long Dispatch")) {
                finalResultDiv.classList.add('result-long-dispatch');
            } else if (finalResult.includes("Picked up by another rider")) {
                finalResultDiv.classList.add('result-picked-up-another-rider');
            } else if (finalResult !== "Before PDT") {
                finalResultDiv.classList.add('result-on-time');
            } else {
                finalResultDiv.classList.add('result-on-time');
            }
        }
        
        // NEW HELPER: Find timeline event with dual pattern search (FROM FIRST CODE)
        function findTimelineEvent(text, eventName) {
            console.log(`=== Searching for ${eventName} ===`);
            
            // Pattern 1: "Something Delivery Something" (original pattern)
            const pattern1 = new RegExp(`(\\d{1,2}:\\d{2}\\s*[ap]m)\\s+${eventName}\\s+Delivery\\s+${eventName}`, 'gi');
            const matches1 = [...text.matchAll(pattern1)];
            
            // Pattern 2: "Something -" (alternative pattern)
            const pattern2 = new RegExp(`(\\d{1,2}:\\d{2}\\s*[ap]m)\\s+${eventName}\\s*-`, 'gi');
            const matches2 = [...text.matchAll(pattern2)];
            
            console.log(`Pattern 1 matches for ${eventName}:`, matches1.length);
            console.log(`Pattern 2 matches for ${eventName}:`, matches2.length);
            
            let finalMatch = null;
            
            // Try pattern 1 first
            if (matches1.length > 0) {
                finalMatch = matches1[matches1.length - 1][0];
                console.log(`Found ${eventName} with Pattern 1:`, finalMatch);
            }
            // If pattern 1 fails, try pattern 2
            else if (matches2.length > 0) {
                finalMatch = matches2[matches2.length - 1][0];
                console.log(`Found ${eventName} with Pattern 2:`, finalMatch);
            }
            
            if (finalMatch) {
                // Extract the time from the match
                const timeMatch = finalMatch.match(/(\d{1,2}:\d{2}\s*[ap]m)/i);
                if (timeMatch) {
                    return timeMatch[1];
                }
            }
            
            console.log(`No match found for ${eventName} with either pattern`);
            return null;
        }
        
        // NEW HELPER FUNCTION: Get last queued time from text (FROM FIRST CODE)
        function getLastQueuedTime(text) {
            console.log('=== Getting last queued time ===');
            
            // Parse time string to Date object
            function parseTime(timeStr) {
                if (!timeStr) return null;
                
                const cleaned = timeStr.trim().toLowerCase().replace(/\s+(am|pm)/, '$1');
                const timeMatch = cleaned.match(/^(\d{1,2}):(\d{2})(?::(\d{2}))?\s*(am|pm)$/);
                if (!timeMatch) return null;
                
                let hours = parseInt(timeMatch[1]);
                const minutes = parseInt(timeMatch[2]);
                const seconds = timeMatch[3] ? parseInt(timeMatch[3]) : 0;
                const period = timeMatch[4];
                
                if (period === 'pm') {
                    if (hours < 12) hours += 12;
                } else if (period === 'am') {
                    if (hours === 12) hours = 0;
                }
                
                const date = new Date();
                date.setHours(hours, minutes, seconds, 0);
                return date;
            }
            
            // Find all Queued events (not Delivery Enqueued)
            const lines = text.split('\n');
            const queuedTimes = [];
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                // Look for time patterns
                const timeMatch = line.match(/^(\d{1,2}:\d{2}\s*[APM]{2})/i);
                if (timeMatch) {
                    // Check if next line contains "Queued" but not "Delivery Enqueued"
                    if (i + 1 < lines.length) {
                        const nextLine = lines[i + 1].trim();
                        if (nextLine.includes("Queued") && !nextLine.includes("Delivery Enqueued")) {
                            const time = parseTime(timeMatch[1]);
                            if (time) {
                                queuedTimes.push({
                                    time: time,
                                    timeStr: timeMatch[1],
                                    index: i,
                                    line: nextLine
                                });
                                console.log(`Found Queued at ${timeMatch[1]}: ${nextLine}`);
                            }
                        }
                    }
                }
            }
            
            // Return the last queued time (chronologically, not necessarily by index)
            if (queuedTimes.length > 0) {
                // Sort by time (latest first)
                queuedTimes.sort((a, b) => b.time - a.time);
                console.log(`Last queued time found: ${queuedTimes[0].timeStr}`);
                return queuedTimes[0].time;
            }
            
            console.log('No queued times found');
            return null;
        }
        
        function processOrderDetails(text, isLocalShopAE) {
            const result = {
                columns: {},
                timestamps: {},
                extracted: {},
                formulas: []
            };
            
            console.log('Processing text...');
            
            // Helper: Parse time string to Date object - FIXED VERSION (FROM FIRST CODE)
            function parseTime(timeStr) {
                if (!timeStr) return null;
                
                console.log('Parsing time string:', timeStr);
                
                // Clean the time string - normalize format
                let cleaned = timeStr.trim().toLowerCase();
                
                // Remove any spaces in am/pm
                cleaned = cleaned.replace(/\s+(am|pm)/, '$1');
                
                // Match time pattern
                const timeMatch = cleaned.match(/^(\d{1,2}):(\d{2})(?::(\d{2}))?\s*(am|pm)$/);
                if (!timeMatch) {
                    console.log('No time match for:', timeStr);
                    return null;
                }
                
                let hours = parseInt(timeMatch[1]);
                const minutes = parseInt(timeMatch[2]);
                const seconds = timeMatch[3] ? parseInt(timeMatch[3]) : 0;
                const period = timeMatch[4];
                
                console.log('Time components:', { hours, minutes, seconds, period });
                
                // Convert to 24-hour format - FIXED LOGIC
                if (period === 'pm') {
                    if (hours < 12) {
                        hours += 12;
                    }
                    // 12 pm stays 12 (noon)
                } else if (period === 'am') {
                    if (hours === 12) {
                        hours = 0; // 12 am is midnight
                    }
                    // All other am times stay as-is
                }
                
                // Validate
                if (hours < 0 || hours > 23 || minutes < 0 || minutes > 59 || seconds < 0 || seconds > 59) {
                    console.log('Invalid time:', hours, minutes, seconds);
                    return null;
                }
                
                const date = new Date();
                date.setHours(hours, minutes, seconds, 0);
                console.log('Parsed time result - getHours():', date.getHours(), 'formatted:', date.toLocaleTimeString('en-US', { hour12: true }));
                return date;
            }
            
            // Helper: Parse date string (FROM FIRST CODE)
            function parseDate(dateStr) {
                if (!dateStr) return null;
                
                console.log('Parsing date:', dateStr);
                
                // Try multiple patterns
                // Pattern 1: "Mon 22 Dec" (with day name)
                const dateMatch1 = dateStr.match(/(\w{3})\s+(\d{1,2})\s+(\w{3})/i);
                
                // Pattern 2: Just "22 Dec" (without day name)
                const dateMatch2 = dateStr.match(/(\d{1,2})\s+(\w{3})/i);
                
                let dateNum, month;
                
                if (dateMatch1) {
                    dateNum = parseInt(dateMatch1[2]);
                    month = dateMatch1[3];
                    console.log('Pattern 1 matched:', dateMatch1[0]);
                } else if (dateMatch2) {
                    dateNum = parseInt(dateMatch2[1]);
                    month = dateMatch2[2];
                    console.log('Pattern 2 matched:', dateMatch2[0]);
                } else {
                    console.log('No date match for:', dateStr);
                    return null;
                }
                
                const now = new Date();
                const year = now.getFullYear();
                
                const monthNames = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 
                                   'jul', 'aug', 'sep', 'oct', 'nov', 'dec'];
                const monthIndex = monthNames.indexOf(month.toLowerCase());
                
                if (monthIndex === -1) {
                    console.log('Invalid month:', month);
                    return null;
                }
                
                const dateObj = new Date(year, monthIndex, dateNum, 0, 0, 0);
                console.log('Parsed date:', dateStr, '->', dateObj.toLocaleDateString());
                return dateObj;
            }
            
            // Helper: Format time as HH:MM:SS AM/PM - FIXED VERSION (FROM FIRST CODE)
            function formatTime(date) {
                if (!date) return '';
                
                // Get local time components
                let hours = date.getHours();
                const minutes = date.getMinutes();
                const seconds = date.getSeconds();
                
                // Determine AM/PM
                const ampm = hours >= 12 ? 'PM' : 'AM';
                
                // Convert to 12-hour format
                hours = hours % 12;
                hours = hours ? hours : 12; // 0 becomes 12
                
                // Format with leading zeros
                const hoursStr = hours.toString().padStart(2, '0');
                const minutesStr = minutes.toString().padStart(2, '0');
                const secondsStr = seconds.toString().padStart(2, '0');
                
                return `${hoursStr}:${minutesStr}:${secondsStr} ${ampm}`;
            }
            
            // Helper: Format date as MM/DD/YYYY (FROM FIRST CODE)
            function formatDate(date) {
                if (!date) return '';
                return (date.getMonth() + 1) + '/' + date.getDate() + '/' + date.getFullYear();
            }
            
            // Helper: Format datetime (FROM FIRST CODE)
            function formatDateTime(date) {
                if (!date) return '';
                return formatDate(date) + ' ' + formatTime(date);
            }
            
            // Helper: Convert datetime difference to seconds (FROM FIRST CODE)
            function datetimeToSeconds(date1, date2) {
                if (!date1 || !date2) return 0;
                return (date2 - date1) / 1000;
            }
            
            // B: Order ID (FROM FIRST CODE)
            const backendMatch = text.match(/(\d+)\s*Backend\s*Link/i);
            result.columns.B = backendMatch ? backendMatch[1].trim() : '';
            result.formulas.push('Order ID = ' + result.columns.B);
            console.log('B: Order ID =', result.columns.B);
            
            // C: Country - UPDATED to handle multiple patterns (FROM FIRST CODE)
            let countryMatch = text.match(/TB_([A-Z]{2})/i);
            if (!countryMatch) {
                // Try HF_ pattern if TB_ not found
                countryMatch = text.match(/HF_([A-Z]{2})/i);
            }
            if (!countryMatch) {
                // Try ODR_ pattern as fallback
                countryMatch = text.match(/ODR_([A-Z]{2})/i);
            }
            result.columns.C = countryMatch ? countryMatch[1].trim() : '';
            result.formulas.push('C: Country = ' + result.columns.C);
            console.log('C: Country =', result.columns.C);
            
            // D: Order Date (FROM FIRST CODE)
            const dateMatch = text.match(/Ordered at\s*[:]?\s*(\w{3}\s+\d{1,2}\s+\w{3}|\d{1,2}\s+\w{3})/i);
            let orderDate = null;
            if (dateMatch) {
                console.log('Date match found:', dateMatch[1]);
                orderDate = parseDate(dateMatch[1]);
                result.columns.D = orderDate ? formatDate(orderDate) : '';
            } else {
                console.log('No date match found');
            }
            result.formulas.push('D: Order Date = ' + result.columns.D);
            console.log('D: Order Date =', result.columns.D);
            
            // E: Ordered at - MODIFIED TO GET THE LAST VALUE (FROM FIRST CODE)
            console.log('=== Searching for E: Ordered at (Getting last value) ===');
            
            // Find ALL matches for "Ordered at" patterns and get the last one
            const orderedAtPatterns = [
                // Pattern 1: "Ordered at" with time on same line or next line
                /Ordered\s+at\s*[:]?\s*(\d{1,2}:\d{2}\s*[ap]m)/gi,
                // Pattern 2: "Ordered at" on one line, time on next line
                /Ordered\s+at\s*\n\s*(\d{1,2}:\d{2}\s*[ap]m)/gi,
                // Pattern 3: "Ordered at:" followed by date, then time on next line
                /Ordered\s+at[^\n]*\n[^\n]*(\d{1,2}:\d{2}\s*[ap]m)/gi
            ];
            
            let lastOrderedTime = null;
            let allMatches = [];
            
            // Collect all matches from all patterns
            orderedAtPatterns.forEach(pattern => {
                const matches = [...text.matchAll(pattern)];
                matches.forEach(match => {
                    if (match[1]) {
                        allMatches.push({
                            time: match[1],
                            index: match.index,
                            pattern: pattern.toString()
                        });
                    }
                });
            });
            
            console.log('Found ordered at matches:', allMatches.length);
            allMatches.forEach((match, i) => {
                console.log(`Match ${i}: ${match.time} at index ${match.index}`);
            });
            
            // Get the last match (with highest index)
            if (allMatches.length > 0) {
                // Sort by index descending to get the last occurrence
                allMatches.sort((a, b) => b.index - a.index);
                const lastMatch = allMatches[0];
                console.log('Using last ordered at match:', lastMatch.time);
                lastOrderedTime = parseTime(lastMatch.time);
            }
            
            // If still not found, try line-by-line search as fallback
            if (!lastOrderedTime) {
                console.log('Pattern search failed, trying line-by-line search...');
                const lines = text.split('\n');
                for (let i = 0; i < lines.length; i++) {
                    if (lines[i].includes('Ordered at')) {
                        console.log('Found "Ordered at" on line', i, ':', lines[i]);
                        // Check current line for time
                        let timeMatch = lines[i].match(/(\d{1,2}:\d{2}\s*[ap]m)/i);
                        if (timeMatch) {
                            console.log('Found time on same line:', timeMatch[1]);
                            lastOrderedTime = parseTime(timeMatch[1]);
                            // Don't break, continue to find the last one
                        }
                        // Check next line
                        if (i + 1 < lines.length) {
                            timeMatch = lines[i + 1].match(/(\d{1,2}:\d{2}\s*[ap]m)/i);
                            if (timeMatch) {
                                console.log('Found time on next line:', timeMatch[1]);
                                lastOrderedTime = parseTime(timeMatch[1]);
                                // Don't break, continue to find the last one
                            }
                        }
                    }
                }
            }
            
            if (lastOrderedTime) {
                console.log('Ordered at time (LAST) successfully parsed:', formatTime(lastOrderedTime));
                result.columns.E = formatTime(lastOrderedTime);
                result.formulas.push('E: Ordered at (LAST value) = ' + result.columns.E);
            } else {
                console.log('No ordered time found after all attempts');
                result.columns.E = 'N/A';
                result.formulas.push('E: Ordered at = N/A (not found)');
            }
            console.log('E: Ordered at (FINAL) =', result.columns.E);
            
            // If no order date yet, use today
            if (!orderDate) {
                orderDate = new Date();
                orderDate.setHours(0, 0, 0, 0);
                result.columns.D = formatDate(orderDate);
            }
            
            // Store base values for calculations
            const baseDate = orderDate;
            const baseTime = lastOrderedTime;
            
            console.log('Base date:', baseDate.toLocaleDateString());
            console.log('Base time:', baseTime ? baseTime.toLocaleTimeString() : 'null');
            
            // Helper: Combine date and time, adjust for midnight crossing (FROM FIRST CODE)
            function combineDateTime(datePart, timeValue, referenceTime) {
                if (!datePart || !timeValue) return null;
                
                const dateTime = new Date(datePart);
                dateTime.setHours(timeValue.getHours(), timeValue.getMinutes(), timeValue.getSeconds());
                
                if (referenceTime && timeValue < referenceTime) {
                    dateTime.setDate(dateTime.getDate() + 1);
                    console.log('Adjusted date +1 day for crossing midnight');
                }
                
                return dateTime;
            }
            
            // F: Queued At - USING DUAL PATTERN SEARCH (FROM FIRST CODE)
            const queuedTimeStr = findTimelineEvent(text, 'Queued');
            if (queuedTimeStr) {
                console.log('Queued time found:', queuedTimeStr);
                const queuedTime = parseTime(queuedTimeStr);
                if (queuedTime) {
                    result.timestamps.F = combineDateTime(baseDate, queuedTime, baseTime);
                    result.columns.F = result.timestamps.F ? formatDateTime(result.timestamps.F) : '';
                }
            } else {
                // Fallback to old pattern if new search fails
                const queuedMatch = text.match(/(\d{1,2}:\d{2}\s?[apm]+)\s*Queued/i);
                if (queuedMatch) {
                    console.log('Queued fallback match found:', queuedMatch[1]);
                    const queuedTime = parseTime(queuedMatch[1]);
                    if (queuedTime) {
                        result.timestamps.F = combineDateTime(baseDate, queuedTime, baseTime);
                        result.columns.F = result.timestamps.F ? formatDateTime(result.timestamps.F) : '';
                    }
                }
            }
            result.formulas.push('F: Queued At = ' + result.columns.F);
            
            // G: Courier Notified - USING DUAL PATTERN SEARCH (FROM FIRST CODE)
            const courierTimeStr = findTimelineEvent(text, 'Courier Notified');
            if (courierTimeStr) {
                console.log('Courier Notified time found:', courierTimeStr);
                const courierTime = parseTime(courierTimeStr);
                if (courierTime) {
                    result.timestamps.G = combineDateTime(baseDate, courierTime, baseTime);
                    result.columns.G = result.timestamps.G ? formatTime(result.timestamps.G) : '';
                }
            } else {
                // Fallback to old pattern if new search fails
                const courierMatch = text.match(/(\d{1,2}:\d{2}\s?[apm]+)\s+Courier\s+Notified/i);
                if (courierMatch) {
                    console.log('Courier fallback match found:', courierMatch[1]);
                    const courierTime = parseTime(courierMatch[1]);
                    if (courierTime) {
                        result.timestamps.G = combineDateTime(baseDate, courierTime, baseTime);
                        result.columns.G = result.timestamps.G ? formatTime(result.timestamps.G) : '';
                    }
                }
            }
            result.formulas.push('G: Courier Notified = ' + result.columns.G);
            
            // H: Accepted At - USING DUAL PATTERN SEARCH (FROM FIRST CODE)
            const acceptedTimeStr = findTimelineEvent(text, 'Accepted');
            if (acceptedTimeStr) {
                console.log('Accepted time found:', acceptedTimeStr);
                const acceptedTime = parseTime(acceptedTimeStr);
                if (acceptedTime) {
                    result.timestamps.H = combineDateTime(baseDate, acceptedTime, baseTime);
                    result.columns.H = result.timestamps.H ? formatTime(result.timestamps.H) : '';
                }
            } else {
                // Fallback to old pattern if new search fails
                const acceptedMatches = [...text.matchAll(/(\d{1,2}:\d{2}\s*[ap]m)\s+Accepted\s+Delivery\s+Accepted/gi)];
                if (acceptedMatches.length > 0) {
                    const lastAccepted = acceptedMatches[acceptedMatches.length - 1][0];
                    const timeMatch = lastAccepted.match(/(\d{1,2}:\d{2}\s*[ap]m)/i);
                    if (timeMatch) {
                        console.log('Accepted fallback match found:', timeMatch[1]);
                        const acceptedTime = parseTime(timeMatch[1]);
                        if (acceptedTime) {
                            result.timestamps.H = combineDateTime(baseDate, acceptedTime, baseTime);
                            result.columns.H = result.timestamps.H ? formatTime(result.timestamps.H) : '';
                        }
                    }
                }
            }
            result.formulas.push('H: Accepted At = ' + result.columns.H);
            
            // I: Near Pickup - USING DUAL PATTERN SEARCH (FROM FIRST CODE)
            const nearPickupTimeStr = findTimelineEvent(text, 'Near Pickup');
            if (nearPickupTimeStr) {
                console.log('Near Pickup time found:', nearPickupTimeStr);
                const nearPickupTime = parseTime(nearPickupTimeStr);
                if (nearPickupTime) {
                    result.timestamps.I = combineDateTime(baseDate, nearPickupTime, baseTime);
                    result.columns.I = result.timestamps.I ? formatTime(result.timestamps.I) : '';
                }
            } else {
                // Fallback to old pattern if new search fails
                const nearPickupMatches = [...text.matchAll(/(\d{1,2}:\d{2}\s*[ap]m)\s+Near\s+Pickup\s+Delivery\s+Near\s+Pickup/gi)];
                if (nearPickupMatches.length > 0) {
                    const lastNearPickup = nearPickupMatches[nearPickupMatches.length - 1][0];
                    const timeMatch = lastNearPickup.match(/(\d{1,2}:\d{2}\s*[ap]m)/i);
                        if (timeMatch) {
                        console.log('Near Pickup fallback match found:', timeMatch[1]);
                        const nearPickupTime = parseTime(timeMatch[1]);
                        if (nearPickupTime) {
                            result.timestamps.I = combineDateTime(baseDate, nearPickupTime, baseTime);
                            result.columns.I = result.timestamps.I ? formatTime(result.timestamps.I) : '';
                        }
                    }
                }
            }
            result.formulas.push('I: Near Pickup = ' + result.columns.I);
            
            // J: Est. Pickup (CPT) (FROM FIRST CODE)
            const acceptedDashMatches = [...text.matchAll(/Accepted\s*[-]\s*(\d{1,2}:\d{2}\s*[apm]{2})/gi)];
            if (acceptedDashMatches.length > 0) {
                const lastAcceptedDash = acceptedDashMatches[acceptedDashMatches.length - 1][1];
                console.log('Accepted - time match found:', lastAcceptedDash);
                const estPickupTime = parseTime(lastAcceptedDash);
                if (estPickupTime) {
                    result.timestamps.J = combineDateTime(baseDate, estPickupTime, baseTime);
                    result.columns.J = result.timestamps.J ? formatTime(result.timestamps.J) : '';
                }
            }
            
            // Alternative for J: Look in timeline
            if (!result.columns.J) {
                const timelineSection = text.match(/Time\s+Event[\s\S]*?(?:\n\n|ID\s+\d|More Details|$)/i);
                if (timelineSection) {
                    const timelineText = timelineSection[0];
                    const estPickupMatch = timelineText.match(/(\d{1,2}:\d{2}\s*[AP]M)[^\n]*Est\.pickup arrival/i);
                    if (estPickupMatch) {
                        console.log('Est. Pickup in timeline:', estPickupMatch[1]);
                        const estPickupTime = parseTime(estPickupMatch[1]);
                        if (estPickupTime) {
                            result.timestamps.J = combineDateTime(baseDate, estPickupTime, baseTime);
                            result.columns.J = result.timestamps.J ? formatTime(result.timestamps.J) : '';
                        }
                    }
                }
            }
            result.formulas.push('J: Est. Pickup (CPT) = ' + result.columns.J);
            console.log('J: Est. Pickup (CPT) =', result.columns.J);
            
            // K: Picked Up At - USING DUAL PATTERN SEARCH (FROM FIRST CODE)
            const pickedUpTimeStr = findTimelineEvent(text, 'Picked Up');
            if (pickedUpTimeStr) {
                console.log('Picked Up time found:', pickedUpTimeStr);
                const pickedUpTime = parseTime(pickedUpTimeStr);
                if (pickedUpTime) {
                    result.timestamps.K = combineDateTime(baseDate, pickedUpTime, baseTime);
                    result.columns.K = result.timestamps.K ? formatTime(result.timestamps.K) : '';
                }
            } else {
                // Fallback to old pattern if new search fails
                const pickedUpMatches = [...text.matchAll(/(\d{1,2}:\d{2}\s*[ap]m)\s+Picked\s+Up\s+Delivery\s+Picked\s+Up/gi)];
                if (pickedUpMatches.length > 0) {
                    const lastPickedUp = pickedUpMatches[pickedUpMatches.length - 1][0];
                    const timeMatch = lastPickedUp.match(/(\d{1,2}:\d{2}\s*[ap]m)/i);
                    if (timeMatch) {
                        console.log('Picked Up fallback match found:', timeMatch[1]);
                        const pickedUpTime = parseTime(timeMatch[1]);
                        if (pickedUpTime) {
                            result.timestamps.K = combineDateTime(baseDate, pickedUpTime, baseTime);
                            result.columns.K = result.timestamps.K ? formatTime(result.timestamps.K) : '';
                        }
                    }
                }
            }
            result.formulas.push('K: Picked Up At = ' + result.columns.K);
            
            // L: Est. Dropoff (FROM FIRST CODE)
            console.log('=== Searching for L: Est. Dropoff ===');
            
            // Method 1: Use your exact Google Sheets formula pattern
            // Pattern: "Picked Up" followed by non-digits, then capture a time
            const estDropoffRegex = /Picked\s+Up\s+[^0-9\n]*(\d{1,2}:\d{2}\s*[APM]{2})/i;
            const estDropoffMatch = text.match(estDropoffRegex);
            
            if (estDropoffMatch) {
                console.log('Method 1 - Google Sheets pattern matched:', estDropoffMatch[1]);
                const estDropoffTime = parseTime(estDropoffMatch[1]);
                if (estDropoffTime) {
                    // Apply the same logic as your Google Sheets formula
                    // IF(time < E2, time + D2 + 1, time + D2)
                    if (estDropoffTime < baseTime) {
                        // If extracted time is before ordered time, add 1 day
                        const nextDay = new Date(baseDate);
                        nextDay.setDate(nextDay.getDate() + 1);
                        result.timestamps.L = combineDateTime(nextDay, estDropoffTime, baseTime);
                    } else {
                        result.timestamps.L = combineDateTime(baseDate, estDropoffTime, baseTime);
                    }
                    result.columns.L = result.timestamps.L ? formatTime(result.timestamps.L) : '';
                    console.log('L: Est. Dropoff calculated with Method 1:', result.columns.L);
                }
            }
            
            // Method 2: Look for specific timeline pattern from your data
            if (!result.columns.L) {
                console.log('Method 1 failed, trying Method 2...');
                // Pattern: time, Picked Up, dashes, then time (10:34 PM Picked Up - - - 10:51 PM)
                const timelinePattern = /(\d{1,2}:\d{2}\s*[AP]M)[^0-9]*Picked\s+Up[^0-9\-]*(-[^0-9\-]*){3}[^0-9]*(\d{1,2}:\d{2}\s*[AP]M)/i;
                const timelineMatch = text.match(timelinePattern);
                
                if (timelineMatch) {
                    console.log('Method 2 - Timeline pattern matched. First time:', timelineMatch[1], 'Second time:', timelineMatch[3]);
                    // The second time is likely Est.dropoff
                    const estDropoffTime = parseTime(timelineMatch[3]);
                    if (estDropoffTime) {
                        result.timestamps.L = combineDateTime(baseDate, estDropoffTime, baseTime);
                        result.columns.L = result.timestamps.L ? formatTime(result.timestamps.L) : '';
                        console.log('L: Est. Dropoff calculated with Method 2:', result.columns.L);
                    }
                }
            }
            
            // Method 3: Look for Picked Up row with multiple times
            if (!result.columns.L) {
                console.log('Method 2 failed, trying Method 3...');
                // Find all occurrences of time near "Picked Up"
                const lines = text.split('\n');
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (line.includes('Picked Up')) {
                        console.log('Found Picked Up line:', line);
                        // Extract all times from this line
                        const times = [...line.matchAll(/(\d{1,2}:\d{2}\s*[AP]M)/gi)];
                        console.log('Times in line:', times.map(t => t[0]));
                        
                        // Usually the last time or second time is Est.dropoff
                        if (times.length >= 2) {
                            // Try the last time first
                            const lastTime = times[times.length - 1][0];
                            console.log('Trying last time:', lastTime);
                            const estDropoffTime = parseTime(lastTime);
                            if (estDropoffTime) {
                                result.timestamps.L = combineDateTime(baseDate, estDropoffTime, baseTime);
                                result.columns.L = result.timestamps.L ? formatTime(result.timestamps.L) : '';
                                console.log('L: Est. Dropoff calculated with Method 3 (last time):', result.columns.L);
                                break;
                            }
                        }
                    }
                }
            }
            
            // Method 4: Look for Est.dropoff arrival specifically
            if (!result.columns.L) {
                console.log('Method 3 failed, trying Method 4...');
                const estDropoffArrivalMatch = text.match(/Est\.dropoff\s+arrival[^0-9\n]*(\d{1,2}:\d{2}\s*[AP]M)/i);
                if (estDropoffArrivalMatch) {
                    console.log('Method 4 - Est.dropoff arrival matched:', estDropoffArrivalMatch[1]);
                    const estDropoffTime = parseTime(estDropoffArrivalMatch[1]);
                    if (estDropoffTime) {
                        result.timestamps.L = combineDateTime(baseDate, estDropoffTime, baseTime);
                        result.columns.L = result.timestamps.L ? formatTime(result.timestamps.L) : '';
                        console.log('L: Est. Dropoff calculated with Method 4:', result.columns.L);
                    }
                }
            }
            
            // Method 5: Search in the timeline table section
            if (!result.columns.L) {
                console.log('Method 4 failed, trying Method 5...');
                // Find timeline section
                const timelineStart = text.search(/Time\s+Event/i);
                if (timelineStart !== -1) {
                    const timelineEnd = text.indexOf('\n\n', timelineStart);
                    const timelineText = text.substring(timelineStart, timelineEnd !== -1 ? timelineEnd : text.length);
                    
                    // Look for pattern with multiple times in Picked Up row
                    const pickedUpRowMatch = timelineText.match(/Picked\s+Up[^\n]*(\d{1,2}:\d{2}\s*[AP]M)[^\n]*$/im);
                    if (pickedUpRowMatch) {
                        console.log('Method 5 - Picked Up row in timeline matched time:', pickedUpRowMatch[1]);
                        const estDropoffTime = parseTime(pickedUpRowMatch[1]);
                        if (estDropoffTime) {
                            result.timestamps.L = combineDateTime(baseDate, estDropoffTime, baseTime);
                            result.columns.L = result.timestamps.L ? formatTime(result.timestamps.L) : '';
                            console.log('L: Est. Dropoff calculated with Method 5:', result.columns.L);
                        }
                    }
                }
            }
            
            // Last resort: Use PDT as fallback (often same as Est. Dropoff)
            if (!result.columns.L && result.columns.N) {
                console.log('All methods failed, using PDT as fallback for L: Est. Dropoff');
                result.timestamps.L = result.timestamps.N;
                result.columns.L = result.columns.N;
            }
            
            result.formulas.push('L: Est. Dropoff = ' + result.columns.L);
            console.log('=== L: Est. Dropoff final result =', result.columns.L, '===');
            
            // M: Near Dropoff - USING DUAL PATTERN SEARCH (FROM FIRST CODE)
            const nearDropoffTimeStr = findTimelineEvent(text, 'Near Dropoff');
            if (nearDropoffTimeStr) {
                console.log('Near Dropoff time found:', nearDropoffTimeStr);
                const nearDropoffTime = parseTime(nearDropoffTimeStr);
                if (nearDropoffTime) {
                    result.timestamps.M = combineDateTime(baseDate, nearDropoffTime, baseTime);
                    result.columns.M = result.timestamps.M ? formatTime(result.timestamps.M) : '';
                }
            } else {
                // Fallback to old pattern if new search fails
                const nearDropoffMatches = [...text.matchAll(/(\d{1,2}:\d{2}\s*[ap]m)\s+Near\s+Dropoff\s+Delivery\s+Near\s+Dropoff/gi)];
                if (nearDropoffMatches.length > 0) {
                    const lastNearDropoff = nearDropoffMatches[nearDropoffMatches.length - 1][0];
                    const timeMatch = lastNearDropoff.match(/(\d{1,2}:\d{2}\s*[ap]m)/i);
                    if (timeMatch) {
                        console.log('Near Dropoff fallback match found:', timeMatch[1]);
                        const nearDropoffTime = parseTime(timeMatch[1]);
                        if (nearDropoffTime) {
                            result.timestamps.M = combineDateTime(baseDate, nearDropoffTime, baseTime);
                            result.columns.M = result.timestamps.M ? formatTime(result.timestamps.M) : '';
                        }
                    }
                }
            }
            result.formulas.push('M: Near Dropoff = ' + result.columns.M);
            
            // N: PDT - MODIFIED TO GET LAST PDT IN THE PATTERN (FROM FIRST CODE)
            console.log('=== Searching for N: PDT ===');

            // Method 1: Find ALL PDT matches and take the last one
            const pdtMatches = [...text.matchAll(/PDT[\s\S]*?(\d{1,2}:\d{2}\s*[ap]m)/gi)];

            let pdtTime = null;
            if (pdtMatches.length > 0) {
                // Get the LAST match (most recent PDT)
                const lastPdtMatch = pdtMatches[pdtMatches.length - 1];
                console.log(`Found ${pdtMatches.length} PDT matches. Using last one:`, lastPdtMatch[1]);
                console.log('Full last match (first 100 chars):', lastPdtMatch[0].substring(0, 100));
                pdtTime = parseTime(lastPdtMatch[1]);
            }

            // Method 2: If no PDT found, search for "Promised delivery time" and get the last one
            if (!pdtTime) {
                console.log('No PDT found, searching for "Promised delivery time"...');
                
                // Find ALL Promised delivery time matches
                const promisedMatches = [...text.matchAll(/Promised\s+delivery\s+time[\s\S]*?(\d{1,2}:\d{2}\s*[ap]m)/gi)];
                
                if (promisedMatches.length > 0) {
                    // Get the LAST match
                    const lastPromisedMatch = promisedMatches[promisedMatches.length - 1];
                    console.log(`Found ${promisedMatches.length} Promised delivery time matches. Using last one:`, lastPromisedMatch[1]);
                    pdtTime = parseTime(lastPromisedMatch[1]);
                }
            }

            // Method 3: If still not found, try line-by-line search (as before)
            if (!pdtTime) {
                console.log('Regex search failed, trying method 3 (line search)...');
                const lines = text.split('\n');
                let foundPdtTimes = [];
                
                for (let i = 0; i < lines.length; i++) {
                    if (lines[i].includes('PDT') || lines[i].includes('Promised delivery time')) {
                        console.log('Found PDT/Promised on line', i, ':', lines[i]);
                        
                        // Check current line for time
                        let timeMatch = lines[i].match(/(\d{1,2}:\d{2}\s*[ap]m)/i);
                        if (timeMatch) {
                            console.log('Found time on same line:', timeMatch[1]);
                            foundPdtTimes.push(timeMatch[1]);
                        }
                        // Check next line
                        if (i + 1 < lines.length) {
                            timeMatch = lines[i + 1].match(/(\d{1,2}:\d{2}\s*[ap]m)/i);
                            if (timeMatch) {
                                console.log('Found time on next line:', timeMatch[1]);
                                foundPdtTimes.push(timeMatch[1]);
                            }
                        }
                        // Check line after next
                        if (i + 2 < lines.length) {
                            timeMatch = lines[i + 2].match(/(\d{1,2}:\d{2}\s*[ap]m)/i);
                            if (timeMatch) {
                                console.log('Found time on line after next:', timeMatch[1]);
                                foundPdtTimes.push(timeMatch[1]);
                            }
                        }
                    }
                }
                
                // Use the last found PDT time
                if (foundPdtTimes.length > 0) {
                    console.log(`Found ${foundPdtTimes.length} PDT times via line search. Using last one:`, foundPdtTimes[foundPdtTimes.length - 1]);
                    pdtTime = parseTime(foundPdtTimes[foundPdtTimes.length - 1]);
                }
            }

            if (pdtTime) {
                console.log('PDT/Promised time successfully parsed:', formatTime(pdtTime));
                result.timestamps.N = combineDateTime(baseDate, pdtTime, baseTime);
                result.columns.N = result.timestamps.N ? formatTime(result.timestamps.N) : '';
                
                // Check if we should apply Local Shop AE logic
                const country = result.columns.C;
                const applyLocalShopAE = isLocalShopAE && country === 'AE';
                const minutesToAdd = applyLocalShopAE ? 30 : 10;
                
                // Add note about the Local Shop AE adjustment
                if (applyLocalShopAE) {
                    result.formulas.push(`N: PDT/Promised time = ${result.columns.N} (Local Shop AE: Using 30 minutes for calculations - Last PDT in pattern)`);
                } else if (isLocalShopAE && country !== 'AE') {
                    result.formulas.push(`N: PDT/Promised time = ${result.columns.N} (Checkbox checked but Country is ${country}, not AE: Using 10 minutes - Last PDT in pattern)`);
                } else {
                    result.formulas.push(`N: PDT/Promised time = ${result.columns.N} (Using 10 minutes for calculations - Last PDT in pattern)`);
                }
                
                console.log('N: PDT/Promised time final result:', result.columns.N, `(+${minutesToAdd}min)`);
            } else {
                console.log('No PDT or Promised delivery time found after all attempts');
                result.columns.N = 'N/A';
                result.formulas.push('N: PDT/Promised delivery time = N/A');
            }
            
            // O: food_is_ready_at (FROM FIRST CODE)
            const foodReadyMatch = text.match(/Food\s+is\s+ready\s+at\s*[:]?\s*(\d{1,2}:\d{2}\s*[apm]+)/i);
            if (foodReadyMatch) {
                console.log('Food ready match found:', foodReadyMatch[1]);
                const foodReadyTime = parseTime(foodReadyMatch[1]);
                if (foodReadyTime) {
                    result.timestamps.O = combineDateTime(baseDate, foodReadyTime, baseTime);
                    result.columns.O = result.timestamps.O ? formatTime(result.timestamps.O) : '';
                }
            } else {
                // Try alternative pattern without "at"
                const foodReadyAltMatch = text.match(/Food\s+ready\s*[:]?\s*(\d{1,2}:\d{2}\s*[apm]+)/i);
                if (foodReadyAltMatch) {
                    console.log('Food ready alternative match found:', foodReadyAltMatch[1]);
                    const foodReadyTime = parseTime(foodReadyAltMatch[1]);
                    if (foodReadyTime) {
                        result.timestamps.O = combineDateTime(baseDate, foodReadyTime, baseTime);
                        result.columns.O = result.timestamps.O ? formatTime(result.timestamps.O) : '';
                    }
                }
            }
            result.formulas.push('O: food_is_ready_at = ' + result.columns.O);
            console.log('O: food_is_ready_at =', result.columns.O);
            
            // P: cancellation_time - UTC-BASED WITH COUNTRY OFFSETS (FROM FIRST CODE)
            const nowUTC = new Date(); // This is browser local, but we'll convert
            
            const countryUTCOffsets = {
                'AE': 4,  // UTC+4
                'EG': 2,  // UTC+2
                'KW': 3,  // UTC+3
                'QA': 3,  // UTC+3
                'IQ': 3,  // UTC+3
                'SA': 3,  // UTC+3
                'JO': 2,  // UTC+2 (Note: Jordan is UTC+2, but UTC+3 in summer)
                'BH': 3,  // UTC+3
                'OM': 4   // UTC+4
            };
            
            const countryCode = result.columns.C;
            const targetOffset = countryUTCOffsets[countryCode] || 4; // Default to UAE (UTC+4)
            
            // Convert browser local time to UTC
            const utcTime = nowUTC.getTime() + (nowUTC.getTimezoneOffset() * 60000);
            // Apply country offset to get country local time
            const countryTime = new Date(utcTime + (3600000 * targetOffset));
            
            result.columns.P = formatTime(countryTime);
            result.timestamps.P = countryTime; // Store as timestamp for use in W and T calculations
            result.formulas.push(`P: cancellation_time = UTC + ${targetOffset} hours (Country: ${countryCode}) = ${result.columns.P}`);
            console.log(`P: cancellation_time = ${result.columns.P} (UTC+${targetOffset} for country ${countryCode})`);
            
            // Q: old_cpt (FROM FIRST CODE)
            const oldCptMatch = text.match(/Pickup\s*[-]\s*Committed\s*[:]?\s*(\d{1,2}:\d{2}[apm]+)/i);
            if (oldCptMatch) {
                console.log('Old CPT match found:', oldCptMatch[1]);
                const oldCptTime = parseTime(oldCptMatch[1]);
                if (oldCptTime) {
                    result.timestamps.Q = combineDateTime(baseDate, oldCptTime, baseTime);
                    result.columns.Q = formatTime(result.timestamps.Q);
                }
            }
            result.formulas.push('Q: old_cpt = ' + result.columns.Q);
            console.log('Q: old_cpt =', result.columns.Q);
            
            // R: cpt =IF(J2>Q2,J2,Q2) (FROM FIRST CODE)
            if (result.timestamps.J && result.timestamps.Q) {
                result.timestamps.R = result.timestamps.J > result.timestamps.Q ? result.timestamps.J : result.timestamps.Q;
                result.columns.R = formatTime(result.timestamps.R);
            } else if (result.timestamps.J) {
                result.timestamps.R = result.timestamps.J;
                result.columns.R = formatTime(result.timestamps.J);
            } else if (result.timestamps.Q) {
                result.timestamps.R = result.timestamps.Q;
                result.columns.R = formatTime(result.timestamps.Q);
            }
            result.formulas.push('R: cpt = MAX(J, Q) = ' + result.columns.R);
            
            // S: is_wfa (FROM FIRST CODE)
            result.columns.S = text.includes("Scheduled") ? "TRUE" : "FALSE";
            result.formulas.push('S: is_wfa (Scheduled) = ' + result.columns.S);
            
            // T: Before PDT Check - MODIFIED VERSION (uses cancellation time as fallback) (FROM FIRST CODE)
            console.log('=== Calculating T: Before PDT Check (Modified) ===');
            result.columns.T = "";
            
            // Get dropoff time for T check (M if available, otherwise P as fallback)
            const dropoffTimeForT = result.timestamps.M || result.timestamps.P;
            
            if (dropoffTimeForT && result.timestamps.N) {
                // MODIFIED: Use 30 minutes if Local Shop AE checkbox is checked AND country is AE, otherwise 10 minutes
                const country = result.columns.C;
                const applyLocalShopAE = isLocalShopAE && country === 'AE';
                const minutesToAdd = applyLocalShopAE ? 30 : 10;
                const pdtPlusMinutes = new Date(result.timestamps.N.getTime() + (minutesToAdd * 60 * 1000));
                console.log(`T Check: Dropoff time = ${formatTime(dropoffTimeForT)}, PDT = ${formatTime(result.timestamps.N)}, PDT+${minutesToAdd}min = ${formatTime(pdtPlusMinutes)}`);
                
                if (dropoffTimeForT <= pdtPlusMinutes) {
                    result.columns.T = "Before PDT";
                    console.log(`T: Before PDT condition met (PDT + ${minutesToAdd}min)`);
                    
                    // Add note if using cancellation time
                    if (!result.timestamps.M && result.timestamps.P) {
                        result.formulas.push('T Note: Using cancellation_time for Before PDT check (Near Dropoff not available)');
                    }
                    
                    // Add note about buffer
                    if (applyLocalShopAE) {
                        result.formulas.push(`T: Using 30-minute buffer (Local Shop AE + Country AE)`);
                    } else if (isLocalShopAE && country !== 'AE') {
                        result.formulas.push(`T: Checkbox checked but Country is ${country}, not AE - Using 10-minute buffer`);
                    }
                } else {
                    console.log(`T: Dropoff time is after PDT+${minutesToAdd}min`);
                }
            } else {
                console.log(`T: Cannot check - Dropoff time: ${dropoffTimeForT ? 'Available' : 'Missing'}, PDT: ${result.timestamps.N ? 'Available' : 'Missing'}`);
            }
            result.formulas.push('T: Before PDT Check = ' + result.columns.T);
            
            // U: System Late Duration - UPDATED FORMULA: IF(H<>"", (H-F)*86400, IF(P<>"", (P-F)*86400, 0)) (FROM FIRST CODE)
            let U_seconds = 0;
            if (result.timestamps.H && result.timestamps.F) {
                // Use H-F if H exists
                U_seconds = datetimeToSeconds(result.timestamps.F, result.timestamps.H);
            } else if (result.columns.P && result.timestamps.F) {
                // Fallback to P-F if H doesn't exist but P does
                const P_time = parseTime(result.columns.P);
                if (P_time) {
                    U_seconds = datetimeToSeconds(result.timestamps.F, P_time);
                }
            }
            result.columns.U = Math.round(U_seconds) + "s";
            result.formulas.push('U: System Late Duration = IF(H<>"", (H-F)*86400, IF(P<>"", (P-F)*86400, 0)) = ' + result.columns.U);
            
            // V: Vendor Late Duration - UPDATED WITH NEW CONDITION (FROM FIRST CODE)
            let V_seconds = 0;
            let V_calculationType = 'standard'; // 'standard' or 'new'

            if (result.timestamps.K && result.timestamps.R) {
                // Standard condition: K exists
                V_seconds = datetimeToSeconds(result.timestamps.R, result.timestamps.K);
                V_calculationType = 'standard';
                console.log('V: Using standard calculation (K - R)');
            } else if (!result.columns.K && result.timestamps.I && result.timestamps.R && result.timestamps.P) {
                // NEW CONDITION: K is N/A, I exists, calculate (P - R)
                V_seconds = datetimeToSeconds(result.timestamps.R, result.timestamps.P);
                V_calculationType = 'new';
                console.log(`V: Using NEW vendor delay calculation (P - R) because K is N/A`);
                console.log(`R (CPT): ${formatTime(result.timestamps.R)}, P (cancellation_time): ${formatTime(result.timestamps.P)}`);
                console.log(`V seconds calculated: ${V_seconds}s`);
            } else {
                console.log('V: No vendor delay calculated');
            }
            result.columns.V = Math.round(V_seconds) + "s";

            // Store calculation type for display
            result.V_calculationType = V_calculationType;

            // Create appropriate formula description
            if (V_calculationType === 'new') {
                result.formulas.push(`V: Vendor Late Duration = NEW: (P - R) [because K is N/A and I exists] = ${result.columns.V}`);
            } else if (V_calculationType === 'standard') {
                result.formulas.push(`V: Vendor Late Duration = (K - R) = ${result.columns.V}`);
            } else {
                result.formulas.push(`V: Vendor Late Duration = 0 = ${result.columns.V}`);
            }
            
            // W: Rider Delay After Pickup - MODIFIED VERSION (FROM FIRST CODE)
            console.log('=== Calculating W: Rider Delay After Pickup (Modified) ===');
            let W_seconds = 0;
            
            // Get the dropoff time (use near dropoff first, cancellation time as fallback)
            let dropoffTime = result.timestamps.M; // Near Dropoff
            
            // If near dropoff is not available, use cancellation time
            if (!dropoffTime && result.columns.P && result.columns.P !== 'N/A') {
                console.log('Near dropoff not available, using cancellation time as dropoff time');
                dropoffTime = result.timestamps.P;
                
                // Add note about using cancellation time
                result.formulas.push('W Note: Using cancellation_time as dropoff time (Near Dropoff not available)');
            }
            
            // Calculate delay if we have both dropoff time and estimated dropoff
            if (dropoffTime && result.timestamps.L && dropoffTime > result.timestamps.L) {
                W_seconds = datetimeToSeconds(result.timestamps.L, dropoffTime);
                console.log(`W calculated: Dropoff time (${formatTime(dropoffTime)}) - Est. Dropoff (${formatTime(result.timestamps.L)}) = ${W_seconds}s`);
                
                // Add specific note if using cancellation time
                if (!result.timestamps.M && result.timestamps.P) {
                    result.formulas.push(`W: Using cancellation_time (${result.columns.P}) instead of Near Dropoff (N/A)`);
                }
            } else if (dropoffTime && result.timestamps.L) {
                console.log(`No delay: Dropoff time (${formatTime(dropoffTime)}) <= Est. Dropoff (${formatTime(result.timestamps.L)})`);
            } else {
                console.log(`Cannot calculate W: Dropoff time or Est. Dropoff missing`);
            }
            
            result.columns.W = Math.round(W_seconds) + "s";
            result.formulas.push('W: Rider Delay After Pickup = (Dropoff Time - Est. Dropoff) = ' + result.columns.W);
            console.log('W: Rider Delay After Pickup final result =', result.columns.W);
            
            // X: Rider Delay Before Pickup - UPDATED FORMULA WITH NEW LOGIC (FROM FIRST CODE)
            let X_seconds = 0;
            
            console.log('=== Calculating X: Rider Delay Before Pickup (Updated Logic) ===');
            console.log('I (Near Pickup):', result.columns.I);
            console.log('J (Est. Pickup):', result.columns.J);
            console.log('P (cancellation_time):', result.columns.P);
            console.log('H (Accepted At):', result.columns.H);
            
            // Get last queued time
            const lastQueuedTime = getLastQueuedTime(text);
            console.log('Last Queued time found:', lastQueuedTime ? formatTime(lastQueuedTime) : 'N/A');
            
            // Check if last queued time > H: Accepted At
            const lastQueuedAfterAccepted = lastQueuedTime && result.timestamps.H && 
                                          lastQueuedTime > result.timestamps.H;
            
            console.log('Check: last queued > H (Accepted At)?', lastQueuedAfterAccepted);
            if (lastQueuedAfterAccepted) {
                console.log('X: Last queued time > H (Accepted At), setting X to 0');
                X_seconds = 0;
                result.formulas.push('X: Rider Delay Before Pickup = 0 (because last queued time > H: Accepted At)');
            } else {
                // Original logic: =IF(AND(I<>"" , I>J), (I-J)*86400, IF(I = "",(P-H) *86400,0))
                console.log('X: Applying original logic (last queued time ‚â§ H: Accepted At)');
                
                // Primary condition: IF(AND(I<>"" , I>J), (I-J)*86400
                if (result.timestamps.I && result.timestamps.J && result.timestamps.I > result.timestamps.J) {
                    X_seconds = datetimeToSeconds(result.timestamps.J, result.timestamps.I);
                    console.log('X: Using primary condition (I > J)');
                }
                // Secondary condition: IF(I = "",(P-H) *86400,0)
                else if (!result.columns.I && result.columns.P && result.timestamps.H) {
                    // If I is empty, calculate (P-H)
                    const P_time = parseTime(result.columns.P);
                    if (P_time) {
                        X_seconds = datetimeToSeconds(result.timestamps.H, P_time);
                        if (X_seconds < 0) {
                            X_seconds = 0; // Ensure non-negative
                        }
                    }
                    console.log('X: Using secondary condition (I is empty, calculating P-H)');
                }
                
                if (lastQueuedAfterAccepted === false) {
                    result.formulas.push('X: Rider Delay Before Pickup = Original logic (last queued ‚â§ H) = ' + Math.round(X_seconds) + "s");
                }
            }
            
            result.columns.X = Math.round(X_seconds) + "s";
            console.log('X: Rider Delay Before Pickup final result =', result.columns.X);
            
            // Y: Vendor Late (Near Pickup vs Picked Up) (FROM FIRST CODE)
            let Y_seconds = 0;
            if (result.columns.S === "FALSE" && result.timestamps.I && result.timestamps.J && result.timestamps.K && result.timestamps.R) {
                if (result.timestamps.I > result.timestamps.J && result.timestamps.K > result.timestamps.R) {
                    if (result.timestamps.K && result.timestamps.I) {
                        Y_seconds = datetimeToSeconds(result.timestamps.I, result.timestamps.K);
                    }
                }
            }
            result.columns.Y = Math.round(Y_seconds) + "s";
            result.formulas.push('Y: Vendor Late (Near Pickup vs Picked Up) = ' + result.columns.Y);
            
            // Z: Late Owner - SIMPLE HIGHEST DELAY WINS LOGIC
            let Z_result = "";
            
            console.log("=== CALCULATING Z RESULT (SIMPLE HIGHEST DELAY WINS) ===");
            console.log("T (Before PDT):", result.columns.T);
            console.log("U (System Late):", U_seconds);
            console.log("V (Vendor Late):", V_seconds);
            console.log("W (Rider After Pickup):", W_seconds);
            console.log("X (Rider Before Pickup):", X_seconds);
            console.log("Y (Vendor Near Pickup):", Y_seconds);
            
            // Check if we should apply Local Shop AE logic
            const country = result.columns.C;
            const applyLocalShopAE = isLocalShopAE && country === 'AE';
            
            // Convert to milliseconds based on checkbox AND country
            const minutesToAdd = applyLocalShopAE ? 30 : 10;
            const pdtBufferMs = minutesToAdd * 60 * 1000;
            
            console.log(`Using ${minutesToAdd} minutes buffer for PDT (Local Shop AE: ${isLocalShopAE}, Country: ${country}, Apply: ${applyLocalShopAE})`);
            
            // Check if dropoff > N + minutes (10 or 30 based on checkbox AND country)
            // Use dropoffTime (which could be M or P) instead of just M
            const dropoffAfterPdtPlusBuffer = dropoffTime && result.timestamps.N && 
                                       (dropoffTime.getTime() > (result.timestamps.N.getTime() + pdtBufferMs));
            
            console.log(`Dropoff > N + ${minutesToAdd}min?`, dropoffAfterPdtPlusBuffer);
            
            // Condition 1: Before PDT
            if (result.columns.T === "Before PDT") {
                Z_result = "Before PDT";
                console.log("Condition 1: Before PDT");
            }
            // Condition: If dropoff after PDT+buffer, then highest delay wins
            else if (dropoffAfterPdtPlusBuffer) {
                const delayValues = {
                    'Vendor Late': Math.max(V_seconds, Y_seconds),
                    'Rider Late': X_seconds + W_seconds,
                    'Long Dispatch': U_seconds
                };

                console.log("Delay values for Z result:", delayValues);

                let maxDelay = 0;
                let maxDelayType = '';

                for (const [type, value] of Object.entries(delayValues)) {
                    if (value > maxDelay) {
                        maxDelay = value;
                        maxDelayType = type;
                    }
                }

                if (maxDelay > 0) {
                    Z_result = maxDelayType;
                    console.log(`Highest delay is ${maxDelayType} with ${maxDelay} seconds`);
                } else {
                    Z_result = "On Time";
                    console.log("No delays, order is On Time");
                }
            }
            // Default
            else {
                Z_result = "On Time";
                console.log("Default: No condition met, order is On Time");
            }
            
            result.columns.Z = Z_result;
            
            // Add note about buffer used
            if (applyLocalShopAE) {
                result.formulas.push(`Z: Late Owner = ${Z_result} (using 30-minute buffer - Local Shop AE + Country AE)`);
            } else if (isLocalShopAE && country !== 'AE') {
                result.formulas.push(`Z: Late Owner = ${Z_result} (checkbox checked but Country is ${country}, not AE - using 10-minute buffer)`);
            } else {
                result.formulas.push(`Z: Late Owner = ${Z_result} (using 10-minute buffer)`);
            }
            
            // Store whether Local Shop AE was applied
            result.applyLocalShopAE = applyLocalShopAE;
            result.isLocalShopAEChecked = isLocalShopAE;
            result.country = country;
            
            return result;
        }
        
        function updateResultDisplay(result) {
            const finalResult = document.getElementById('finalResult');
            const basicInfoGrid = document.getElementById('basicInfoGrid');
            
            // Set final result with appropriate styling
            finalResult.textContent = result.columns.Z || 'No Result';
            finalResult.className = 'final-result ';
            
            if (result.columns.Z === "Before PDT") {
                finalResult.classList.add('result-before-pdt');
            } else if (result.columns.Z.includes("Vendor Late")) {
                finalResult.classList.add('result-vendor-late');
            } else if (result.columns.Z.includes("Rider Late")) {
                finalResult.classList.add('result-rider-late');
            } else if (result.columns.Z.includes("Long Dispatch")) {
                finalResult.classList.add('result-long-dispatch');
            } else if (result.columns.Z.includes("Picked up by another rider")) {
                finalResult.classList.add('result-picked-up-another-rider');
            } else if (result.columns.Z !== "Before PDT") {
                // FIXED: Get ALL delay values for comparison (FROM FIRST CODE)
                const U_value = parseFloat(result.columns.U.replace('s', '') || 0);
                const X_value = parseFloat(result.columns.X.replace('s', '') || 0);
                const V_value = parseFloat(result.columns.V.replace('s', '') || 0);
                const W_value = parseFloat(result.columns.W.replace('s', '') || 0);
                const Y_value = parseFloat(result.columns.Y.replace('s', '') || 0);
                
                // Find the maximum value among ALL delay types
                const maxValue = Math.max(U_value, X_value, V_value, W_value, Y_value);
                
                console.log("Delay values for fallback decision:");
                console.log("U (System Late):", U_value);
                console.log("X (Rider Before Pickup):", X_value);
                console.log("V (Vendor Late):", V_value);
                console.log("W (Rider After Pickup):", W_value);
                console.log("Y (Vendor Near Pickup):", Y_value);
                console.log("Maximum value:", maxValue);
                
                // Determine which one is the max with proper priority
                // Priority: W (Rider After Pickup) > U (Long Dispatch) > X (Rider Late) > V (Vendor Late) > Y (Vendor Near Pickup)
                if (W_value === maxValue) {
                    // W (Rider After Pickup) is highest ‚Üí Rider Late
                    finalResult.classList.add('result-rider-late');
                    if (result.columns.Z !== "Rider Late") {
                        finalResult.textContent = "Rider Late";
                        result.columns.Z = "Rider Late";
                        console.log("Fallback: Changed to Rider Late (W is largest)");
                    }
                } else if (U_value === maxValue) {
                    // U is highest ‚Üí Long Dispatch
                    finalResult.classList.add('result-long-dispatch');
                    if (result.columns.Z !== "Long Dispatch") {
                        finalResult.textContent = "Long Dispatch";
                        result.columns.Z = "Long Dispatch";
                        console.log("Fallback: Changed to Long Dispatch (U is largest)");
                    }
                } else if (X_value === maxValue) {
                    // X is highest ‚Üí Rider Late (before pickup)
                    finalResult.classList.add('result-rider-late');
                    if (result.columns.Z !== "Rider Late") {
                        finalResult.textContent = "Rider Late";
                        result.columns.Z = "Rider Late";
                        console.log("Fallback: Changed to Rider Late (X is largest)");
                    }
                } else if (V_value === maxValue) {
                    // V is highest ‚Üí Vendor Late
                    finalResult.classList.add('result-vendor-late');
                    if (result.columns.Z !== "Vendor Late") {
                        finalResult.textContent = "Vendor Late";
                        result.columns.Z = "Vendor Late";
                        console.log("Fallback: Changed to Vendor Late (V is largest)");
                    }
                } else if (Y_value === maxValue) {
                    // Y is highest ‚Üí Vendor Late (near pickup)
                    finalResult.classList.add('result-vendor-late');
                    if (result.columns.Z !== "Vendor Late") {
                        finalResult.textContent = "Vendor Late";
                        result.columns.Z = "Vendor Late";
                        console.log("Fallback: Changed to Vendor Late (Y is largest)");
                    }
                } else {
                    // Fallback if no max found (shouldn't happen)
                    finalResult.classList.add('result-on-time');
                    console.log("Fallback: No clear max value, defaulting to On Time");
                }
            } else {
                finalResult.classList.add('result-on-time');
            }
            
            // Get buffer information
            const isLocalShopAE = document.getElementById('localShopAE').checked;
            const country = result.columns.C;
            const applyLocalShopAE = isLocalShopAE && country === 'AE';
            
            // Create basic information cards - ONLY SHOWING SPECIFIC CARDS
            let cardsHTML = '';
            
            // Only show these specific cards
            const visibleCards = [
                {
                    label: 'Order ID',
                    value: result.columns.B || 'N/A',
                    icon: 'üî¢'
                },
                {
                    label: 'Country',
                    value: result.columns.C || 'N/A',
                    icon: 'üåç'
                },
                {
                    label: 'Order Date',
                    value: result.columns.D || 'N/A',
                    icon: 'üìÖ'
                }
            ];
            
            visibleCards.forEach(card => {
                cardsHTML += `
                    <div class="info-card">
                        <div class="info-label">
                            <span>${card.icon}</span>
                            ${card.label}
                        </div>
                        <div class="info-value">
                            ${card.value}
                        </div>
                    </div>
                `;
            });
            
            basicInfoGrid.innerHTML = cardsHTML;
        }
        
        // Initialize
        window.addEventListener('load', function() {
            document.getElementById('orderDetails').value = '';
            
            // Add event listener for split deliveries checkbox
            document.getElementById('splitDeliveries').addEventListener('change', handleSplitDeliveriesChange);
            
            // Add event listener for delivery count input
            document.getElementById('deliveryCountInput').addEventListener('input', function(e) {
                const value = parseInt(e.target.value);
                if (!isNaN(value) && value >= 2 && value <= 10) {
                    selectDeliveryCount(value);
                }
            });
        });
    </script>
</body>
</html>
