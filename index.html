<!DOCTYPE html>
<html lang="en">
<head> 
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Order Analysis Tool - Complete with Picked Up by Another Rider</title>
    <style>
        /* Enhanced CSS */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #411517; /* Changed to requested color */
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
            border: 1px solid #e0e0e0;
        }
        
        .header {
            background: linear-gradient(135deg, #ff5900 0%, #e64a00 100%); /* Changed to orange gradient */
            color: white;
            padding: 30px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }
        
        .header::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 1px, transparent 1px);
            background-size: 20px 20px;
            opacity: 0.3;
        }
        
        .header-content {
            position: relative;
            z-index: 1;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 700; /* Bold */
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .header p {
            opacity: 0.95;
            font-size: 1.1em;
            font-weight: 300;
        }
        
        .content {
            padding: 30px;
            background: linear-gradient(to bottom, #f9f9f9, #ffffff);
        }
        
        .input-section {
            margin-bottom: 30px;
            position: relative;
        }
        
        .input-section label {
            display: block;
            margin-bottom: 15px;
            font-weight: 600;
            color: #333;
            font-size: 1.1em;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            padding-left: 5px;
        }
        
        .input-section label::before {
            content: 'üìã ';
            margin-right: 5px;
        }
        
        textarea {
            width: 100%;
            height: 250px;
            padding: 20px;
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            resize: vertical;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            background: #fff;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.05);
            line-height: 1.5;
        } 
        
        textarea:focus {
            outline: none;
            border-color: #ff5900; /* Orange focus */
            box-shadow: 0 0 0 3px rgba(255, 89, 0, 0.15), inset 0 2px 5px rgba(0,0,0,0.05);
            transform: translateY(-1px);
        }
        
        /* Added checkbox styling */
        .checkbox-container {
            margin-top: 15px;
            padding: 10px 0;
            display: flex;
            align-items: center;
        }
        
        .checkbox-container input[type="checkbox"] {
            margin-right: 10px;
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        .checkbox-container label {
            display: inline;
            margin: 0;
            font-weight: 500;
            cursor: pointer;
            color: #333;
        }
        
        .button-container {
            text-align: center;
            margin: 30px 0;
        }
        
        .analyze-btn {
            background: linear-gradient(135deg, #411517 0%, #5a1f22 100%); /* Changed to requested color */
            color: white;
            border: none;
            padding: 18px 50px;
            font-size: 18px;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-weight: 600;
            letter-spacing: 0.5px;
            box-shadow: 0 8px 20px rgba(65, 21, 23, 0.3);
            position: relative;
            overflow: hidden;
        }
        
        .analyze-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: 0.5s;
        }
        
        .analyze-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 25px rgba(65, 21, 23, 0.4);
        }
        
        .analyze-btn:hover::before {
            left: 100%;
        }
        
        .analyze-btn:active {
            transform: translateY(-1px);
            box-shadow: 0 5px 15px rgba(65, 21, 23, 0.4);
        }
        
        .analyze-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
            box-shadow: 0 5px 15px rgba(65, 21, 23, 0.2);
        }
        
        .loading {
            text-align: center;
            margin: 20px 0;
        }
        
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #ff5900; /* Orange spinner */
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .result-container {
            display: none;
            animation: fadeIn 0.5s;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .result-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 25px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 12px;
            margin-bottom: 30px;
            border: 1px solid #dee2e6;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
        }
        
        .result-header h2 {
            color: #333;
            font-size: 1.8em;
            font-weight: 600;
        }
        
        .result-header p {
            color: #666;
            margin-top: 8px;
            font-size: 0.95em;
            opacity: 0; /* Hidden */
            height: 0;
            overflow: hidden;
        }
        
        .final-result {
            font-size: 24px;
            font-weight: 700;
            padding: 15px 30px;
            border-radius: 10px;
            text-align: center;
            min-width: 200px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
        }
        
        .final-result:hover {
            transform: scale(1.02);
        }
        
        .result-before-pdt {
            background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
            color: #155724;
            border: 2px solid #b1d8b7;
        }
        
        .result-vendor-late {
            background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
            color: #856404;
            border: 2px solid #ffe082;
        }
        
        .result-rider-late {
            background: linear-gradient(135deg, #f8d7da 0%, #f5c6cb 100%);
            color: #721c24;
            border: 2px solid #f1b0b7;
        }
        
        .result-long-dispatch {
            background: linear-gradient(135deg, #cce5ff 0%, #b8daff 100%);
            color: #004085;
            border: 2px solid #9fc5e8;
        }
        
        .result-on-time {
            background: linear-gradient(135deg, #d1ecf1 0%, #bee5eb 100%);
            color: #0c5460;
            border: 2px solid #abdde5;
        }
        
        .result-picked-up-another-rider {
            background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%);
            color: #1b5e20;
            border: 2px solid #b2dfdb;
        }
        
        .columns-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 25px;
            margin-bottom: 30px;
        }
        
        .column-group {
            background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
            border-radius: 12px;
            padding: 25px;
            border: 1px solid #e9ecef;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .column-group:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 15px rgba(0,0,0,0.1);
        }
        
        .column-group h3 {
            color: #ff5900; /* Orange */
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 3px solid #ff5900;
            font-size: 1.3em;
            font-weight: 600;
            position: relative;
        }
        
        .column-group h3::after {
            content: '';
            position: absolute;
            bottom: -3px;
            left: 0;
            width: 50px;
            height: 3px;
            background: #411517; /* Dark red */
        }
        
        .column-item {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px dashed #dee2e6;
            transition: padding-left 0.2s ease;
        }
        
        .column-item:hover {
            padding-left: 5px;
        }
        
        .column-item:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        
        .column-label {
            font-weight: 600;
            color: #495057;
            font-size: 0.95em;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
        }
        
        .column-label::before {
            content: '‚Ä¢';
            color: #ff5900;
            margin-right: 8px;
            font-size: 1.2em;
        }
        
        .column-value {
            color: #212529;
            font-weight: 500;
            font-size: 1.15em;
            word-break: break-all;
            padding: 5px 0;
        }
        
        .time-value {
            color: #e83e8c;
            font-family: 'Courier New', monospace;
            font-weight: 600;
        }
        
        .seconds-value {
            color: #20c997;
            font-weight: 700;
            background: rgba(32, 201, 151, 0.1);
            padding: 2px 8px;
            border-radius: 4px;
            display: inline-block;
        }
        
        .boolean-true {
            color: #28a745;
            font-weight: 700;
            background: rgba(40, 167, 69, 0.1);
            padding: 2px 10px;
            border-radius: 20px;
            display: inline-block;
        }
        
        .boolean-false {
            color: #dc3545;
            font-weight: 700;
            background: rgba(220, 53, 69, 0.1);
            padding: 2px 10px;
            border-radius: 20px;
            display: inline-block;
        }
        
        .column-note {
            font-size: 0.85em;
            color: #6c757d;
            margin-top: 5px;
            font-style: italic;
            padding-left: 15px;
            border-left: 2px solid #dee2e6;
        }
        
        .formula-section {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 12px;
            padding: 25px;
            margin-top: 30px;
            border: 1px solid #dee2e6;
            display: none; /* Hidden */
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
        }
        
        .formula-section h3 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.3em;
        }
        
        .formula-step {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            border-left: 4px solid #667eea;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            overflow-x: auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        
        .error {
            background: linear-gradient(135deg, #f8d7da 0%, #f5c6cb 100%);
            color: #721c24;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            border: 1px solid #f1b0b7;
            display: none;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
        }
        
        .debug-toggle {
            text-align: center;
            margin: 20px 0;
            display: none;
        }
        
        .debug-btn {
            background: #6c757d;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s;
        }
        
        .debug-btn:hover {
            background: #545b62;
        }
        
        .debug-info {
            background: #212529;
            color: #20c997;
            padding: 20px;
            border-radius: 10px;
            margin-top: 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            white-space: pre-wrap;
            display: none;
            max-height: 400px;
            overflow-y: auto;
        }
        
        /* NEW: Picked up by another rider section styling */
        .picked-up-section {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 12px;
            padding: 25px;
            margin-top: 30px;
            border: 1px solid #dee2e6;
            display: none;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
        }
        
        .picked-up-section h3 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.3em;
        }
        
        .picked-up-result {
            background: white;
            padding: 20px;
            border-radius: 10px;
            border-left: 4px solid #28a745;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        
        .picked-up-total {
            font-size: 1.5em;
            font-weight: 600;
            color: #28a745;
            margin-bottom: 10px;
        }
        
        .picked-up-breakdown {
            margin-top: 15px;
        }
        
        .picked-up-pattern {
            background: #f1f8ff;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            border-left: 3px solid #4a90e2;
        }
        
        .picked-up-pattern-header {
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
        }
        
        .picked-up-pattern-details {
            color: #666;
            font-size: 0.9em;
            font-family: 'Courier New', monospace;
        }
        
        /* NEW: Comparison result styling */
        .comparison-section {
            background: linear-gradient(135deg, #fff8e1 0%, #ffecb3 100%);
            border-radius: 12px;
            padding: 25px;
            margin-top: 30px;
            border: 2px solid #ffd54f;
            display: none;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
        }
        
        .comparison-section h3 {
            color: #ff8f00;
            margin-bottom: 20px;
            font-size: 1.3em;
        }
        
        .comparison-result {
            background: white;
            padding: 20px;
            border-radius: 10px;
            border-left: 4px solid #ff8f00;
            margin-bottom: 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        
        .comparison-details {
            background: #fffde7;
            padding: 15px;
            border-radius: 8px;
            margin-top: 10px;
            font-family: 'Courier New', monospace;
        }
        
        .comparison-formula {
            color: #d84315;
            font-weight: 600;
            margin-top: 10px;
            padding: 10px;
            background: #ffecb3;
            border-radius: 6px;
        }
        
        .comparison-verdict {
            font-size: 1.2em;
            font-weight: 600;
            color: #e65100;
            margin-top: 15px;
            padding: 15px;
            background: #ffcc80;
            border-radius: 8px;
            text-align: center;
        }
        
        /* Enhanced responsive design */
        @media (max-width: 992px) {
            .columns-grid {
                grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            }
        }
        
        @media (max-width: 768px) {
            .columns-grid {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .content {
                padding: 20px;
            }
            
            .result-header {
                flex-direction: column;
                text-align: center;
                gap: 20px;
            }
            
            .result-header h2 {
                margin-bottom: 10px;
            }
            
            .final-result {
                min-width: 100%;
            }
            
            .analyze-btn {
                padding: 16px 40px;
                font-size: 16px;
            }
        }
        
        @media (max-width: 480px) {
            .header h1 {
                font-size: 1.8em;
            }
            
            .header {
                padding: 20px;
            }
            
            .content {
                padding: 15px;
            }
            
            .column-group {
                padding: 20px;
            }
            
            .analyze-btn {
                padding: 14px 30px;
                font-size: 16px;
                width: 100%;
            }
        }
        
        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 10px;
        }
        
        ::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 5px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #ff5900 0%, #411517 100%);
            border-radius: 5px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, #e64a00 0%, #5a1f22 100%);
        }
        
        /* Selection color */
        ::selection {
            background: rgba(255, 89, 0, 0.3);
            color: #411517;
        }
        
        /* Focus styles for accessibility */
        *:focus {
            outline: 2px solid #ff5900;
            outline-offset: 2px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="header-content">
                <h1>üìä Late Owner Analysis Tool</h1>
                <p>Created by talabat SSC Analytics Team.‚Äã</p>
            </div>
        </div>
        
        <div class="content">
            <div class="input-section">
                <label for="orderDetails">üìã Paste Order Details</label>
                <textarea id="orderDetails" placeholder="Make sure to expand the rider's delivery to be able to see the rider's event&#10;Then press CTRL + A >> Copy >> then paste it here"></textarea>
                
                <!-- Hidden checkbox -->
                <div class="checkbox-container" style="display: none;">
                    <input type="checkbox" id="localShopAE">
                    <label for="localShopAE">Local Shop AE (Adds 30 minutes to PDT instead of 10 minutes - ONLY if Country is AE)</label>
                </div>
            </div>
            
            <div class="error" id="errorMessage"></div>
            
            <div class="loading" id="loading" style="display: none;">
                <div class="spinner"></div>
                <p>Analyzing order details...</p>
            </div>
            
            <div class="button-container">
                <button class="analyze-btn" id="analyzeBtn" onclick="analyzeOrder()">üöÄ Analyze Order</button>
            </div>
            
            <div class="result-container" id="resultContainer">
                <div class="result-header">
                    <div>
                        <h2>Analysis Result</h2>
                        <p style="color: #666; margin-top: 5px;">Column Z equivalent calculation</p>
                    </div>
                    <div class="final-result" id="finalResult"></div>
                </div>
                
                <!-- Hidden sections -->
                <div class="picked-up-section" id="pickedUpSection" style="display: none;">
                    <h3>üîÑ Picked up by another rider</h3>
                    <div id="pickedUpContent"></div>
                </div>
                
                <div class="comparison-section" id="comparisonSection" style="display: none;">
                    <h3>üìä Long Dispatch Comparison</h3>
                    <div id="comparisonContent"></div>
                </div>
                
                <div class="columns-grid" id="columnsGrid">
                    <!-- Columns will be populated here -->
                </div>
                
                <div class="formula-section">
                    <h3>üßÆ Formula Calculations:</h3>
                    <div id="formulaSteps"></div>
                </div>
                
                <div class="debug-toggle">
                    <button class="debug-btn" onclick="toggleDebug()">üîç Show Debug Info</button>
                    <div class="debug-info" id="debugInfo"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let debugData = {};
        
        function toggleDebug() {
            const debug = document.getElementById('debugInfo');
            debug.style.display = debug.style.display === 'block' ? 'none' : 'block';
        }
        
        function analyzeOrder() {
            const details = document.getElementById('orderDetails').value.trim();
            const errorDiv = document.getElementById('errorMessage');
            const loadingDiv = document.getElementById('loading');
            const resultContainer = document.getElementById('resultContainer');
            const analyzeBtn = document.getElementById('analyzeBtn');
            
            // Get checkbox state
            const isLocalShopAE = document.getElementById('localShopAE').checked;
            
            // Reset UI
            errorDiv.style.display = 'none';
            resultContainer.style.display = 'none';
            document.getElementById('debugInfo').style.display = 'none';
            
            // Validate input
            if (!details) {
                errorDiv.textContent = 'Please paste order details in the text area';
                errorDiv.style.display = 'block';
                return;
            }
            
            // Show loading
            loadingDiv.style.display = 'block';
            analyzeBtn.disabled = true;
            analyzeBtn.textContent = 'Processing...';
            
            // Process the details
            setTimeout(() => {
                try {
                    const result = processOrderDetails(details, isLocalShopAE);
                    debugData = result;
                    
                    // Calculate picked up by another rider
                    const pickedUpResult = calculatePickedUpByAnotherRider(details);
                    
                    // Update result display with original Z result
                    updateResultDisplay(result);
                    
                    // Display picked up by another rider results
                    updatePickedUpDisplay(pickedUpResult);
                    
                    // Check if we need to do Long Dispatch comparison
                    const finalZResult = checkLongDispatchComparison(result, pickedUpResult);
                    
                    // Update final result if changed by comparison
                    if (finalZResult !== result.columns.Z) {
                        updateFinalResult(finalZResult);
                        result.columns.Z = finalZResult; // Update the result object
                    }
                    
                    // Show result
                    resultContainer.style.display = 'block';
                    
                    // Update debug info
                    updateDebugInfo(result);
                    
                } catch (error) {
                    errorDiv.textContent = 'Error processing details: ' + error.message;
                    errorDiv.style.display = 'block';
                    console.error('Processing error:', error);
                } finally {
                    // Hide loading
                    loadingDiv.style.display = 'none';
                    analyzeBtn.disabled = false;
                    analyzeBtn.textContent = 'üöÄ Analyze Order';
                }
            }, 500);
        }
        
        // NEW FUNCTION: Calculate picked up by another rider
        function calculatePickedUpByAnotherRider(text) {
            console.log("=== Calculating Picked up by another rider ===");
            
            const result = {
                totalSeconds: 0,
                patterns: [],
                breakdown: []
            };
            
            // Parse time string to minutes since midnight
            function parseTimeToMinutes(timeStr) {
                if (!timeStr) return null;
                
                const cleaned = timeStr.trim().toLowerCase().replace(/\s+(am|pm)/, '$1');
                const timeMatch = cleaned.match(/^(\d{1,2}):(\d{2})\s*(am|pm)$/);
                
                if (!timeMatch) {
                    console.log('No time match for visibility:', timeStr);
                    return null;
                }
                
                let hours = parseInt(timeMatch[1]);
                const minutes = parseInt(timeMatch[2]);
                const period = timeMatch[3];
                
                // Convert to 24-hour format
                if (period === 'pm') {
                    if (hours < 12) hours += 12;
                } else if (period === 'am') {
                    if (hours === 12) hours = 0;
                }
                
                return hours * 60 + minutes;
            }
            
            // Convert minutes to seconds
            function minutesToSeconds(minutes) {
                return minutes * 60;
            }
            
            // Format minutes as HH:MM
            function formatMinutes(totalMinutes) {
                const hours = Math.floor(totalMinutes / 60);
                const minutes = totalMinutes % 60;
                return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
            }
            
            // Find all lines with times and events
            const lines = text.split('\n');
            const events = [];
            
            // Collect all events with their times
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                // Look for time patterns like "9:00 PM" at the beginning of a line
                const timeMatch = line.match(/^(\d{1,2}:\d{2}\s*[APM]{2})/i);
                if (timeMatch) {
                    const timeStr = timeMatch[1];
                    const timeMinutes = parseTimeToMinutes(timeStr);
                    
                    // Check if next line has an event
                    if (i + 1 < lines.length) {
                        const nextLine = lines[i + 1].trim();
                        if (nextLine && !nextLine.match(/^\d{1,2}:\d{2}\s*[APM]{2}/i)) {
                            // This is an event line
                            events.push({
                                timeStr: timeStr,
                                timeMinutes: timeMinutes,
                                event: nextLine,
                                lineIndex: i
                            });
                            i++; // Skip the event line
                        }
                    }
                }
            }
            
            console.log("Found events:", events.length);
            
            // Find Accepted ‚Üí Queued patterns
            for (let i = 0; i < events.length; i++) {
                const currentEvent = events[i];
                
                // Look for "Accepted" events
                if (currentEvent.event.includes("Accepted") && !currentEvent.event.includes("Courier Notified")) {
                    console.log(`Found Accepted at ${currentEvent.timeStr}`);
                    
                    // Look for the next "Queued" event (could be after other events)
                    let queuedFound = false;
                    let j = i + 1;
                    
                    while (j < events.length && !queuedFound) {
                        if (events[j].event.includes("Queued") && 
                            !events[j].event.includes("Delivery Enqueued")) { // Skip initial "Queued" event
                            
                            console.log(`Found subsequent Queued at ${events[j].timeStr}`);
                            
                            // Calculate time difference
                            if (currentEvent.timeMinutes !== null && events[j].timeMinutes !== null) {
                                // Handle midnight crossing (if queued time is earlier than accepted time)
                                let timeDiffMinutes;
                                if (events[j].timeMinutes >= currentEvent.timeMinutes) {
                                    timeDiffMinutes = events[j].timeMinutes - currentEvent.timeMinutes;
                                } else {
                                    // Queued is on the next day (after midnight)
                                    timeDiffMinutes = (24 * 60 - currentEvent.timeMinutes) + events[j].timeMinutes;
                                }
                                
                                const timeDiffSeconds = minutesToSeconds(timeDiffMinutes);
                                
                                result.patterns.push({
                                    acceptedTime: currentEvent.timeStr,
                                    queuedTime: events[j].timeStr,
                                    durationMinutes: timeDiffMinutes,
                                    durationSeconds: timeDiffSeconds,
                                    acceptedEvent: currentEvent.event,
                                    queuedEvent: events[j].event
                                });
                                
                                result.totalSeconds += timeDiffSeconds;
                                queuedFound = true;
                                
                                console.log(`Pattern ${result.patterns.length}: ${currentEvent.timeStr} ‚Üí ${events[j].timeStr} = ${timeDiffMinutes} min = ${timeDiffSeconds} sec`);
                            }
                        }
                        j++;
                    }
                }
            }
            
            // Create breakdown for display
            if (result.patterns.length > 0) {
                result.breakdown = result.patterns.map((pattern, index) => {
                    return {
                        patternNumber: index + 1,
                        acceptedTime: pattern.acceptedTime,
                        queuedTime: pattern.queuedTime,
                        duration: `${pattern.durationMinutes} min (${pattern.durationSeconds} sec)`,
                        calculation: `${pattern.acceptedTime} ‚Üí ${pattern.queuedTime} = ${pattern.durationMinutes} √ó 60 = ${pattern.durationSeconds} sec`
                    };
                });
            }
            
            console.log("Picked up by another rider calculation complete:", result);
            return result;
        }
        
        // NEW FUNCTION: Check Long Dispatch comparison
        function checkLongDispatchComparison(orderResult, pickedUpResult) {
            console.log("=== Checking Long Dispatch Comparison ===");
            
            const originalZResult = orderResult.columns.Z;
            const systemLateSeconds = parseFloat(orderResult.columns.U.replace('s', '') || 0);
            const pickedUpTotalSeconds = pickedUpResult.totalSeconds;
            
            console.log("Original Z Result:", originalZResult);
            console.log("System Late (U):", systemLateSeconds, "seconds");
            console.log("Picked up by another rider:", pickedUpTotalSeconds, "seconds");
            
            // Only do comparison if original result is Long Dispatch
            if (originalZResult.includes("Long Dispatch") || originalZResult === "Long Dispatch") {
                console.log("Original result is Long Dispatch, performing comparison...");
                
                // Calculate: (System Late Duration - Picked up by another rider)
                const comparisonValue = systemLateSeconds - pickedUpTotalSeconds;
                
                console.log("Comparison value (U - Picked up):", comparisonValue);
                
                // Check condition: if (U - Picked up) > Picked up
                if (comparisonValue > pickedUpTotalSeconds) {
                    console.log("Condition met: (U - Picked up) > Picked up");
                    console.log(`${comparisonValue} > ${pickedUpTotalSeconds}`);
                    console.log("Result remains: Long Dispatch");
                    
                    // Show comparison section
                    updateComparisonDisplay(originalZResult, systemLateSeconds, pickedUpTotalSeconds, comparisonValue, originalZResult);
                    
                    return originalZResult; // Remain as Long Dispatch
                } else {
                    console.log("Condition NOT met: (U - Picked up) ‚â§ Picked up");
                    console.log(`${comparisonValue} ‚â§ ${pickedUpTotalSeconds}`);
                    console.log("Result changed to: Picked up by another rider");
                    
                    // Show comparison section
                    updateComparisonDisplay(originalZResult, systemLateSeconds, pickedUpTotalSeconds, comparisonValue, "Picked up by another rider");
                    
                    return "Picked up by another rider";
                }
            } else {
                console.log("Original result is not Long Dispatch, no comparison needed");
                // Hide comparison section if not Long Dispatch
                document.getElementById('comparisonSection').style.display = 'none';
                return originalZResult;
            }
        }
        
        // NEW FUNCTION: Update picked up display
        function updatePickedUpDisplay(pickedUpResult) {
            const pickedUpSection = document.getElementById('pickedUpSection');
            const pickedUpContent = document.getElementById('pickedUpContent');
            
            if (pickedUpResult.patterns.length === 0) {
                pickedUpSection.style.display = 'none';
                return;
            }
            
            pickedUpSection.style.display = 'none'; // Keep hidden
            return;
            
            // The following code won't execute due to the return above
            pickedUpSection.style.display = 'block';
            
            let html = `
                <div class="picked-up-result">
                    <div class="picked-up-total">
                        Total Picked up by another rider: ${Math.round(pickedUpResult.totalSeconds)} seconds
                        (${Math.round(pickedUpResult.totalSeconds / 60)} minutes)
                    </div>
                    <div>Found ${pickedUpResult.patterns.length} Accepted ‚Üí Queued pattern(s)</div>
                </div>
            `;
            
            if (pickedUpResult.breakdown.length > 0) {
                html += `<div class="picked-up-breakdown">`;
                
                pickedUpResult.breakdown.forEach(item => {
                    html += `
                        <div class="picked-up-pattern">
                            <div class="picked-up-pattern-header">
                                <span>Pattern ${item.patternNumber}</span>
                                <span>${item.duration}</span>
                            </div>
                            <div class="picked-up-pattern-details">
                                ${item.calculation}
                            </div>
                        </div>
                    `;
                });
                
                html += `</div>`;
            }
            
            pickedUpContent.innerHTML = html;
        }
        
        // NEW FUNCTION: Update comparison display
        function updateComparisonDisplay(originalResult, systemLateSeconds, pickedUpSeconds, comparisonValue, finalResult) {
            const comparisonSection = document.getElementById('comparisonSection');
            const comparisonContent = document.getElementById('comparisonContent');
            
            comparisonSection.style.display = 'none'; // Keep hidden
            return;
            
            // The following code won't execute due to the return above
            comparisonSection.style.display = 'block';
            
            let html = `
                <div class="comparison-result">
                    <div style="font-size: 1.2em; font-weight: 600; margin-bottom: 10px;">
                        Original Z Result: <span style="color: #004085;">${originalResult}</span>
                    </div>
                    <div class="comparison-details">
                        <div><strong>System Late Duration (U):</strong> ${systemLateSeconds} seconds</div>
                        <div><strong>Picked up by another rider:</strong> ${pickedUpSeconds} seconds</div>
                        <div><strong>Comparison:</strong> (U - Picked up) = ${systemLateSeconds} - ${pickedUpSeconds} = ${comparisonValue} seconds</div>
                    </div>
                    
                    <div class="comparison-formula">
                        Condition Check: (U - Picked up) > Picked up ?<br>
                        ${comparisonValue} > ${pickedUpSeconds} ?
                    </div>
                    
                    <div class="comparison-verdict">
                        Final Result: ${finalResult}
                    </div>
                </div>
            `;
            
            comparisonContent.innerHTML = html;
        }
        
        // NEW FUNCTION: Update final result display with new result
        function updateFinalResult(finalResult) {
            const finalResultDiv = document.getElementById('finalResult');
            finalResultDiv.textContent = finalResult;
            
            // Update styling based on new result
            finalResultDiv.className = 'final-result ';
            
            if (finalResult === "Before PDT") {
                finalResultDiv.classList.add('result-before-pdt');
            } else if (finalResult.includes("Vendor Late")) {
                finalResultDiv.classList.add('result-vendor-late');
            } else if (finalResult.includes("Rider Late")) {
                finalResultDiv.classList.add('result-rider-late');
            } else if (finalResult.includes("Long Dispatch")) {
                finalResultDiv.classList.add('result-long-dispatch');
            } else if (finalResult.includes("Picked up by another rider")) {
                finalResultDiv.classList.add('result-picked-up-another-rider');
            } else if (finalResult !== "Before PDT") {
                finalResultDiv.classList.add('result-on-time');
            } else {
                finalResultDiv.classList.add('result-on-time');
            }
        }
        
        function processOrderDetails(text, isLocalShopAE) {
            const result = {
                columns: {},
                timestamps: {},
                extracted: {},
                formulas: []
            };
            
            console.log('Processing text...');
            
            // Helper: Parse time string to Date object - FIXED VERSION
            function parseTime(timeStr) {
                if (!timeStr) return null;
                
                console.log('Parsing time string:', timeStr);
                
                // Clean the time string - normalize format
                let cleaned = timeStr.trim().toLowerCase();
                
                // Remove any spaces in am/pm
                cleaned = cleaned.replace(/\s+(am|pm)/, '$1');
                
                // Match time pattern
                const timeMatch = cleaned.match(/^(\d{1,2}):(\d{2})(?::(\d{2}))?\s*(am|pm)$/);
                if (!timeMatch) {
                    console.log('No time match for:', timeStr);
                    return null;
                }
                
                let hours = parseInt(timeMatch[1]);
                const minutes = parseInt(timeMatch[2]);
                const seconds = timeMatch[3] ? parseInt(timeMatch[3]) : 0;
                const period = timeMatch[4];
                
                console.log('Time components:', { hours, minutes, seconds, period });
                
                // Convert to 24-hour format - FIXED LOGIC
                if (period === 'pm') {
                    if (hours < 12) {
                        hours += 12;
                    }
                    // 12 pm stays 12 (noon)
                } else if (period === 'am') {
                    if (hours === 12) {
                        hours = 0; // 12 am is midnight
                    }
                    // All other am times stay as-is
                }
                
                // Validate
                if (hours < 0 || hours > 23 || minutes < 0 || minutes > 59 || seconds < 0 || seconds > 59) {
                    console.log('Invalid time:', hours, minutes, seconds);
                    return null;
                }
                
                const date = new Date();
                date.setHours(hours, minutes, seconds, 0);
                console.log('Parsed time result - getHours():', date.getHours(), 'formatted:', date.toLocaleTimeString('en-US', { hour12: true }));
                return date;
            }
            
            // Helper: Parse date string
            function parseDate(dateStr) {
                if (!dateStr) return null;
                
                console.log('Parsing date:', dateStr);
                
                // Try multiple patterns
                // Pattern 1: "Mon 22 Dec" (with day name)
                const dateMatch1 = dateStr.match(/(\w{3})\s+(\d{1,2})\s+(\w{3})/i);
                
                // Pattern 2: Just "22 Dec" (without day name)
                const dateMatch2 = dateStr.match(/(\d{1,2})\s+(\w{3})/i);
                
                let dateNum, month;
                
                if (dateMatch1) {
                    dateNum = parseInt(dateMatch1[2]);
                    month = dateMatch1[3];
                    console.log('Pattern 1 matched:', dateMatch1[0]);
                } else if (dateMatch2) {
                    dateNum = parseInt(dateMatch2[1]);
                    month = dateMatch2[2];
                    console.log('Pattern 2 matched:', dateMatch2[0]);
                } else {
                    console.log('No date match for:', dateStr);
                    return null;
                }
                
                const now = new Date();
                const year = now.getFullYear();
                
                const monthNames = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 
                                   'jul', 'aug', 'sep', 'oct', 'nov', 'dec'];
                const monthIndex = monthNames.indexOf(month.toLowerCase());
                
                if (monthIndex === -1) {
                    console.log('Invalid month:', month);
                    return null;
                }
                
                const dateObj = new Date(year, monthIndex, dateNum, 0, 0, 0);
                console.log('Parsed date:', dateStr, '->', dateObj.toLocaleDateString());
                return dateObj;
            }
            
            // Helper: Format time as HH:MM:SS AM/PM - FIXED VERSION
            function formatTime(date) {
                if (!date) return '';
                
                // Get local time components
                let hours = date.getHours();
                const minutes = date.getMinutes();
                const seconds = date.getSeconds();
                
                // Determine AM/PM
                const ampm = hours >= 12 ? 'PM' : 'AM';
                
                // Convert to 12-hour format
                hours = hours % 12;
                hours = hours ? hours : 12; // 0 becomes 12
                
                // Format with leading zeros
                const hoursStr = hours.toString().padStart(2, '0');
                const minutesStr = minutes.toString().padStart(2, '0');
                const secondsStr = seconds.toString().padStart(2, '0');
                
                return `${hoursStr}:${minutesStr}:${secondsStr} ${ampm}`;
            }
            
            // Helper: Format date as MM/DD/YYYY
            function formatDate(date) {
                if (!date) return '';
                return (date.getMonth() + 1) + '/' + date.getDate() + '/' + date.getFullYear();
            }
            
            // Helper: Format datetime
            function formatDateTime(date) {
                if (!date) return '';
                return formatDate(date) + ' ' + formatTime(date);
            }
            
            // NEW HELPER: Find timeline event with dual pattern search
            function findTimelineEvent(eventName) {
                console.log(`=== Searching for ${eventName} ===`);
                
                // Pattern 1: "Something Delivery Something" (original pattern)
                const pattern1 = new RegExp(`(\\d{1,2}:\\d{2}\\s*[ap]m)\\s+${eventName}\\s+Delivery\\s+${eventName}`, 'gi');
                const matches1 = [...text.matchAll(pattern1)];
                
                // Pattern 2: "Something -" (alternative pattern)
                const pattern2 = new RegExp(`(\\d{1,2}:\\d{2}\\s*[ap]m)\\s+${eventName}\\s*-`, 'gi');
                const matches2 = [...text.matchAll(pattern2)];
                
                console.log(`Pattern 1 matches for ${eventName}:`, matches1.length);
                console.log(`Pattern 2 matches for ${eventName}:`, matches2.length);
                
                let finalMatch = null;
                
                // Try pattern 1 first
                if (matches1.length > 0) {
                    finalMatch = matches1[matches1.length - 1][0];
                    console.log(`Found ${eventName} with Pattern 1:`, finalMatch);
                }
                // If pattern 1 fails, try pattern 2
                else if (matches2.length > 0) {
                    finalMatch = matches2[matches2.length - 1][0];
                    console.log(`Found ${eventName} with Pattern 2:`, finalMatch);
                }
                
                if (finalMatch) {
                    // Extract the time from the match
                    const timeMatch = finalMatch.match(/(\d{1,2}:\d{2}\s*[ap]m)/i);
                    if (timeMatch) {
                        return timeMatch[1];
                    }
                }
                
                console.log(`No match found for ${eventName} with either pattern`);
                return null;
            }
            
            // B: Order ID
            const backendMatch = text.match(/(\d+)\s*Backend\s*Link/i);
            result.columns.B = backendMatch ? backendMatch[1].trim() : '';
            result.formulas.push('B: Order ID = ' + result.columns.B);
            console.log('B: Order ID =', result.columns.B);
            
            // C: Country - UPDATED to handle multiple patterns
            let countryMatch = text.match(/TB_([A-Z]{2})/i);
            if (!countryMatch) {
                // Try HF_ pattern if TB_ not found
                countryMatch = text.match(/HF_([A-Z]{2})/i);
            }
            if (!countryMatch) {
                // Try ODR_ pattern as fallback
                countryMatch = text.match(/ODR_([A-Z]{2})/i);
            }
            result.columns.C = countryMatch ? countryMatch[1].trim() : '';
            result.formulas.push('C: Country = ' + result.columns.C);
            console.log('C: Country =', result.columns.C);
            
            // D: Order Date
            const dateMatch = text.match(/Ordered at\s*[:]?\s*(\w{3}\s+\d{1,2}\s+\w{3}|\d{1,2}\s+\w{3})/i);
            let orderDate = null;
            if (dateMatch) {
                console.log('Date match found:', dateMatch[1]);
                orderDate = parseDate(dateMatch[1]);
                result.columns.D = orderDate ? formatDate(orderDate) : '';
            } else {
                console.log('No date match found');
            }
            result.formulas.push('D: Order Date = ' + result.columns.D);
            console.log('D: Order Date =', result.columns.D);
            
            // E: Ordered at - FIXED MULTILINE VERSION
            console.log('=== Searching for E: Ordered at ===');
            
            // Method 1: Look for "Ordered at" then capture time from next line (multiline)
            const orderedAtRegex1 = /Ordered\s+at[\s\S]*?(\d{1,2}:\d{2}\s*[ap]m)/i;
            const orderedTimeMatch1 = text.match(orderedAtRegex1);
            
            let orderedTime = null;
            if (orderedTimeMatch1) {
                console.log('Ordered at regex 1 matched:', orderedTimeMatch1[1]);
                console.log('Full match (first 100 chars):', orderedTimeMatch1[0].substring(0, 100));
                orderedTime = parseTime(orderedTimeMatch1[1]);
            }
            
            // Method 2: If first method fails, try line-by-line search
            if (!orderedTime) {
                console.log('Ordered at regex 1 failed, trying line search...');
                const lines = text.split('\n');
                for (let i = 0; i < lines.length; i++) {
                    if (lines[i].includes('Ordered at')) {
                        console.log('Found "Ordered at" on line', i, ':', lines[i]);
                        // Check current line for time
                        let timeMatch = lines[i].match(/(\d{1,2}:\d{2}\s*[ap]m)/i);
                        if (timeMatch) {
                            console.log('Found time on same line:', timeMatch[1]);
                            orderedTime = parseTime(timeMatch[1]);
                            break;
                        }
                        // Check next line
                        if (i + 1 < lines.length) {
                            timeMatch = lines[i + 1].match(/(\d{1,2}:\d{2}\s*[ap]m)/i);
                            if (timeMatch) {
                                console.log('Found time on next line:', timeMatch[1]);
                                orderedTime = parseTime(timeMatch[1]);
                                break;
                            }
                        }
                        // Check line after next
                        if (i + 2 < lines.length) {
                            timeMatch = lines[i + 2].match(/(\d{1,2}:\d{2}\s*[ap]m)/i);
                            if (timeMatch) {
                                console.log('Found time on line after next:', timeMatch[1]);
                                orderedTime = parseTime(timeMatch[1]);
                                break;
                            }
                        }
                    }
                }
            }
            
            // Method 3: Try a more specific pattern for the structure
            if (!orderedTime) {
                console.log('Line search failed, trying specific pattern...');
                const orderedAtRegex3 = /Ordered\s+at\s*\n\s*[^\n]*?(\d{1,2}:\d{2}\s*[ap]m)/i;
                const orderedTimeMatch3 = text.match(orderedAtRegex3);
                if (orderedTimeMatch3) {
                    console.log('Ordered at regex 3 matched:', orderedTimeMatch3[1]);
                    orderedTime = parseTime(orderedTimeMatch3[1]);
                }
            }
            
            if (orderedTime) {
                console.log('Ordered at time successfully parsed:', formatTime(orderedTime));
                result.columns.E = formatTime(orderedTime);
            } else {
                console.log('No ordered time found after all attempts');
                result.columns.E = 'N/A';
            }
            result.formulas.push('E: Ordered at = ' + result.columns.E);
            console.log('E: Ordered at =', result.columns.E);
            
            // If no order date yet, use today
            if (!orderDate) {
                orderDate = new Date();
                orderDate.setHours(0, 0, 0, 0);
                result.columns.D = formatDate(orderDate);
            }
            
            // Store base values for calculations
            const baseDate = orderDate;
            const baseTime = orderedTime;
            
            console.log('Base date:', baseDate.toLocaleDateString());
            console.log('Base time:', baseTime ? baseTime.toLocaleTimeString() : 'null');
            
            // Helper: Combine date and time, adjust for midnight crossing
            function combineDateTime(datePart, timeValue, referenceTime) {
                if (!datePart || !timeValue) return null;
                
                const dateTime = new Date(datePart);
                dateTime.setHours(timeValue.getHours(), timeValue.getMinutes(), timeValue.getSeconds());
                
                if (referenceTime && timeValue < referenceTime) {
                    dateTime.setDate(dateTime.getDate() + 1);
                    console.log('Adjusted date +1 day for crossing midnight');
                }
                
                return dateTime;
            }
            
            // F: Queued At - USING DUAL PATTERN SEARCH
            const queuedTimeStr = findTimelineEvent('Queued');
            if (queuedTimeStr) {
                console.log('Queued time found:', queuedTimeStr);
                const queuedTime = parseTime(queuedTimeStr);
                if (queuedTime) {
                    result.timestamps.F = combineDateTime(baseDate, queuedTime, baseTime);
                    result.columns.F = result.timestamps.F ? formatDateTime(result.timestamps.F) : '';
                }
            } else {
                // Fallback to old pattern if new search fails
                const queuedMatch = text.match(/(\d{1,2}:\d{2}\s?[apm]+)\s*Queued/i);
                if (queuedMatch) {
                    console.log('Queued fallback match found:', queuedMatch[1]);
                    const queuedTime = parseTime(queuedMatch[1]);
                    if (queuedTime) {
                        result.timestamps.F = combineDateTime(baseDate, queuedTime, baseTime);
                        result.columns.F = result.timestamps.F ? formatDateTime(result.timestamps.F) : '';
                    }
                }
            }
            result.formulas.push('F: Queued At = ' + result.columns.F);
            
            // G: Courier Notified - USING DUAL PATTERN SEARCH
            const courierTimeStr = findTimelineEvent('Courier Notified');
            if (courierTimeStr) {
                console.log('Courier Notified time found:', courierTimeStr);
                const courierTime = parseTime(courierTimeStr);
                if (courierTime) {
                    result.timestamps.G = combineDateTime(baseDate, courierTime, baseTime);
                    result.columns.G = result.timestamps.G ? formatTime(result.timestamps.G) : '';
                }
            } else {
                // Fallback to old pattern if new search fails
                const courierMatch = text.match(/(\d{1,2}:\d{2}\s?[apm]+)\s+Courier\s+Notified/i);
                if (courierMatch) {
                    console.log('Courier fallback match found:', courierMatch[1]);
                    const courierTime = parseTime(courierMatch[1]);
                    if (courierTime) {
                        result.timestamps.G = combineDateTime(baseDate, courierTime, baseTime);
                        result.columns.G = result.timestamps.G ? formatTime(result.timestamps.G) : '';
                    }
                }
            }
            result.formulas.push('G: Courier Notified = ' + result.columns.G);
            
            // H: Accepted At - USING DUAL PATTERN SEARCH
            const acceptedTimeStr = findTimelineEvent('Accepted');
            if (acceptedTimeStr) {
                console.log('Accepted time found:', acceptedTimeStr);
                const acceptedTime = parseTime(acceptedTimeStr);
                if (acceptedTime) {
                    result.timestamps.H = combineDateTime(baseDate, acceptedTime, baseTime);
                    result.columns.H = result.timestamps.H ? formatTime(result.timestamps.H) : '';
                }
            } else {
                // Fallback to old pattern if new search fails
                const acceptedMatches = [...text.matchAll(/(\d{1,2}:\d{2}\s*[ap]m)\s+Accepted\s+Delivery\s+Accepted/gi)];
                if (acceptedMatches.length > 0) {
                    const lastAccepted = acceptedMatches[acceptedMatches.length - 1][0];
                    const timeMatch = lastAccepted.match(/(\d{1,2}:\d{2}\s*[ap]m)/i);
                    if (timeMatch) {
                        console.log('Accepted fallback match found:', timeMatch[1]);
                        const acceptedTime = parseTime(timeMatch[1]);
                        if (acceptedTime) {
                            result.timestamps.H = combineDateTime(baseDate, acceptedTime, baseTime);
                            result.columns.H = result.timestamps.H ? formatTime(result.timestamps.H) : '';
                        }
                    }
                }
            }
            result.formulas.push('H: Accepted At = ' + result.columns.H);
            
            // I: Near Pickup - USING DUAL PATTERN SEARCH
            const nearPickupTimeStr = findTimelineEvent('Near Pickup');
            if (nearPickupTimeStr) {
                console.log('Near Pickup time found:', nearPickupTimeStr);
                const nearPickupTime = parseTime(nearPickupTimeStr);
                if (nearPickupTime) {
                    result.timestamps.I = combineDateTime(baseDate, nearPickupTime, baseTime);
                    result.columns.I = result.timestamps.I ? formatTime(result.timestamps.I) : '';
                }
            } else {
                // Fallback to old pattern if new search fails
                const nearPickupMatches = [...text.matchAll(/(\d{1,2}:\d{2}\s*[ap]m)\s+Near\s+Pickup\s+Delivery\s+Near\s+Pickup/gi)];
                if (nearPickupMatches.length > 0) {
                    const lastNearPickup = nearPickupMatches[nearPickupMatches.length - 1][0];
                    const timeMatch = lastNearPickup.match(/(\d{1,2}:\d{2}\s*[ap]m)/i);
                    if (timeMatch) {
                        console.log('Near Pickup fallback match found:', timeMatch[1]);
                        const nearPickupTime = parseTime(timeMatch[1]);
                        if (nearPickupTime) {
                            result.timestamps.I = combineDateTime(baseDate, nearPickupTime, baseTime);
                            result.columns.I = result.timestamps.I ? formatTime(result.timestamps.I) : '';
                        }
                    }
                }
            }
            result.formulas.push('I: Near Pickup = ' + result.columns.I);
            
            // J: Est. Pickup (CPT)
            const acceptedDashMatches = [...text.matchAll(/Accepted\s*[-]\s*(\d{1,2}:\d{2}\s*[apm]{2})/gi)];
            if (acceptedDashMatches.length > 0) {
                const lastAcceptedDash = acceptedDashMatches[acceptedDashMatches.length - 1][1];
                console.log('Accepted - time match found:', lastAcceptedDash);
                const estPickupTime = parseTime(lastAcceptedDash);
                if (estPickupTime) {
                    result.timestamps.J = combineDateTime(baseDate, estPickupTime, baseTime);
                    result.columns.J = result.timestamps.J ? formatTime(result.timestamps.J) : '';
                }
            }
            
            // Alternative for J: Look in timeline
            if (!result.columns.J) {
                const timelineSection = text.match(/Time\s+Event[\s\S]*?(?:\n\n|ID\s+\d|More Details|$)/i);
                if (timelineSection) {
                    const timelineText = timelineSection[0];
                    const estPickupMatch = timelineText.match(/(\d{1,2}:\d{2}\s*[AP]M)[^\n]*Est\.pickup arrival/i);
                    if (estPickupMatch) {
                        console.log('Est. Pickup in timeline:', estPickupMatch[1]);
                        const estPickupTime = parseTime(estPickupMatch[1]);
                        if (estPickupTime) {
                            result.timestamps.J = combineDateTime(baseDate, estPickupTime, baseTime);
                            result.columns.J = result.timestamps.J ? formatTime(result.timestamps.J) : '';
                        }
                    }
                }
            }
            result.formulas.push('J: Est. Pickup (CPT) = ' + result.columns.J);
            console.log('J: Est. Pickup (CPT) =', result.columns.J);
            
            // K: Picked Up At - USING DUAL PATTERN SEARCH
            const pickedUpTimeStr = findTimelineEvent('Picked Up');
            if (pickedUpTimeStr) {
                console.log('Picked Up time found:', pickedUpTimeStr);
                const pickedUpTime = parseTime(pickedUpTimeStr);
                if (pickedUpTime) {
                    result.timestamps.K = combineDateTime(baseDate, pickedUpTime, baseTime);
                    result.columns.K = result.timestamps.K ? formatTime(result.timestamps.K) : '';
                }
            } else {
                // Fallback to old pattern if new search fails
                const pickedUpMatches = [...text.matchAll(/(\d{1,2}:\d{2}\s*[ap]m)\s+Picked\s+Up\s+Delivery\s+Picked\s+Up/gi)];
                if (pickedUpMatches.length > 0) {
                    const lastPickedUp = pickedUpMatches[pickedUpMatches.length - 1][0];
                    const timeMatch = lastPickedUp.match(/(\d{1,2}:\d{2}\s*[ap]m)/i);
                    if (timeMatch) {
                        console.log('Picked Up fallback match found:', timeMatch[1]);
                        const pickedUpTime = parseTime(timeMatch[1]);
                        if (pickedUpTime) {
                            result.timestamps.K = combineDateTime(baseDate, pickedUpTime, baseTime);
                            result.columns.K = result.timestamps.K ? formatTime(result.timestamps.K) : '';
                        }
                    }
                }
            }
            result.formulas.push('K: Picked Up At = ' + result.columns.K);
            
            // L: Est. Dropoff
            console.log('=== Searching for L: Est. Dropoff ===');
            
            // Method 1: Use your exact Google Sheets formula pattern
            // Pattern: "Picked Up" followed by non-digits, then capture a time
            const estDropoffRegex = /Picked\s+Up\s+[^0-9\n]*(\d{1,2}:\d{2}\s*[APM]{2})/i;
            const estDropoffMatch = text.match(estDropoffRegex);
            
            if (estDropoffMatch) {
                console.log('Method 1 - Google Sheets pattern matched:', estDropoffMatch[1]);
                const estDropoffTime = parseTime(estDropoffMatch[1]);
                if (estDropoffTime) {
                    // Apply the same logic as your Google Sheets formula
                    // IF(time < E2, time + D2 + 1, time + D2)
                    if (estDropoffTime < baseTime) {
                        // If extracted time is before ordered time, add 1 day
                        const nextDay = new Date(baseDate);
                        nextDay.setDate(nextDay.getDate() + 1);
                        result.timestamps.L = combineDateTime(nextDay, estDropoffTime, baseTime);
                    } else {
                        result.timestamps.L = combineDateTime(baseDate, estDropoffTime, baseTime);
                    }
                    result.columns.L = result.timestamps.L ? formatTime(result.timestamps.L) : '';
                    console.log('L: Est. Dropoff calculated with Method 1:', result.columns.L);
                }
            }
            
            // Method 2: Look for specific timeline pattern from your data
            if (!result.columns.L) {
                console.log('Method 1 failed, trying Method 2...');
                // Pattern: time, Picked Up, dashes, then time (10:34 PM Picked Up - - - 10:51 PM)
                const timelinePattern = /(\d{1,2}:\d{2}\s*[AP]M)[^0-9]*Picked\s+Up[^0-9\-]*(-[^0-9\-]*){3}[^0-9]*(\d{1,2}:\d{2}\s*[AP]M)/i;
                const timelineMatch = text.match(timelinePattern);
                
                if (timelineMatch) {
                    console.log('Method 2 - Timeline pattern matched. First time:', timelineMatch[1], 'Second time:', timelineMatch[3]);
                    // The second time is likely Est.dropoff
                    const estDropoffTime = parseTime(timelineMatch[3]);
                    if (estDropoffTime) {
                        result.timestamps.L = combineDateTime(baseDate, estDropoffTime, baseTime);
                        result.columns.L = result.timestamps.L ? formatTime(result.timestamps.L) : '';
                        console.log('L: Est. Dropoff calculated with Method 2:', result.columns.L);
                    }
                }
            }
            
            // Method 3: Look for Picked Up row with multiple times
            if (!result.columns.L) {
                console.log('Method 2 failed, trying Method 3...');
                const lines = text.split('\n');
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (line.includes('Picked Up')) {
                        console.log('Found Picked Up line:', line);
                        // Extract all times from this line
                        const times = [...line.matchAll(/(\d{1,2}:\d{2}\s*[AP]M)/gi)];
                        console.log('Times in line:', times.map(t => t[0]));
                        
                        // Usually the last time or second time is Est.dropoff
                        if (times.length >= 2) {
                            // Try the last time first
                            const lastTime = times[times.length - 1][0];
                            console.log('Trying last time:', lastTime);
                            const estDropoffTime = parseTime(lastTime);
                            if (estDropoffTime) {
                                result.timestamps.L = combineDateTime(baseDate, estDropoffTime, baseTime);
                                result.columns.L = result.timestamps.L ? formatTime(result.timestamps.L) : '';
                                console.log('L: Est. Dropoff calculated with Method 3 (last time):', result.columns.L);
                                break;
                            }
                        }
                    }
                }
            }
            
            // Method 4: Look for Est.dropoff arrival specifically
            if (!result.columns.L) {
                console.log('Method 3 failed, trying Method 4...');
                const estDropoffArrivalMatch = text.match(/Est\.dropoff\s+arrival[^0-9\n]*(\d{1,2}:\d{2}\s*[AP]M)/i);
                if (estDropoffArrivalMatch) {
                    console.log('Method 4 - Est.dropoff arrival matched:', estDropoffArrivalMatch[1]);
                    const estDropoffTime = parseTime(estDropoffArrivalMatch[1]);
                    if (estDropoffTime) {
                        result.timestamps.L = combineDateTime(baseDate, estDropoffTime, baseTime);
                        result.columns.L = result.timestamps.L ? formatTime(result.timestamps.L) : '';
                        console.log('L: Est. Dropoff calculated with Method 4:', result.columns.L);
                    }
                }
            }
            
            // Method 5: Search in the timeline table section
            if (!result.columns.L) {
                console.log('Method 4 failed, trying Method 5...');
                // Find timeline section
                const timelineStart = text.search(/Time\s+Event/i);
                if (timelineStart !== -1) {
                    const timelineEnd = text.indexOf('\n\n', timelineStart);
                    const timelineText = text.substring(timelineStart, timelineEnd !== -1 ? timelineEnd : text.length);
                    
                    // Look for pattern with multiple times in Picked Up row
                    const pickedUpRowMatch = timelineText.match(/Picked\s+Up[^\n]*(\d{1,2}:\d{2}\s*[AP]M)[^\n]*$/im);
                    if (pickedUpRowMatch) {
                        console.log('Method 5 - Picked Up row in timeline matched time:', pickedUpRowMatch[1]);
                        const estDropoffTime = parseTime(pickedUpRowMatch[1]);
                        if (estDropoffTime) {
                            result.timestamps.L = combineDateTime(baseDate, estDropoffTime, baseTime);
                            result.columns.L = result.timestamps.L ? formatTime(result.timestamps.L) : '';
                            console.log('L: Est. Dropoff calculated with Method 5:', result.columns.L);
                        }
                    }
                }
            }
            
            // Last resort: Use PDT as fallback (often same as Est. Dropoff)
            if (!result.columns.L && result.columns.N) {
                console.log('All methods failed, using PDT as fallback for L: Est. Dropoff');
                result.timestamps.L = result.timestamps.N;
                result.columns.L = result.columns.N;
            }
            
            result.formulas.push('L: Est. Dropoff = ' + result.columns.L);
            console.log('=== L: Est. Dropoff final result =', result.columns.L, '===');
            
            // M: Near Dropoff - USING DUAL PATTERN SEARCH
            const nearDropoffTimeStr = findTimelineEvent('Near Dropoff');
            if (nearDropoffTimeStr) {
                console.log('Near Dropoff time found:', nearDropoffTimeStr);
                const nearDropoffTime = parseTime(nearDropoffTimeStr);
                if (nearDropoffTime) {
                    result.timestamps.M = combineDateTime(baseDate, nearDropoffTime, baseTime);
                    result.columns.M = result.timestamps.M ? formatTime(result.timestamps.M) : '';
                }
            } else {
                // Fallback to old pattern if new search fails
                const nearDropoffMatches = [...text.matchAll(/(\d{1,2}:\d{2}\s*[ap]m)\s+Near\s+Dropoff\s+Delivery\s+Near\s+Dropoff/gi)];
                if (nearDropoffMatches.length > 0) {
                    const lastNearDropoff = nearDropoffMatches[nearDropoffMatches.length - 1][0];
                    const timeMatch = lastNearDropoff.match(/(\d{1,2}:\d{2}\s*[ap]m)/i);
                    if (timeMatch) {
                        console.log('Near Dropoff fallback match found:', timeMatch[1]);
                        const nearDropoffTime = parseTime(timeMatch[1]);
                        if (nearDropoffTime) {
                            result.timestamps.M = combineDateTime(baseDate, nearDropoffTime, baseTime);
                            result.columns.M = result.timestamps.M ? formatTime(result.timestamps.M) : '';
                        }
                    }
                }
            }
            result.formulas.push('M: Near Dropoff = ' + result.columns.M);
            
            // N: PDT - FIXED MULTILINE VERSION
            console.log('=== Searching for N: PDT ===');
            
            // Method 1: Use [\s\S]*? to match across multiple lines
            const pdtRegex1 = /PDT[\s\S]*?(\d{1,2}:\d{2}\s*[ap]m)/i;
            const pdtMatch1 = text.match(pdtRegex1);
            
            let pdtTime = null;
            if (pdtMatch1) {
                console.log('PDT regex 1 matched:', pdtMatch1[1]);
                console.log('Full match (first 100 chars):', pdtMatch1[0].substring(0, 100));
                pdtTime = parseTime(pdtMatch1[1]);
            }
            
            // Method 2: If first method fails, try a more specific pattern
            if (!pdtTime) {
                console.log('PDT regex 1 failed, trying method 2...');
                // Look for PDT, then optional whitespace/newlines, then date, then time
                const pdtRegex2 = /PDT\s*\n?\s*[^\n]*?\s*(\d{1,2}:\d{2}\s*[ap]m)/i;
                const pdtMatch2 = text.match(pdtRegex2);
                if (pdtMatch2) {
                    console.log('PDT regex 2 matched:', pdtMatch2[1]);
                    pdtTime = parseTime(pdtMatch2[1]);
                }
            }
            
            // Method 3: Manual search through lines
            if (!pdtTime) {
                console.log('PDT regex 2 failed, trying method 3 (line search)...');
                const lines = text.split('\n');
                for (let i = 0; i < lines.length; i++) {
                    if (lines[i].includes('PDT')) {
                        console.log('Found PDT on line', i, ':', lines[i]);
                        // Check current line for time
                        let timeMatch = lines[i].match(/(\d{1,2}:\d{2}\s*[ap]m)/i);
                        if (timeMatch) {
                            console.log('Found time on same line:', timeMatch[1]);
                            pdtTime = parseTime(timeMatch[1]);
                            break;
                        }
                        // Check next line
                        if (i + 1 < lines.length) {
                            timeMatch = lines[i + 1].match(/(\d{1,2}:\d{2}\s*[ap]m)/i);
                            if (timeMatch) {
                                console.log('Found time on next line:', timeMatch[1]);
                                pdtTime = parseTime(timeMatch[1]);
                                break;
                            }
                        }
                        // Check line after next
                        if (i + 2 < lines.length) {
                            timeMatch = lines[i + 2].match(/(\d{1,2}:\d{2}\s*[ap]m)/i);
                            if (timeMatch) {
                                console.log('Found time on line after next:', timeMatch[1]);
                                pdtTime = parseTime(timeMatch[1]);
                                break;
                            }
                        }
                    }
                }
            }
            
            // NEW METHOD 4: If no PDT found, search for "Promised delivery time"
            if (!pdtTime) {
                console.log('No PDT found, searching for "Promised delivery time"...');
                
                // Method 4a: Look for "Promised delivery time" followed by date and time
                const promisedRegex1 = /Promised\s+delivery\s+time\s*\n?\s*[^\n]*?\s*(\d{1,2}:\d{2}\s*[ap]m)/i;
                const promisedMatch1 = text.match(promisedRegex1);
                
                if (promisedMatch1) {
                    console.log('Promised delivery time regex 1 matched:', promisedMatch1[1]);
                    pdtTime = parseTime(promisedMatch1[1]);
                }
                
                // Method 4b: If that fails, do a line-by-line search
                if (!pdtTime) {
                    console.log('Promised delivery time regex failed, trying line search...');
                    const lines = text.split('\n');
                    for (let i = 0; i < lines.length; i++) {
                        if (lines[i].includes('Promised delivery time')) {
                            console.log('Found "Promised delivery time" on line', i, ':', lines[i]);
                            
                            // Check current line for time
                            let timeMatch = lines[i].match(/(\d{1,2}:\d{2}\s*[ap]m)/i);
                            if (timeMatch) {
                                console.log('Found time on same line:', timeMatch[1]);
                                pdtTime = parseTime(timeMatch[1]);
                                break;
                            }
                            
                            // Check next line
                            if (i + 1 < lines.length) {
                                timeMatch = lines[i + 1].match(/(\d{1,2}:\d{2}\s*[ap]m)/i);
                                if (timeMatch) {
                                    console.log('Found time on next line:', timeMatch[1]);
                                    pdtTime = parseTime(timeMatch[1]);
                                    break;
                                }
                            }
                            
                            // Check line after next
                            if (i + 2 < lines.length) {
                                timeMatch = lines[i + 2].match(/(\d{1,2}:\d{2}\s*[ap]m)/i);
                                if (timeMatch) {
                                    console.log('Found time on line after next:', timeMatch[1]);
                                    pdtTime = parseTime(timeMatch[1]);
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            
            if (pdtTime) {
                console.log('PDT/Promised time successfully parsed:', formatTime(pdtTime));
                result.timestamps.N = combineDateTime(baseDate, pdtTime, baseTime);
                result.columns.N = result.timestamps.N ? formatTime(result.timestamps.N) : '';
                
                // Check if we should apply Local Shop AE logic
                const country = result.columns.C;
                const applyLocalShopAE = isLocalShopAE && country === 'AE';
                const minutesToAdd = applyLocalShopAE ? 30 : 10;
                
                // Add note about the Local Shop AE adjustment
                if (applyLocalShopAE) {
                    result.formulas.push(`N: PDT/Promised time = ${result.columns.N} (Local Shop AE: Using 30 minutes for calculations)`);
                } else if (isLocalShopAE && country !== 'AE') {
                    result.formulas.push(`N: PDT/Promised time = ${result.columns.N} (Checkbox checked but Country is ${country}, not AE: Using 10 minutes)`);
                } else {
                    result.formulas.push(`N: PDT/Promised time = ${result.columns.N} (Using 10 minutes for calculations)`);
                }
                
                console.log('N: PDT/Promised time final result:', result.columns.N, `(+${minutesToAdd}min)`);
            } else {
                console.log('No PDT or Promised delivery time found after all attempts');
                result.columns.N = 'N/A';
                result.formulas.push('N: PDT/Promised delivery time = N/A');
            }
            
            // O: food_is_ready_at
            const foodReadyMatch = text.match(/Food\s+is\s+ready\s+at\s*[:]?\s*(\d{1,2}:\d{2}\s*[apm]+)/i);
            if (foodReadyMatch) {
                console.log('Food ready match found:', foodReadyMatch[1]);
                const foodReadyTime = parseTime(foodReadyMatch[1]);
                if (foodReadyTime) {
                    result.timestamps.O = combineDateTime(baseDate, foodReadyTime, baseTime);
                    result.columns.O = result.timestamps.O ? formatTime(result.timestamps.O) : '';
                }
            } else {
                // Try alternative pattern without "at"
                const foodReadyAltMatch = text.match(/Food\s+ready\s*[:]?\s*(\d{1,2}:\d{2}\s*[apm]+)/i);
                if (foodReadyAltMatch) {
                    console.log('Food ready alternative match found:', foodReadyAltMatch[1]);
                    const foodReadyTime = parseTime(foodReadyAltMatch[1]);
                    if (foodReadyTime) {
                        result.timestamps.O = combineDateTime(baseDate, foodReadyTime, baseTime);
                        result.columns.O = result.timestamps.O ? formatTime(result.timestamps.O) : '';
                    }
                }
            }
            result.formulas.push('O: food_is_ready_at = ' + result.columns.O);
            console.log('O: food_is_ready_at =', result.columns.O);
            
            // P: cancellation_time - UTC-BASED WITH COUNTRY OFFSETS
            const nowUTC = new Date(); // This is browser local, but we'll convert
            
            const countryUTCOffsets = {
                'AE': 4,  // UTC+4
                'EG': 2,  // UTC+2
                'KW': 3,  // UTC+3
                'QA': 3,  // UTC+3
                'IQ': 3,  // UTC+3
                'SA': 3,  // UTC+3
                'JO': 2,  // UTC+2 (Note: Jordan is UTC+2, but UTC+3 in summer)
                'BH': 3,  // UTC+3
                'OM': 4   // UTC+4
            };
            
            const countryCode = result.columns.C;
            const targetOffset = countryUTCOffsets[countryCode] || 4; // Default to UAE (UTC+4)
            
            // Convert browser local time to UTC
            const utcTime = nowUTC.getTime() + (nowUTC.getTimezoneOffset() * 60000);
            // Apply country offset to get country local time
            const countryTime = new Date(utcTime + (3600000 * targetOffset));
            
            result.columns.P = formatTime(countryTime);
            result.timestamps.P = countryTime; // Store as timestamp for use in W and T calculations
            result.formulas.push(`P: cancellation_time = UTC + ${targetOffset} hours (Country: ${countryCode}) = ${result.columns.P}`);
            console.log(`P: cancellation_time = ${result.columns.P} (UTC+${targetOffset} for country ${countryCode})`);
            
            // Q: old_cpt
            const oldCptMatch = text.match(/Pickup\s*[-]\s*Committed\s*[:]?\s*(\d{1,2}:\d{2}[apm]+)/i);
            if (oldCptMatch) {
                console.log('Old CPT match found:', oldCptMatch[1]);
                const oldCptTime = parseTime(oldCptMatch[1]);
                if (oldCptTime) {
                    result.timestamps.Q = combineDateTime(baseDate, oldCptTime, baseTime);
                    result.columns.Q = result.timestamps.Q ? formatTime(result.timestamps.Q) : '';
                }
            }
            result.formulas.push('Q: old_cpt = ' + result.columns.Q);
            console.log('Q: old_cpt =', result.columns.Q);
            
            // R: cpt =IF(J2>Q2,J2,Q2)
            if (result.timestamps.J && result.timestamps.Q) {
                result.timestamps.R = result.timestamps.J > result.timestamps.Q ? result.timestamps.J : result.timestamps.Q;
                result.columns.R = formatTime(result.timestamps.R);
            } else if (result.timestamps.J) {
                result.timestamps.R = result.timestamps.J;
                result.columns.R = formatTime(result.timestamps.J);
            } else if (result.timestamps.Q) {
                result.timestamps.R = result.timestamps.Q;
                result.columns.R = formatTime(result.timestamps.Q);
            }
            result.formulas.push('R: cpt = MAX(J, Q) = ' + result.columns.R);
            
            // S: is_wfa
            result.columns.S = text.includes("Scheduled") ? "TRUE" : "FALSE";
            result.formulas.push('S: is_wfa (Scheduled) = ' + result.columns.S);
            
            // T: Before PDT Check - MODIFIED VERSION (uses cancellation time as fallback)
            console.log('=== Calculating T: Before PDT Check (Modified) ===');
            result.columns.T = "";
            
            // Get dropoff time for T check (M if available, otherwise P as fallback)
            const dropoffTimeForT = result.timestamps.M || result.timestamps.P;
            
            if (dropoffTimeForT && result.timestamps.N) {
                // MODIFIED: Use 30 minutes if Local Shop AE checkbox is checked AND country is AE, otherwise 10 minutes
                const country = result.columns.C;
                const applyLocalShopAE = isLocalShopAE && country === 'AE';
                const minutesToAdd = applyLocalShopAE ? 30 : 10;
                const pdtPlusMinutes = new Date(result.timestamps.N.getTime() + (minutesToAdd * 60 * 1000));
                console.log(`T Check: Dropoff time = ${formatTime(dropoffTimeForT)}, PDT = ${formatTime(result.timestamps.N)}, PDT+${minutesToAdd}min = ${formatTime(pdtPlusMinutes)}`);
                
                if (dropoffTimeForT <= pdtPlusMinutes) {
                    result.columns.T = "Before PDT";
                    console.log(`T: Before PDT condition met (PDT + ${minutesToAdd}min)`);
                    
                    // Add note if using cancellation time
                    if (!result.timestamps.M && result.timestamps.P) {
                        result.formulas.push('T Note: Using cancellation_time for Before PDT check (Near Dropoff not available)');
                    }
                    
                    // Add note about buffer
                    if (applyLocalShopAE) {
                        result.formulas.push(`T: Using 30-minute buffer (Local Shop AE + Country AE)`);
                    } else if (isLocalShopAE && country !== 'AE') {
                        result.formulas.push(`T: Checkbox checked but Country is ${country}, not AE - Using 10-minute buffer`);
                    }
                } else {
                    console.log(`T: Dropoff time is after PDT+${minutesToAdd}min`);
                }
            } else {
                console.log(`T: Cannot check - Dropoff time: ${dropoffTimeForT ? 'Available' : 'Missing'}, PDT: ${result.timestamps.N ? 'Available' : 'Missing'}`);
            }
            result.formulas.push('T: Before PDT Check = ' + result.columns.T);
            
            // Helper: Convert datetime difference to seconds
            function datetimeToSeconds(date1, date2) {
                if (!date1 || !date2) return 0;
                return (date2 - date1) / 1000;
            }
            
            // U: System Late Duration - UPDATED FORMULA: IF(H<>"", (H-F)*86400, IF(P<>"", (P-F)*86400, 0))
            let U_seconds = 0;
            if (result.timestamps.H && result.timestamps.F) {
                // Use H-F if H exists
                U_seconds = datetimeToSeconds(result.timestamps.F, result.timestamps.H);
            } else if (result.columns.P && result.timestamps.F) {
                // Fallback to P-F if H doesn't exist but P does
                const P_time = parseTime(result.columns.P);
                if (P_time) {
                    U_seconds = datetimeToSeconds(result.timestamps.F, P_time);
                }
            }
            result.columns.U = Math.round(U_seconds) + "s";
            result.formulas.push('U: System Late Duration = IF(H<>"", (H-F)*86400, IF(P<>"", (P-F)*86400, 0)) = ' + result.columns.U);
            
            // V: Vendor Late Duration
            let V_seconds = 0;
            if (result.timestamps.K && result.timestamps.R) {
                V_seconds = datetimeToSeconds(result.timestamps.R, result.timestamps.K);
            }
            result.columns.V = Math.round(V_seconds) + "s";
            result.formulas.push('V: Vendor Late Duration = ' + result.columns.V);
            
            // W: Rider Delay After Pickup - MODIFIED VERSION
            console.log('=== Calculating W: Rider Delay After Pickup (Modified) ===');
            let W_seconds = 0;
            
            // Get the dropoff time (use near dropoff first, cancellation time as fallback)
            let dropoffTime = result.timestamps.M; // Near Dropoff
            
            // If near dropoff is not available, use cancellation time
            if (!dropoffTime && result.columns.P && result.columns.P !== 'N/A') {
                console.log('Near dropoff not available, using cancellation time as dropoff time');
                dropoffTime = result.timestamps.P;
                
                // Add note about using cancellation time
                result.formulas.push('W Note: Using cancellation_time as dropoff time (Near Dropoff not available)');
            }
            
            // Calculate delay if we have both dropoff time and estimated dropoff
            if (dropoffTime && result.timestamps.L && dropoffTime > result.timestamps.L) {
                W_seconds = datetimeToSeconds(result.timestamps.L, dropoffTime);
                console.log(`W calculated: Dropoff time (${formatTime(dropoffTime)}) - Est. Dropoff (${formatTime(result.timestamps.L)}) = ${W_seconds}s`);
                
                // Add specific note if using cancellation time
                if (!result.timestamps.M && result.timestamps.P) {
                    result.formulas.push(`W: Using cancellation_time (${result.columns.P}) instead of Near Dropoff (N/A)`);
                }
            } else if (dropoffTime && result.timestamps.L) {
                console.log(`No delay: Dropoff time (${formatTime(dropoffTime)}) <= Est. Dropoff (${formatTime(result.timestamps.L)})`);
            } else {
                console.log(`Cannot calculate W: Dropoff time or Est. Dropoff missing`);
            }
            
            result.columns.W = Math.round(W_seconds) + "s";
            result.formulas.push('W: Rider Delay After Pickup = (Dropoff Time - Est. Dropoff) = ' + result.columns.W);
            console.log('W: Rider Delay After Pickup final result =', result.columns.W);
            
            // X: Rider Delay Before Pickup - UPDATED FORMULA: =IF(AND(I<>"" , I>J), (I-J)*86400, IF(I = "",(P-H) *86400,0))
            let X_seconds = 0;
            // Primary condition: IF(AND(I<>"" , I>J), (I-J)*86400
            if (result.timestamps.I && result.timestamps.J && result.timestamps.I > result.timestamps.J) {
                X_seconds = datetimeToSeconds(result.timestamps.J, result.timestamps.I);
            }
            // Secondary condition: IF(I = "",(P-H) *86400,0)
            else if (!result.columns.I && result.columns.P && result.timestamps.H) {
                // If I is empty, calculate (P-H)
                const P_time = parseTime(result.columns.P);
                if (P_time) {
                    X_seconds = datetimeToSeconds(result.timestamps.H, P_time);
                    if (X_seconds < 0) {
                        X_seconds = 0; // Ensure non-negative
                    }
                }
            }
            result.columns.X = Math.round(X_seconds) + "s";
            result.formulas.push('X: Rider Delay Before Pickup = IF(AND(I<>"" , I>J), (I-J)*86400, IF(I = "",(P-H)*86400,0)) = ' + result.columns.X);
            
            // Y: Vendor Late (Near Pickup vs Picked Up)
            let Y_seconds = 0;
            if (result.columns.S === "FALSE" && result.timestamps.I && result.timestamps.J && result.timestamps.K && result.timestamps.R) {
                if (result.timestamps.I > result.timestamps.J && result.timestamps.K > result.timestamps.R) {
                    if (result.timestamps.K && result.timestamps.I) {
                        Y_seconds = datetimeToSeconds(result.timestamps.I, result.timestamps.K);
                    }
                }
            }
            result.columns.Y = Math.round(Y_seconds) + "s";
            result.formulas.push('Y: Vendor Late (Near Pickup vs Picked Up) = ' + result.columns.Y);
            
            // Z: Late Owner - EXACT GOOGLE SHEETS FORMULA LOGIC
            let Z_result = "";
            
            console.log("=== CALCULATING Z RESULT ===");
            console.log("T (Before PDT):", result.columns.T);
            console.log("M (Near Dropoff):", result.columns.M);
            console.log("N (PDT):", result.columns.N);
            console.log("I (Near Pickup):", result.columns.I);
            console.log("J (Est Pickup):", result.columns.J);
            console.log("K (Picked Up):", result.columns.K);
            console.log("R (CPT):", result.columns.R);
            console.log("S (Scheduled):", result.columns.S);
            console.log("U (System Late):", U_seconds);
            console.log("V (Vendor Late):", V_seconds);
            console.log("W (Rider After Pickup):", W_seconds);
            console.log("X (Rider Before Pickup):", X_seconds);
            console.log("Y (Vendor Near Pickup):", Y_seconds);
            
            // Check if we should apply Local Shop AE logic
            const country = result.columns.C;
            const applyLocalShopAE = isLocalShopAE && country === 'AE';
            
            // Convert to milliseconds based on checkbox AND country
            const minutesToAdd = applyLocalShopAE ? 30 : 10;
            const pdtBufferMs = minutesToAdd * 60 * 1000;
            
            console.log(`Using ${minutesToAdd} minutes buffer for PDT (Local Shop AE: ${isLocalShopAE}, Country: ${country}, Apply: ${applyLocalShopAE})`);
            
            // Check if dropoff > N + minutes (10 or 30 based on checkbox AND country)
            // Use dropoffTime (which could be M or P) instead of just M
            const dropoffAfterPdtPlusBuffer = dropoffTime && result.timestamps.N && 
                                       (dropoffTime.getTime() > (result.timestamps.N.getTime() + pdtBufferMs));
            
            console.log(`Dropoff > N + ${minutesToAdd}min?`, dropoffAfterPdtPlusBuffer);
            
            // Condition 1: Before PDT
            if (result.columns.T === "Before PDT") {
                Z_result = "Before PDT";
                console.log("Condition 1: Before PDT");
            }
            // Condition 2: Scheduled and vendor late
            else if (dropoffAfterPdtPlusBuffer && result.columns.S === "TRUE") {
                const foodOrCancelTime = result.timestamps.O || (result.columns.P ? new Date(baseDate.getTime() + parseTime(result.columns.P).getTime()) : null);
                if (foodOrCancelTime && foodOrCancelTime > result.timestamps.N) {
                    Z_result = "Vendor Late";
                    console.log("Condition 2: Scheduled and vendor late");
                }
            }
            // Condition 3: Vendor late (non-scheduled, I <= J, K > R, V > U, V > (X+W))
            else if (dropoffAfterPdtPlusBuffer && result.columns.S !== "TRUE" && 
                    result.timestamps.I && result.timestamps.J && result.timestamps.K && result.timestamps.R &&
                    result.timestamps.I <= result.timestamps.J && result.timestamps.K > result.timestamps.R &&
                    V_seconds > U_seconds && V_seconds > (X_seconds + W_seconds)) {
                Z_result = "Vendor Late";
                console.log("Condition 3: Vendor late (non-scheduled)");
            }
            // Condition 4: Rider late ((X+W) > U, (X+W) > V, (X+W) > Y)
            else if (dropoffAfterPdtPlusBuffer && (X_seconds + W_seconds) > U_seconds && 
                    (X_seconds + W_seconds) > V_seconds && (X_seconds + W_seconds) > Y_seconds) {
                Z_result = "Rider Late";
                console.log("Condition 4: Rider late");
            }
            // Condition 5: Long dispatch (U >= (X+W), U > V, U > Y)
            else if (dropoffAfterPdtPlusBuffer && U_seconds >= (X_seconds + W_seconds) && 
                    U_seconds > V_seconds && U_seconds > Y_seconds) {
                Z_result = "Long Dispatch";
                console.log("Condition 5: Long dispatch");
            }
            // Condition 6: Vendor late (I > J, K > R, non-scheduled)
            else if (dropoffAfterPdtPlusBuffer && result.columns.S !== "TRUE" && 
                    result.timestamps.I && result.timestamps.J && result.timestamps.K && result.timestamps.R &&
                    result.timestamps.I > result.timestamps.J && result.timestamps.K > result.timestamps.R &&
                    ((Y_seconds > U_seconds && Y_seconds > (X_seconds + W_seconds)) || 
                     (V_seconds > U_seconds && V_seconds > (X_seconds + W_seconds)))) {
                Z_result = "Vendor Late";
                console.log("Condition 6: Vendor late (I > J, K > R)");
            }
            // Default
            else {
                Z_result = "";
                console.log("Default: No condition met");
            }
            
            // If still empty, set to "On Time"
            if (!Z_result) {
                Z_result = "On Time";
            }
            
            result.columns.Z = Z_result;
            
            // Add note about buffer used
            if (applyLocalShopAE) {
                result.formulas.push(`Z: Late Owner = ${Z_result} (using 30-minute buffer - Local Shop AE + Country AE)`);
            } else if (isLocalShopAE && country !== 'AE') {
                result.formulas.push(`Z: Late Owner = ${Z_result} (checkbox checked but Country is ${country}, not AE - using 10-minute buffer)`);
            } else {
                result.formulas.push(`Z: Late Owner = ${Z_result} (using 10-minute buffer)`);
            }
            
            // Store whether Local Shop AE was applied
            result.applyLocalShopAE = applyLocalShopAE;
            result.isLocalShopAEChecked = isLocalShopAE;
            result.country = country;
            
            return result;
        }
        
        function updateResultDisplay(result) {
            const finalResult = document.getElementById('finalResult');
            const columnsGrid = document.getElementById('columnsGrid');
            const formulaSteps = document.getElementById('formulaSteps');
            
            // Set final result with appropriate styling
            finalResult.textContent = result.columns.Z || 'No Result';
            finalResult.className = 'final-result ';
            
            if (result.columns.Z === "Before PDT") {
                finalResult.classList.add('result-before-pdt');
            } else if (result.columns.Z.includes("Vendor Late")) {
                finalResult.classList.add('result-vendor-late');
            } else if (result.columns.Z.includes("Rider Late")) {
                finalResult.classList.add('result-rider-late');
            } else if (result.columns.Z.includes("Long Dispatch")) {
                finalResult.classList.add('result-long-dispatch');
            } else if (result.columns.Z !== "Before PDT") {
                // Get the numeric values for U, X, V (remove 's' and parse)
                const U_value = parseFloat(result.columns.U.replace('s', '') || 0);
                const X_value = parseFloat(result.columns.X.replace('s', '') || 0);
                const V_value = parseFloat(result.columns.V.replace('s', '') || 0);
                
                // Find the maximum value
                const maxValue = Math.max(U_value, X_value, V_value);
                
                // Determine which one is the max (with priority U > X > V)
                if (U_value === maxValue) {
                    finalResult.classList.add('result-long-dispatch'); // U corresponds to Long Dispatch
                    if (result.columns.Z !== "Long Dispatch") {
                        finalResult.textContent = "Long Dispatch";
                        result.columns.Z = "Long Dispatch"; // Update the result
                    }
                } else if (X_value === maxValue) {
                    finalResult.classList.add('result-rider-late'); // X corresponds to Rider Late
                    if (result.columns.Z !== "Rider Late") {
                        finalResult.textContent = "Rider Late";
                        result.columns.Z = "Rider Late"; // Update the result
                    }
                } else if (V_value === maxValue) {
                    finalResult.classList.add('result-vendor-late'); // V corresponds to Vendor Late
                    if (result.columns.Z !== "Vendor Late") {
                        finalResult.textContent = "Vendor Late";
                        result.columns.Z = "Vendor Late"; // Update the result
                    }
                } else {
                    // Fallback if no max found (shouldn't happen)
                    finalResult.classList.add('result-on-time');
                }
            } else {
                finalResult.classList.add('result-on-time');
            }
            
            // Create columns grid - MODIFIED: Only show Basic Information (Calculations section removed)
            let columnsHTML = '';
            
            // Get buffer information
            const isLocalShopAE = document.getElementById('localShopAE').checked;
            const country = result.columns.C;
            const applyLocalShopAE = isLocalShopAE && country === 'AE';
            
            // Group columns logically - ONLY SHOW Basic Information (Calculations hidden)
            const columnGroups = [
                {
                    title: 'Basic Information',
                    columns: [
                        { label: 'B: Order ID', value: result.columns.B },
                        { label: 'C: Country', value: result.columns.C },
                        { label: 'D: Order Date', value: result.columns.D },
                        { label: 'E: Ordered at', value: result.columns.E, isTime: true }
                    ]
                }
            ];
            
            columnGroups.forEach(group => {
                let groupHTML = `<div class="column-group">
                    <h3>${group.title}</h3>`;
                
                group.columns.forEach(col => {
                    let valueClass = '';
                    let noteHTML = '';
                    if (col.isTime) valueClass = 'time-value';
                    if (col.isSeconds) valueClass = 'seconds-value';
                    if (col.isBoolean) valueClass = col.value === 'TRUE' ? 'boolean-true' : 'boolean-false';
                    if (col.note) noteHTML = `<div class="column-note">${col.note}</div>`;
                    
                    groupHTML += `
                        <div class="column-item">
                            <div class="column-label">${col.label}</div>
                            <div class="column-value ${valueClass}">${col.value || 'N/A'}</div>
                            ${noteHTML}
                        </div>
                    `;
                });
                
                groupHTML += '</div>';
                columnsHTML += groupHTML;
            });
            
            columnsGrid.innerHTML = columnsHTML;
            
            // Show formula steps (but section is hidden)
            let formulaHTML = '';
            if (result.formulas && result.formulas.length > 0) {
                result.formulas.forEach(formula => {
                    formulaHTML += `<div class="formula-step">${formula}</div>`;
                });
            }
            formulaSteps.innerHTML = formulaHTML;
        }
        
        // Helper function to get UTC offset for a country
        function getUTCOffsetForCountry(countryCode) {
            const countryUTCOffsets = {
                'AE': 4,
                'EG': 2,
                'KW': 3,
                'QA': 3,
                'IQ': 3,
                'SA': 3,
                'JO': 2,
                'BH': 3,
                'OM': 4
            };
            return countryUTCOffsets[countryCode] || 4;
        }
        
        function updateDebugInfo(result) {
            const debugInfo = document.getElementById('debugInfo');
            let debugHTML = 'EXTRACTED DATA:\n\n';
            
            debugHTML += 'Columns B-Z:\n';
            Object.entries(result.columns).forEach(([key, value]) => {
                debugHTML += `${key}: ${value}\n`;
            });
            
            debugHTML += '\nTimestamps (Date Objects):\n';
            Object.entries(result.timestamps).forEach(([key, value]) => {
                debugHTML += `${key}: ${value ? value.toString() : 'null'}\n`;
            });
            
            // Add current time info
            const now = new Date();
            debugHTML += '\nCurrent Time Info:\n';
            debugHTML += `Browser Local: ${now.toString()}\n`;
            debugHTML += `Browser UTC Offset: ${-now.getTimezoneOffset()/60} hours\n`;
            debugHTML += `Country: ${result.columns.C}\n`;
            debugHTML += `Country UTC Offset: UTC+${getUTCOffsetForCountry(result.columns.C)}\n`;
            
            // Add checkbox and country info
            const isLocalShopAE = document.getElementById('localShopAE').checked;
            const country = result.columns.C;
            const applyLocalShopAE = isLocalShopAE && country === 'AE';
            
            debugHTML += `\nLocal Shop AE Checkbox: ${isLocalShopAE ? 'Checked' : 'Not Checked'}\n`;
            debugHTML += `Country: ${country}\n`;
            debugHTML += `Apply Local Shop AE buffer: ${applyLocalShopAE ? 'Yes (30 min) - Checkbox checked AND Country is AE' : 'No (10 min)'}\n`;
            if (isLocalShopAE && country !== 'AE') {
                debugHTML += `Note: Checkbox checked but Country is ${country}, not AE - Using 10-minute buffer\n`;
            }
            
            // Add W calculation details - FIXED: Don't use formatTime function
            debugHTML += '\nW & T Calculation Details:\n';
            debugHTML += `Near Dropoff (M): ${result.columns.M}\n`;
            debugHTML += `Using cancellation time for W: ${!result.columns.M && result.columns.P ? 'Yes' : 'No'}\n`;
            debugHTML += `Using cancellation time for T: ${!result.columns.M && result.columns.P && result.columns.T === "Before PDT" ? 'Yes' : 'No'}\n`;
            
            // Helper function to format time for debug display
            function formatDebugTime(date) {
                if (!date) return 'N/A';
                return date.toLocaleTimeString('en-US', { hour12: true, hour: '2-digit', minute: '2-digit', second: '2-digit' });
            }
            
            debugHTML += `Final dropoff time used for calculations: ${result.timestamps.M ? formatDebugTime(result.timestamps.M) : (result.timestamps.P ? formatDebugTime(result.timestamps.P) : 'N/A')}\n`;
            debugHTML += `PDT buffer used: ${applyLocalShopAE ? '30 minutes (Local Shop AE + Country AE)' : '10 minutes'}\n`;
            
            debugInfo.textContent = debugHTML;
        }
        
        // Remove the auto-load example data
        window.addEventListener('load', function() {
            // Empty textarea
            document.getElementById('orderDetails').value = '';
        });
    </script>
</body>
</html>
