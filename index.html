<!DOCTYPE html>
<html lang="en">
<head> 
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Order Analysis Tool - Complete with Picked Up by Another Rider</title>
    <style>
        /* Modern CSS Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #411517 0%, #2a0e10 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 24px;
            box-shadow: 0 25px 70px rgba(0,0,0,0.4);
            overflow: hidden;
            position: relative;
        }
        
        .container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 6px;
            background: linear-gradient(90deg, #ff5900 0%, #ff8c42 100%);
            z-index: 2;
        }
        
        /* Header Section */
        .header {
            background: linear-gradient(135deg, #ff5900 0%, #ff8c42 100%);
            color: white;
            padding: 40px 30px 30px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }
        
        .header::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: rgba(255,255,255,0.2);
        }
        
        .header-content {
            position: relative;
            z-index: 1;
        }
        
        .header h1 {
            font-size: 2.8rem;
            font-weight: 800;
            margin-bottom: 8px;
            letter-spacing: -0.5px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .header p {
            font-size: 1.1rem;
            opacity: 0.95;
            font-weight: 400;
            margin-top: 5px;
        }
        
        .header-icon {
            font-size: 3rem;
            margin-bottom: 15px;
            display: block;
        }
        
        /* Main Content */
        .content {
            padding: 30px;
            background: linear-gradient(to bottom, #fafafa 0%, #ffffff 100%);
        }
        
        /* Input Section */
        .input-section {
            margin-bottom: 30px;
        }
        
        .input-label {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            font-size: 1.3rem;
            font-weight: 600;
            color: #411517;
            padding-left: 5px;
        }
        
        .input-label svg {
            width: 24px;
            height: 24px;
            fill: #ff5900;
        }
        
        .input-wrapper {
            position: relative;
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 8px 30px rgba(65, 21, 23, 0.12);
            border: 2px solid #e8e8e8;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .input-wrapper:hover {
            border-color: #ff8c42;
            box-shadow: 0 12px 40px rgba(255, 89, 0, 0.15);
        }
        
        .input-wrapper:focus-within {
            border-color: #ff5900;
            box-shadow: 0 12px 40px rgba(255, 89, 0, 0.2);
        }
        
        textarea {
            width: 100%;
            height: 280px;
            padding: 25px;
            border: none;
            background: white;
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            font-size: 15px;
            line-height: 1.6;
            resize: vertical;
            color: #333;
        }
        
        textarea:focus {
            outline: none;
        }
        
        textarea::placeholder {
            color: #888;
            font-size: 15px;
            font-weight: 400;
        }
        
        /* Checkbox Styling */
        .checkbox-container {
            margin-top: 20px;
            padding: 15px;
            background: rgba(255, 89, 0, 0.05);
            border-radius: 12px;
            border: 1px solid rgba(255, 89, 0, 0.2);
            display: flex;
            align-items: center;
            gap: 12px;
            transition: all 0.3s ease;
        }
        
        .checkbox-container:hover {
            background: rgba(255, 89, 0, 0.1);
            border-color: rgba(255, 89, 0, 0.3);
        }
        
        .checkbox-container input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
            accent-color: #ff5900;
        }
        
        .checkbox-container label {
            display: inline;
            margin: 0;
            font-weight: 500;
            cursor: pointer;
            color: #411517;
            font-size: 0.95rem;
            flex: 1;
        }
        
        /* Button Section */
        .button-section {
            text-align: center;
            margin: 40px 0 30px;
            padding: 0 20px;
        }
        
        .analyze-btn {
            background: linear-gradient(135deg, #411517 0%, #5a1f22 100%);
            color: white;
            border: none;
            padding: 22px 60px;
            font-size: 1.2rem;
            font-weight: 600;
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 15px 35px rgba(65, 21, 23, 0.3);
            display: inline-flex;
            align-items: center;
            gap: 12px;
            letter-spacing: 0.5px;
            position: relative;
            overflow: hidden;
        }
        
        .analyze-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            transition: 0.6s;
        }
        
        .analyze-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 20px 40px rgba(65, 21, 23, 0.4);
        }
        
        .analyze-btn:hover::before {
            left: 100%;
        }
        
        .analyze-btn:active {
            transform: translateY(-1px);
        }
        
        .analyze-btn:disabled {
            opacity: 0.7;
            cursor: not-allowed;
            transform: none;
        }
        
        .btn-icon {
            font-size: 1.4rem;
        }
        
        /* Loading State */
        .loading {
            text-align: center;
            margin: 20px 0;
            padding: 20px;
            display: none;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255, 89, 0, 0.1);
            border-top-color: #ff5900;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Error Message */
        .error {
            background: linear-gradient(135deg, #fed7d7 0%, #feb2b2 100%);
            color: #9b2c2c;
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0;
            border: 1px solid #fc8181;
            display: none;
            align-items: center;
            gap: 12px;
        }
        
        /* Result Container */
        .result-container {
            display: none;
            animation: slideUp 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* Result Header */
        .result-header {
            background: linear-gradient(135deg, #f8f9fa 0%, #f0f2f4 100%);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            border: 1px solid #e8e9ea;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 20px;
        }
        
        .result-title h2 {
            font-size: 1.8rem;
            font-weight: 700;
            color: #411517;
            margin-bottom: 5px;
        }
        
        .result-title p {
            color: #666;
            font-size: 0.95rem;
            display: none; /* Hide "Column Z equivalent calculation" */
        }
        
        .final-result {
            padding: 20px 40px;
            border-radius: 16px;
            font-size: 1.8rem;
            font-weight: 800;
            text-align: center;
            min-width: 220px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
        }
        
        .final-result:hover {
            transform: scale(1.03);
        }
        
        .result-before-pdt {
            background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
            color: white;
        }
        
        .result-vendor-late {
            background: linear-gradient(135deg, #ed8936 0%, #dd6b20 100%);
            color: white;
        }
        
        .result-rider-late {
            background: linear-gradient(135deg, #f56565 0%, #e53e3e 100%);
            color: white;
        }
        
        .result-long-dispatch {
            background: linear-gradient(135deg, #4299e1 0%, #3182ce 100%);
            color: white;
        }
        
        .result-on-time {
            background: linear-gradient(135deg, #a0aec0 0%, #718096 100%);
            color: white;
        }
        
        .result-picked-up-another-rider {
            background: linear-gradient(135deg, #9f7aea 0%, #805ad5 100%);
            color: white;
        }
        
        /* Basic Information - Horizontal Layout */
        .basic-info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .info-card {
            background: white;
            border-radius: 16px;
            padding: 25px;
            border: 1px solid #e8e9ea;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.05);
        }
        
        .info-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
            border-color: #ff8c42;
        }
        
        .info-label {
            font-size: 0.9rem;
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .info-label::before {
            content: '';
            width: 6px;
            height: 6px;
            background: #ff5900;
            border-radius: 50%;
            display: inline-block;
        }
        
        .info-value {
            font-size: 1.4rem;
            font-weight: 700;
            color: #411517;
            margin-bottom: 5px;
        }
        
        .info-time {
            color: #ff5900;
            font-family: 'SF Mono', monospace;
            font-weight: 600;
        }
        
        .info-seconds {
            color: #4299e1;
            font-family: 'SF Mono', monospace;
            font-weight: 600;
        }
        
        .info-boolean {
            display: inline-block;
            padding: 6px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 600;
            margin-top: 5px;
        }
        
        .info-boolean-true {
            background: rgba(72, 187, 120, 0.1);
            color: #2f855a;
        }
        
        .info-boolean-false {
            background: rgba(245, 101, 101, 0.1);
            color: #c53030;
        }
        
        .info-note {
            font-size: 0.8rem;
            color: #718096;
            margin-top: 5px;
            font-style: italic;
        }
        
        /* Hidden Sections */
        .hidden-section {
            display: none !important;
        }
        
        /* Responsive Design */
        @media (max-width: 1024px) {
            .basic-info-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        @media (max-width: 768px) {
            .container {
                border-radius: 16px;
            }
            
            .header {
                padding: 30px 20px;
            }
            
            .header h1 {
                font-size: 2.2rem;
            }
            
            .content {
                padding: 20px;
            }
            
            .result-header {
                flex-direction: column;
                text-align: center;
                padding: 25px;
            }
            
            .final-result {
                min-width: 100%;
                padding: 15px 20px;
            }
            
            .basic-info-grid {
                grid-template-columns: 1fr;
            }
            
            .analyze-btn {
                width: 100%;
                justify-content: center;
                padding: 20px;
            }
            
            textarea {
                height: 240px;
                padding: 20px;
            }
        }
        
        @media (max-width: 480px) {
            body {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 1.8rem;
            }
            
            .input-label {
                font-size: 1.1rem;
            }
            
            .info-card {
                padding: 20px;
            }
            
            .info-value {
                font-size: 1.2rem;
            }
        }
        
        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 10px;
        }
        
        ::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 5px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #ff5900 0%, #411517 100%);
            border-radius: 5px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, #ff8c42 0%, #5a1f22 100%);
        }
        
        /* Selection */
        ::selection {
            background: rgba(255, 89, 0, 0.3);
            color: #411517;
        }
        
        /* Focus */
        *:focus {
            outline: 2px solid #ff5900;
            outline-offset: 2px;
        }
        
        /* Animation for card entrance */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .info-card {
            animation: fadeIn 0.5s ease forwards;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="header-content">
                <div class="header-icon">üìä</div>
                <h1>Late Owner Analysis Tool</h1>
                <p>Created by talabat SSC Analytics Team</p>
            </div>
        </div>
        
        <div class="content">
            <!-- Input Section -->
            <div class="input-section">
                <div class="input-label">
                    <svg viewBox="0 0 24 24">
                        <path d="M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-4.86 8.86l-3 3.87L9 13.14 6 17h12l-3.86-5.14z"/>
                    </svg>
                    Paste Order Details
                </div>
                <div class="input-wrapper">
                    <textarea 
                        id="orderDetails" 
                        placeholder="Make sure to expand the rider delivery to get the timeline events&#10;then press CTRL + A >> Copy >> Paste"
                        spellcheck="false">
                    </textarea>
                </div>
                
                <!-- Checkbox for Local Shop AE -->
                <div class="checkbox-container">
                    <input type="checkbox" id="localShopAE">
                    <label for="localShopAE">Local Shop AE</label>
                </div>
            </div>
            
            <!-- Error Message -->
            <div class="error" id="errorMessage"></div>
            
            <!-- Loading State -->
            <div class="loading" id="loading">
                <div class="spinner"></div>
                <p>Analyzing order details...</p>
            </div>
            
            <!-- Button Section -->
            <div class="button-section">
                <button class="analyze-btn" id="analyzeBtn" onclick="analyzeOrder()">
                    <span class="btn-icon">üöÄ</span>
                    <span>Analyze Order</span>
                </button>
            </div>
            
            <!-- Results Container -->
            <div class="result-container" id="resultContainer">
                <!-- Result Header -->
                <div class="result-header">
                    <div class="result-title">
                        <h2>Analysis Result</h2>
                        <p>Column Z equivalent calculation</p>
                    </div>
                    <div class="final-result" id="finalResult"></div>
                </div>
                
                <!-- Basic Information - Horizontal Cards -->
                <div class="basic-info-grid" id="basicInfoGrid">
                    <!-- Cards will be populated here -->
                </div>
            </div>
        </div>
    </div>

    <script>
        let debugData = {};
        
        function analyzeOrder() {
            const details = document.getElementById('orderDetails').value.trim();
            const errorDiv = document.getElementById('errorMessage');
            const loadingDiv = document.getElementById('loading');
            const resultContainer = document.getElementById('resultContainer');
            const analyzeBtn = document.getElementById('analyzeBtn');
            
            // Get checkbox state
            const isLocalShopAE = document.getElementById('localShopAE').checked;
            
            // Reset UI
            errorDiv.style.display = 'none';
            resultContainer.style.display = 'none';
            
            // Validate input
            if (!details) {
                errorDiv.textContent = 'Please paste order details in the text area';
                errorDiv.style.display = 'flex';
                return;
            }
            
            // Show loading
            loadingDiv.style.display = 'block';
            analyzeBtn.disabled = true;
            analyzeBtn.innerHTML = '<span class="btn-icon">‚è≥</span><span>Processing...</span>';
            
            // Process the details
            setTimeout(() => {
                try {
                    const result = processOrderDetails(details, isLocalShopAE);
                    debugData = result;
                    
                    // Check for incomplete order data
                    if (!result.columns.F || result.columns.F === '' || result.columns.F === 'N/A') {
                        errorDiv.textContent = 'Incomplete order data - Could not find Queued At time';
                        errorDiv.style.display = 'flex';
                        loadingDiv.style.display = 'none';
                        analyzeBtn.disabled = false;
                        analyzeBtn.innerHTML = '<span class="btn-icon">üöÄ</span><span>Analyze Order</span>';
                        return;
                    }
                    
                    // Calculate picked up by another rider (still calculated but not displayed)
                    const pickedUpResult = calculatePickedUpByAnotherRider(details);
                    
                    // Update result display with original Z result
                    updateResultDisplay(result);
                    
                    // Check if we need to do Long Dispatch comparison (still calculated but not displayed)
                    const finalZResult = checkLongDispatchComparison(result, pickedUpResult);
                    
                    // Update final result if changed by comparison
                    if (finalZResult !== result.columns.Z) {
                        updateFinalResult(finalZResult);
                        result.columns.Z = finalZResult; // Update the result object
                    }
                    
                    // Show result
                    resultContainer.style.display = 'block';
                    
                } catch (error) {
                    errorDiv.textContent = 'Error processing details: ' + error.message;
                    errorDiv.style.display = 'flex';
                    console.error('Processing error:', error);
                } finally {
                    // Hide loading
                    loadingDiv.style.display = 'none';
                    analyzeBtn.disabled = false;
                    analyzeBtn.innerHTML = '<span class="btn-icon">üöÄ</span><span>Analyze Order</span>';
                }
            }, 500);
        }
        
        // Function: Calculate picked up by another rider (kept for calculations)
        function calculatePickedUpByAnotherRider(text) {
            console.log("=== Calculating Picked up by another rider ===");
            
            const result = {
                totalSeconds: 0,
                patterns: [],
                breakdown: []
            };
            
            // Parse time string to minutes since midnight
            function parseTimeToMinutes(timeStr) {
                if (!timeStr) return null;
                
                const cleaned = timeStr.trim().toLowerCase().replace(/\s+(am|pm)/, '$1');
                const timeMatch = cleaned.match(/^(\d{1,2}):(\d{2})\s*(am|pm)$/);
                
                if (!timeMatch) {
                    console.log('No time match for visibility:', timeStr);
                    return null;
                }
                
                let hours = parseInt(timeMatch[1]);
                const minutes = parseInt(timeMatch[2]);
                const period = timeMatch[3];
                
                // Convert to 24-hour format
                if (period === 'pm') {
                    if (hours < 12) hours += 12;
                } else if (period === 'am') {
                    if (hours === 12) hours = 0;
                }
                
                return hours * 60 + minutes;
            }
            
            // Convert minutes to seconds
            function minutesToSeconds(minutes) {
                return minutes * 60;
            }
            
            // Find all lines with times and events
            const lines = text.split('\n');
            const events = [];
            
            // Collect all events with their times
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                // Look for time patterns like "9:00 PM" at the beginning of a line
                const timeMatch = line.match(/^(\d{1,2}:\d{2}\s*[APM]{2})/i);
                if (timeMatch) {
                    const timeStr = timeMatch[1];
                    const timeMinutes = parseTimeToMinutes(timeStr);
                    
                    // Check if next line has an event
                    if (i + 1 < lines.length) {
                        const nextLine = lines[i + 1].trim();
                        if (nextLine && !nextLine.match(/^\d{1,2}:\d{2}\s*[APM]{2}/i)) {
                            // This is an event line
                            events.push({
                                timeStr: timeStr,
                                timeMinutes: timeMinutes,
                                event: nextLine,
                                lineIndex: i
                            });
                            i++; // Skip the event line
                        }
                    }
                }
            }
            
            console.log("Found events:", events.length);
            
            // Find Accepted ‚Üí Queued patterns
            for (let i = 0; i < events.length; i++) {
                const currentEvent = events[i];
                
                // Look for "Accepted" events
                if (currentEvent.event.includes("Accepted") && !currentEvent.event.includes("Courier Notified")) {
                    console.log(`Found Accepted at ${currentEvent.timeStr}`);
                    
                    // Look for the next "Queued" event (could be after other events)
                    let queuedFound = false;
                    let j = i + 1;
                    
                    while (j < events.length && !queuedFound) {
                        if (events[j].event.includes("Queued") && 
                            !events[j].event.includes("Delivery Enqueued")) { // Skip initial "Queued" event
                            
                            console.log(`Found subsequent Queued at ${events[j].timeStr}`);
                            
                            // Calculate time difference
                            if (currentEvent.timeMinutes !== null && events[j].timeMinutes !== null) {
                                // Handle midnight crossing (if queued time is earlier than accepted time)
                                let timeDiffMinutes;
                                if (events[j].timeMinutes >= currentEvent.timeMinutes) {
                                    timeDiffMinutes = events[j].timeMinutes - currentEvent.timeMinutes;
                                } else {
                                    // Queued is on the next day (after midnight)
                                    timeDiffMinutes = (24 * 60 - currentEvent.timeMinutes) + events[j].timeMinutes;
                                }
                                
                                const timeDiffSeconds = minutesToSeconds(timeDiffMinutes);
                                
                                result.patterns.push({
                                    acceptedTime: currentEvent.timeStr,
                                    queuedTime: events[j].timeStr,
                                    durationMinutes: timeDiffMinutes,
                                    durationSeconds: timeDiffSeconds,
                                    acceptedEvent: currentEvent.event,
                                    queuedEvent: events[j].event
                                });
                                
                                result.totalSeconds += timeDiffSeconds;
                                queuedFound = true;
                                
                                console.log(`Pattern ${result.patterns.length}: ${currentEvent.timeStr} ‚Üí ${events[j].timeStr} = ${timeDiffMinutes} min = ${timeDiffSeconds} sec`);
                            }
                        }
                        j++;
                    }
                }
            }
            
            // Create breakdown for display
            if (result.patterns.length > 0) {
                result.breakdown = result.patterns.map((pattern, index) => {
                    return {
                        patternNumber: index + 1,
                        acceptedTime: pattern.acceptedTime,
                        queuedTime: pattern.queuedTime,
                        duration: `${pattern.durationMinutes} min (${pattern.durationSeconds} sec)`,
                        calculation: `${pattern.acceptedTime} ‚Üí ${pattern.queuedTime} = ${pattern.durationMinutes} √ó 60 = ${pattern.durationSeconds} sec`
                    };
                });
            }
            
            console.log("Picked up by another rider calculation complete:", result);
            return result;
        }
        
        // Function: Check Long Dispatch comparison (kept for calculations)
        function checkLongDispatchComparison(orderResult, pickedUpResult) {
            console.log("=== Checking Long Dispatch Comparison ===");
            
            const originalZResult = orderResult.columns.Z;
            const systemLateSeconds = parseFloat(orderResult.columns.U.replace('s', '') || 0);
            const pickedUpTotalSeconds = pickedUpResult.totalSeconds;
            
            console.log("Original Z Result:", originalZResult);
            console.log("System Late (U):", systemLateSeconds, "seconds");
            console.log("Picked up by another rider:", pickedUpTotalSeconds, "seconds");
            
            // Only do comparison if original result is Long Dispatch
            if (originalZResult.includes("Long Dispatch") || originalZResult === "Long Dispatch") {
                console.log("Original result is Long Dispatch, performing comparison...");
                
                // Calculate: (System Late Duration - Picked up by another rider)
                const comparisonValue = systemLateSeconds - pickedUpTotalSeconds;
                
                console.log("Comparison value (U - Picked up):", comparisonValue);
                
                // Check condition: if (U - Picked up) > Picked up
                if (comparisonValue > pickedUpTotalSeconds) {
                    console.log("Condition met: (U - Picked up) > Picked up");
                    console.log(`${comparisonValue} > ${pickedUpTotalSeconds}`);
                    console.log("Result remains: Long Dispatch");
                    
                    return originalZResult; // Remain as Long Dispatch
                } else {
                    console.log("Condition NOT met: (U - Picked up) ‚â§ Picked up");
                    console.log(`${comparisonValue} ‚â§ ${pickedUpTotalSeconds}`);
                    console.log("Result changed to: Picked up by another rider");
                    
                    return "Picked up by another rider";
                }
            } else {
                console.log("Original result is not Long Dispatch, no comparison needed");
                return originalZResult;
            }
        }
        
        // Function: Update final result display with new result
        function updateFinalResult(finalResult) {
            const finalResultDiv = document.getElementById('finalResult');
            finalResultDiv.textContent = finalResult;
            
            // Update styling based on new result
            finalResultDiv.className = 'final-result ';
            
            if (finalResult === "Before PDT") {
                finalResultDiv.classList.add('result-before-pdt');
            } else if (finalResult.includes("Vendor Late")) {
                finalResultDiv.classList.add('result-vendor-late');
            } else if (finalResult.includes("Rider Late")) {
                finalResultDiv.classList.add('result-rider-late');
            } else if (finalResult.includes("Long Dispatch")) {
                finalResultDiv.classList.add('result-long-dispatch');
            } else if (finalResult.includes("Picked up by another rider")) {
                finalResultDiv.classList.add('result-picked-up-another-rider');
            } else if (finalResult !== "Before PDT") {
                finalResultDiv.classList.add('result-on-time');
            } else {
                finalResultDiv.classList.add('result-on-time');
            }
        }
        
        function processOrderDetails(text, isLocalShopAE) {
            const result = {
                columns: {},
                timestamps: {},
                extracted: {},
                formulas: []
            };
            
            console.log('Processing text...');
            
            // Helper: Parse time string to Date object - FIXED VERSION
            function parseTime(timeStr) {
                if (!timeStr) return null;
                
                console.log('Parsing time string:', timeStr);
                
                // Clean the time string - normalize format
                let cleaned = timeStr.trim().toLowerCase();
                
                // Remove any spaces in am/pm
                cleaned = cleaned.replace(/\s+(am|pm)/, '$1');
                
                // Match time pattern
                const timeMatch = cleaned.match(/^(\d{1,2}):(\d{2})(?::(\d{2}))?\s*(am|pm)$/);
                if (!timeMatch) {
                    console.log('No time match for:', timeStr);
                    return null;
                }
                
                let hours = parseInt(timeMatch[1]);
                const minutes = parseInt(timeMatch[2]);
                const seconds = timeMatch[3] ? parseInt(timeMatch[3]) : 0;
                const period = timeMatch[4];
                
                console.log('Time components:', { hours, minutes, seconds, period });
                
                // Convert to 24-hour format - FIXED LOGIC
                if (period === 'pm') {
                    if (hours < 12) {
                        hours += 12;
                    }
                    // 12 pm stays 12 (noon)
                } else if (period === 'am') {
                    if (hours === 12) {
                        hours = 0; // 12 am is midnight
                    }
                    // All other am times stay as-is
                }
                
                // Validate
                if (hours < 0 || hours > 23 || minutes < 0 || minutes > 59 || seconds < 0 || seconds > 59) {
                    console.log('Invalid time:', hours, minutes, seconds);
                    return null;
                }
                
                const date = new Date();
                date.setHours(hours, minutes, seconds, 0);
                console.log('Parsed time result - getHours():', date.getHours(), 'formatted:', date.toLocaleTimeString('en-US', { hour12: true }));
                return date;
            }
            
            // Helper: Parse date string
            function parseDate(dateStr) {
                if (!dateStr) return null;
                
                console.log('Parsing date:', dateStr);
                
                // Try multiple patterns
                // Pattern 1: "Mon 22 Dec" (with day name)
                const dateMatch1 = dateStr.match(/(\w{3})\s+(\d{1,2})\s+(\w{3})/i);
                
                // Pattern 2: Just "22 Dec" (without day name)
                const dateMatch2 = dateStr.match(/(\d{1,2})\s+(\w{3})/i);
                
                let dateNum, month;
                
                if (dateMatch1) {
                    dateNum = parseInt(dateMatch1[2]);
                    month = dateMatch1[3];
                    console.log('Pattern 1 matched:', dateMatch1[0]);
                } else if (dateMatch2) {
                    dateNum = parseInt(dateMatch2[1]);
                    month = dateMatch2[2];
                    console.log('Pattern 2 matched:', dateMatch2[0]);
                } else {
                    console.log('No date match for:', dateStr);
                    return null;
                }
                
                const now = new Date();
                const year = now.getFullYear();
                
                const monthNames = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 
                                   'jul', 'aug', 'sep', 'oct', 'nov', 'dec'];
                const monthIndex = monthNames.indexOf(month.toLowerCase());
                
                if (monthIndex === -1) {
                    console.log('Invalid month:', month);
                    return null;
                }
                
                const dateObj = new Date(year, monthIndex, dateNum, 0, 0, 0);
                console.log('Parsed date:', dateStr, '->', dateObj.toLocaleDateString());
                return dateObj;
            }
            
            // Helper: Format time as HH:MM:SS AM/PM - FIXED VERSION
            function formatTime(date) {
                if (!date) return '';
                
                // Get local time components
                let hours = date.getHours();
                const minutes = date.getMinutes();
                const seconds = date.getSeconds();
                
                // Determine AM/PM
                const ampm = hours >= 12 ? 'PM' : 'AM';
                
                // Convert to 12-hour format
                hours = hours % 12;
                hours = hours ? hours : 12; // 0 becomes 12
                
                // Format with leading zeros
                const hoursStr = hours.toString().padStart(2, '0');
                const minutesStr = minutes.toString().padStart(2, '0');
                const secondsStr = seconds.toString().padStart(2, '0');
                
                return `${hoursStr}:${minutesStr}:${secondsStr} ${ampm}`;
            }
            
            // Helper: Format date as MM/DD/YYYY
            function formatDate(date) {
                if (!date) return '';
                return (date.getMonth() + 1) + '/' + date.getDate() + '/' + date.getFullYear();
            }
            
            // Helper: Format datetime
            function formatDateTime(date) {
                if (!date) return '';
                return formatDate(date) + ' ' + formatTime(date);
            }
            
            // NEW HELPER: Find timeline event with dual pattern search
            function findTimelineEvent(eventName) {
                console.log(`=== Searching for ${eventName} ===`);
                
                // Pattern 1: "Something Delivery Something" (original pattern)
                const pattern1 = new RegExp(`(\\d{1,2}:\\d{2}\\s*[ap]m)\\s+${eventName}\\s+Delivery\\s+${eventName}`, 'gi');
                const matches1 = [...text.matchAll(pattern1)];
                
                // Pattern 2: "Something -" (alternative pattern)
                const pattern2 = new RegExp(`(\\d{1,2}:\\d{2}\\s*[ap]m)\\s+${eventName}\\s*-`, 'gi');
                const matches2 = [...text.matchAll(pattern2)];
                
                console.log(`Pattern 1 matches for ${eventName}:`, matches1.length);
                console.log(`Pattern 2 matches for ${eventName}:`, matches2.length);
                
                let finalMatch = null;
                
                // Try pattern 1 first
                if (matches1.length > 0) {
                    finalMatch = matches1[matches1.length - 1][0];
                    console.log(`Found ${eventName} with Pattern 1:`, finalMatch);
                }
                // If pattern 1 fails, try pattern 2
                else if (matches2.length > 0) {
                    finalMatch = matches2[matches2.length - 1][0];
                    console.log(`Found ${eventName} with Pattern 2:`, finalMatch);
                }
                
                if (finalMatch) {
                    // Extract the time from the match
                    const timeMatch = finalMatch.match(/(\d{1,2}:\d{2}\s*[ap]m)/i);
                    if (timeMatch) {
                        return timeMatch[1];
                    }
                }
                
                console.log(`No match found for ${eventName} with either pattern`);
                return null;
            }
            
            // B: Order ID
            const backendMatch = text.match(/(\d+)\s*Backend\s*Link/i);
            result.columns.B = backendMatch ? backendMatch[1].trim() : '';
            result.formulas.push('Order ID = ' + result.columns.B);
            console.log('B: Order ID =', result.columns.B);
            
            // C: Country - UPDATED to handle multiple patterns
            let countryMatch = text.match(/TB_([A-Z]{2})/i);
            if (!countryMatch) {
                // Try HF_ pattern if TB_ not found
                countryMatch = text.match(/HF_([A-Z]{2})/i);
            }
            if (!countryMatch) {
                // Try ODR_ pattern as fallback
                countryMatch = text.match(/ODR_([A-Z]{2})/i);
            }
            result.columns.C = countryMatch ? countryMatch[1].trim() : '';
            result.formulas.push('C: Country = ' + result.columns.C);
            console.log('C: Country =', result.columns.C);
            
            // D: Order Date
            const dateMatch = text.match(/Ordered at\s*[:]?\s*(\w{3}\s+\d{1,2}\s+\w{3}|\d{1,2}\s+\w{3})/i);
            let orderDate = null;
            if (dateMatch) {
                console.log('Date match found:', dateMatch[1]);
                orderDate = parseDate(dateMatch[1]);
                result.columns.D = orderDate ? formatDate(orderDate) : '';
            } else {
                console.log('No date match found');
            }
            result.formulas.push('D: Order Date = ' + result.columns.D);
            console.log('D: Order Date =', result.columns.D);
            
            // E: Ordered at - FIXED MULTILINE VERSION
            console.log('=== Searching for E: Ordered at ===');
            
            // Method 1: Look for "Ordered at" then capture time from next line (multiline)
            const orderedAtRegex1 = /Ordered\s+at[\s\S]*?(\d{1,2}:\d{2}\s*[ap]m)/i;
            const orderedTimeMatch1 = text.match(orderedAtRegex1);
            
            let orderedTime = null;
            if (orderedTimeMatch1) {
                console.log('Ordered at regex 1 matched:', orderedTimeMatch1[1]);
                console.log('Full match (first 100 chars):', orderedTimeMatch1[0].substring(0, 100));
                orderedTime = parseTime(orderedTimeMatch1[1]);
            }
            
            // Method 2: If first method fails, try line-by-line search
            if (!orderedTime) {
                console.log('Ordered at regex 1 failed, trying line search...');
                const lines = text.split('\n');
                for (let i = 0; i < lines.length; i++) {
                    if (lines[i].includes('Ordered at')) {
                        console.log('Found "Ordered at" on line', i, ':', lines[i]);
                        // Check current line for time
                        let timeMatch = lines[i].match(/(\d{1,2}:\d{2}\s*[ap]m)/i);
                        if (timeMatch) {
                            console.log('Found time on same line:', timeMatch[1]);
                            orderedTime = parseTime(timeMatch[1]);
                            break;
                        }
                        // Check next line
                        if (i + 1 < lines.length) {
                            timeMatch = lines[i + 1].match(/(\d{1,2}:\d{2}\s*[ap]m)/i);
                            if (timeMatch) {
                                console.log('Found time on next line:', timeMatch[1]);
                                orderedTime = parseTime(timeMatch[1]);
                                break;
                            }
                        }
                        // Check line after next
                        if (i + 2 < lines.length) {
                            timeMatch = lines[i + 2].match(/(\d{1,2}:\d{2}\s*[ap]m)/i);
                            if (timeMatch) {
                                console.log('Found time on line after next:', timeMatch[1]);
                                orderedTime = parseTime(timeMatch[1]);
                                break;
                            }
                        }
                    }
                }
            }
            
            // Method 3: Try a more specific pattern for the structure
            if (!orderedTime) {
                console.log('Line search failed, trying specific pattern...');
                const orderedAtRegex3 = /Ordered\s+at\s*\n\s*[^\n]*?(\d{1,2}:\d{2}\s*[ap]m)/i;
                const orderedTimeMatch3 = text.match(orderedAtRegex3);
                if (orderedTimeMatch3) {
                    console.log('Ordered at regex 3 matched:', orderedTimeMatch3[1]);
                    orderedTime = parseTime(orderedTimeMatch3[1]);
                }
            }
            
            if (orderedTime) {
                console.log('Ordered at time successfully parsed:', formatTime(orderedTime));
                result.columns.E = formatTime(orderedTime);
            } else {
                console.log('No ordered time found after all attempts');
                result.columns.E = 'N/A';
            }
            result.formulas.push('E: Ordered at = ' + result.columns.E);
            console.log('E: Ordered at =', result.columns.E);
            
            // If no order date yet, use today
            if (!orderDate) {
                orderDate = new Date();
                orderDate.setHours(0, 0, 0, 0);
                result.columns.D = formatDate(orderDate);
            }
            
            // Store base values for calculations
            const baseDate = orderDate;
            const baseTime = orderedTime;
            
            console.log('Base date:', baseDate.toLocaleDateString());
            console.log('Base time:', baseTime ? baseTime.toLocaleTimeString() : 'null');
            
            // Helper: Combine date and time, adjust for midnight crossing
            function combineDateTime(datePart, timeValue, referenceTime) {
                if (!datePart || !timeValue) return null;
                
                const dateTime = new Date(datePart);
                dateTime.setHours(timeValue.getHours(), timeValue.getMinutes(), timeValue.getSeconds());
                
                if (referenceTime && timeValue < referenceTime) {
                    dateTime.setDate(dateTime.getDate() + 1);
                    console.log('Adjusted date +1 day for crossing midnight');
                }
                
                return dateTime;
            }
            
            // F: Queued At - USING DUAL PATTERN SEARCH
            const queuedTimeStr = findTimelineEvent('Queued');
            if (queuedTimeStr) {
                console.log('Queued time found:', queuedTimeStr);
                const queuedTime = parseTime(queuedTimeStr);
                if (queuedTime) {
                    result.timestamps.F = combineDateTime(baseDate, queuedTime, baseTime);
                    result.columns.F = result.timestamps.F ? formatDateTime(result.timestamps.F) : '';
                }
            } else {
                // Fallback to old pattern if new search fails
                const queuedMatch = text.match(/(\d{1,2}:\d{2}\s?[apm]+)\s*Queued/i);
                if (queuedMatch) {
                    console.log('Queued fallback match found:', queuedMatch[1]);
                    const queuedTime = parseTime(queuedMatch[1]);
                    if (queuedTime) {
                        result.timestamps.F = combineDateTime(baseDate, queuedTime, baseTime);
                        result.columns.F = result.timestamps.F ? formatDateTime(result.timestamps.F) : '';
                    }
                }
            }
            result.formulas.push('F: Queued At = ' + result.columns.F);
            
            // G: Courier Notified - USING DUAL PATTERN SEARCH
            const courierTimeStr = findTimelineEvent('Courier Notified');
            if (courierTimeStr) {
                console.log('Courier Notified time found:', courierTimeStr);
                const courierTime = parseTime(courierTimeStr);
                if (courierTime) {
                    result.timestamps.G = combineDateTime(baseDate, courierTime, baseTime);
                    result.columns.G = result.timestamps.G ? formatTime(result.timestamps.G) : '';
                }
            } else {
                // Fallback to old pattern if new search fails
                const courierMatch = text.match(/(\d{1,2}:\d{2}\s?[apm]+)\s+Courier\s+Notified/i);
                if (courierMatch) {
                    console.log('Courier fallback match found:', courierMatch[1]);
                    const courierTime = parseTime(courierMatch[1]);
                    if (courierTime) {
                        result.timestamps.G = combineDateTime(baseDate, courierTime, baseTime);
                        result.columns.G = result.timestamps.G ? formatTime(result.timestamps.G) : '';
                    }
                }
            }
            result.formulas.push('G: Courier Notified = ' + result.columns.G);
            
            // H: Accepted At - USING DUAL PATTERN SEARCH
            const acceptedTimeStr = findTimelineEvent('Accepted');
            if (acceptedTimeStr) {
                console.log('Accepted time found:', acceptedTimeStr);
                const acceptedTime = parseTime(acceptedTimeStr);
                if (acceptedTime) {
                    result.timestamps.H = combineDateTime(baseDate, acceptedTime, baseTime);
                    result.columns.H = result.timestamps.H ? formatTime(result.timestamps.H) : '';
                }
            } else {
                // Fallback to old pattern if new search fails
                const acceptedMatches = [...text.matchAll(/(\d{1,2}:\d{2}\s*[ap]m)\s+Accepted\s+Delivery\s+Accepted/gi)];
                if (acceptedMatches.length > 0) {
                    const lastAccepted = acceptedMatches[acceptedMatches.length - 1][0];
                    const timeMatch = lastAccepted.match(/(\d{1,2}:\d{2}\s*[ap]m)/i);
                    if (timeMatch) {
                        console.log('Accepted fallback match found:', timeMatch[1]);
                        const acceptedTime = parseTime(timeMatch[1]);
                        if (acceptedTime) {
                            result.timestamps.H = combineDateTime(baseDate, acceptedTime, baseTime);
                            result.columns.H = result.timestamps.H ? formatTime(result.timestamps.H) : '';
                        }
                    }
                }
            }
            result.formulas.push('H: Accepted At = ' + result.columns.H);
            
            // I: Near Pickup - USING DUAL PATTERN SEARCH
            const nearPickupTimeStr = findTimelineEvent('Near Pickup');
            if (nearPickupTimeStr) {
                console.log('Near Pickup time found:', nearPickupTimeStr);
                const nearPickupTime = parseTime(nearPickupTimeStr);
                if (nearPickupTime) {
                    result.timestamps.I = combineDateTime(baseDate, nearPickupTime, baseTime);
                    result.columns.I = result.timestamps.I ? formatTime(result.timestamps.I) : '';
                }
            } else {
                // Fallback to old pattern if new search fails
                const nearPickupMatches = [...text.matchAll(/(\d{1,2}:\d{2}\s*[ap]m)\s+Near\s+Pickup\s+Delivery\s+Near\s+Pickup/gi)];
                if (nearPickupMatches.length > 0) {
                    const lastNearPickup = nearPickupMatches[nearPickupMatches.length - 1][0];
                    const timeMatch = lastNearPickup.match(/(\d{1,2}:\d{2}\s*[ap]m)/i);
                    if (timeMatch) {
                        console.log('Near Pickup fallback match found:', timeMatch[1]);
                        const nearPickupTime = parseTime(timeMatch[1]);
                        if (nearPickupTime) {
                            result.timestamps.I = combineDateTime(baseDate, nearPickupTime, baseTime);
                            result.columns.I = result.timestamps.I ? formatTime(result.timestamps.I) : '';
                        }
                    }
                }
            }
            result.formulas.push('I: Near Pickup = ' + result.columns.I);
            
            // J: Est. Pickup (CPT)
            const acceptedDashMatches = [...text.matchAll(/Accepted\s*[-]\s*(\d{1,2}:\d{2}\s*[apm]{2})/gi)];
            if (acceptedDashMatches.length > 0) {
                const lastAcceptedDash = acceptedDashMatches[acceptedDashMatches.length - 1][1];
                console.log('Accepted - time match found:', lastAcceptedDash);
                const estPickupTime = parseTime(lastAcceptedDash);
                if (estPickupTime) {
                    result.timestamps.J = combineDateTime(baseDate, estPickupTime, baseTime);
                    result.columns.J = result.timestamps.J ? formatTime(result.timestamps.J) : '';
                }
            }
            
            // Alternative for J: Look in timeline
            if (!result.columns.J) {
                const timelineSection = text.match(/Time\s+Event[\s\S]*?(?:\n\n|ID\s+\d|More Details|$)/i);
                if (timelineSection) {
                    const timelineText = timelineSection[0];
                    const estPickupMatch = timelineText.match(/(\d{1,2}:\d{2}\s*[AP]M)[^\n]*Est\.pickup arrival/i);
                    if (estPickupMatch) {
                        console.log('Est. Pickup in timeline:', estPickupMatch[1]);
                        const estPickupTime = parseTime(estPickupMatch[1]);
                        if (estPickupTime) {
                            result.timestamps.J = combineDateTime(baseDate, estPickupTime, baseTime);
                            result.columns.J = result.timestamps.J ? formatTime(result.timestamps.J) : '';
                        }
                    }
                }
            }
            result.formulas.push('J: Est. Pickup (CPT) = ' + result.columns.J);
            console.log('J: Est. Pickup (CPT) =', result.columns.J);
            
            // K: Picked Up At - USING DUAL PATTERN SEARCH
            const pickedUpTimeStr = findTimelineEvent('Picked Up');
            if (pickedUpTimeStr) {
                console.log('Picked Up time found:', pickedUpTimeStr);
                const pickedUpTime = parseTime(pickedUpTimeStr);
                if (pickedUpTime) {
                    result.timestamps.K = combineDateTime(baseDate, pickedUpTime, baseTime);
                    result.columns.K = result.timestamps.K ? formatTime(result.timestamps.K) : '';
                }
            } else {
                // Fallback to old pattern if new search fails
                const pickedUpMatches = [...text.matchAll(/(\d{1,2}:\d{2}\s*[ap]m)\s+Picked\s+Up\s+Delivery\s+Picked\s+Up/gi)];
                if (pickedUpMatches.length > 0) {
                    const lastPickedUp = pickedUpMatches[pickedUpMatches.length - 1][0];
                    const timeMatch = lastPickedUp.match(/(\d{1,2}:\d{2}\s*[ap]m)/i);
                    if (timeMatch) {
                        console.log('Picked Up fallback match found:', timeMatch[1]);
                        const pickedUpTime = parseTime(timeMatch[1]);
                        if (pickedUpTime) {
                            result.timestamps.K = combineDateTime(baseDate, pickedUpTime, baseTime);
                            result.columns.K = result.timestamps.K ? formatTime(result.timestamps.K) : '';
                        }
                    }
                }
            }
            result.formulas.push('K: Picked Up At = ' + result.columns.K);
            
            // L: Est. Dropoff
            console.log('=== Searching for L: Est. Dropoff ===');
            
            // Method 1: Use your exact Google Sheets formula pattern
            // Pattern: "Picked Up" followed by non-digits, then capture a time
            const estDropoffRegex = /Picked\s+Up\s+[^0-9\n]*(\d{1,2}:\d{2}\s*[APM]{2})/i;
            const estDropoffMatch = text.match(estDropoffRegex);
            
            if (estDropoffMatch) {
                console.log('Method 1 - Google Sheets pattern matched:', estDropoffMatch[1]);
                const estDropoffTime = parseTime(estDropoffMatch[1]);
                if (estDropoffTime) {
                    // Apply the same logic as your Google Sheets formula
                    // IF(time < E2, time + D2 + 1, time + D2)
                    if (estDropoffTime < baseTime) {
                        // If extracted time is before ordered time, add 1 day
                        const nextDay = new Date(baseDate);
                        nextDay.setDate(nextDay.getDate() + 1);
                        result.timestamps.L = combineDateTime(nextDay, estDropoffTime, baseTime);
                    } else {
                        result.timestamps.L = combineDateTime(baseDate, estDropoffTime, baseTime);
                    }
                    result.columns.L = result.timestamps.L ? formatTime(result.timestamps.L) : '';
                    console.log('L: Est. Dropoff calculated with Method 1:', result.columns.L);
                }
            }
            
            // Method 2: Look for specific timeline pattern from your data
            if (!result.columns.L) {
                console.log('Method 1 failed, trying Method 2...');
                // Pattern: time, Picked Up, dashes, then time (10:34 PM Picked Up - - - 10:51 PM)
                const timelinePattern = /(\d{1,2}:\d{2}\s*[AP]M)[^0-9]*Picked\s+Up[^0-9\-]*(-[^0-9\-]*){3}[^0-9]*(\d{1,2}:\d{2}\s*[AP]M)/i;
                const timelineMatch = text.match(timelinePattern);
                
                if (timelineMatch) {
                    console.log('Method 2 - Timeline pattern matched. First time:', timelineMatch[1], 'Second time:', timelineMatch[3]);
                    // The second time is likely Est.dropoff
                    const estDropoffTime = parseTime(timelineMatch[3]);
                    if (estDropoffTime) {
                        result.timestamps.L = combineDateTime(baseDate, estDropoffTime, baseTime);
                        result.columns.L = result.timestamps.L ? formatTime(result.timestamps.L) : '';
                        console.log('L: Est. Dropoff calculated with Method 2:', result.columns.L);
                    }
                }
            }
            
            // Method 3: Look for Picked Up row with multiple times
            if (!result.columns.L) {
                console.log('Method 2 failed, trying Method 3...');
                // Find all occurrences of time near "Picked Up"
                const lines = text.split('\n');
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (line.includes('Picked Up')) {
                        console.log('Found Picked Up line:', line);
                        // Extract all times from this line
                        const times = [...line.matchAll(/(\d{1,2}:\d{2}\s*[AP]M)/gi)];
                        console.log('Times in line:', times.map(t => t[0]));
                        
                        // Usually the last time or second time is Est.dropoff
                        if (times.length >= 2) {
                            // Try the last time first
                            const lastTime = times[times.length - 1][0];
                            console.log('Trying last time:', lastTime);
                            const estDropoffTime = parseTime(lastTime);
                            if (estDropoffTime) {
                                result.timestamps.L = combineDateTime(baseDate, estDropoffTime, baseTime);
                                result.columns.L = result.timestamps.L ? formatTime(result.timestamps.L) : '';
                                console.log('L: Est. Dropoff calculated with Method 3 (last time):', result.columns.L);
                                break;
                            }
                        }
                    }
                }
            }
            
            // Method 4: Look for Est.dropoff arrival specifically
            if (!result.columns.L) {
                console.log('Method 3 failed, trying Method 4...');
                const estDropoffArrivalMatch = text.match(/Est\.dropoff\s+arrival[^0-9\n]*(\d{1,2}:\d{2}\s*[AP]M)/i);
                if (estDropoffArrivalMatch) {
                    console.log('Method 4 - Est.dropoff arrival matched:', estDropoffArrivalMatch[1]);
                    const estDropoffTime = parseTime(estDropoffArrivalMatch[1]);
                    if (estDropoffTime) {
                        result.timestamps.L = combineDateTime(baseDate, estDropoffTime, baseTime);
                        result.columns.L = result.timestamps.L ? formatTime(result.timestamps.L) : '';
                        console.log('L: Est. Dropoff calculated with Method 4:', result.columns.L);
                    }
                }
            }
            
            // Method 5: Search in the timeline table section
            if (!result.columns.L) {
                console.log('Method 4 failed, trying Method 5...');
                // Find timeline section
                const timelineStart = text.search(/Time\s+Event/i);
                if (timelineStart !== -1) {
                    const timelineEnd = text.indexOf('\n\n', timelineStart);
                    const timelineText = text.substring(timelineStart, timelineEnd !== -1 ? timelineEnd : text.length);
                    
                    // Look for pattern with multiple times in Picked Up row
                    const pickedUpRowMatch = timelineText.match(/Picked\s+Up[^\n]*(\d{1,2}:\d{2}\s*[AP]M)[^\n]*$/im);
                    if (pickedUpRowMatch) {
                        console.log('Method 5 - Picked Up row in timeline matched time:', pickedUpRowMatch[1]);
                        const estDropoffTime = parseTime(pickedUpRowMatch[1]);
                        if (estDropoffTime) {
                            result.timestamps.L = combineDateTime(baseDate, estDropoffTime, baseTime);
                            result.columns.L = result.timestamps.L ? formatTime(result.timestamps.L) : '';
                            console.log('L: Est. Dropoff calculated with Method 5:', result.columns.L);
                        }
                    }
                }
            }
            
            // Last resort: Use PDT as fallback (often same as Est. Dropoff)
            if (!result.columns.L && result.columns.N) {
                console.log('All methods failed, using PDT as fallback for L: Est. Dropoff');
                result.timestamps.L = result.timestamps.N;
                result.columns.L = result.columns.N;
            }
            
            result.formulas.push('L: Est. Dropoff = ' + result.columns.L);
            console.log('=== L: Est. Dropoff final result =', result.columns.L, '===');
            
            // M: Near Dropoff - USING DUAL PATTERN SEARCH
            const nearDropoffTimeStr = findTimelineEvent('Near Dropoff');
            if (nearDropoffTimeStr) {
                console.log('Near Dropoff time found:', nearDropoffTimeStr);
                const nearDropoffTime = parseTime(nearDropoffTimeStr);
                if (nearDropoffTime) {
                    result.timestamps.M = combineDateTime(baseDate, nearDropoffTime, baseTime);
                    result.columns.M = result.timestamps.M ? formatTime(result.timestamps.M) : '';
                }
            } else {
                // Fallback to old pattern if new search fails
                const nearDropoffMatches = [...text.matchAll(/(\d{1,2}:\d{2}\s*[ap]m)\s+Near\s+Dropoff\s+Delivery\s+Near\s+Dropoff/gi)];
                if (nearDropoffMatches.length > 0) {
                    const lastNearDropoff = nearDropoffMatches[nearDropoffMatches.length - 1][0];
                    const timeMatch = lastNearDropoff.match(/(\d{1,2}:\d{2}\s*[ap]m)/i);
                    if (timeMatch) {
                        console.log('Near Dropoff fallback match found:', timeMatch[1]);
                        const nearDropoffTime = parseTime(timeMatch[1]);
                        if (nearDropoffTime) {
                            result.timestamps.M = combineDateTime(baseDate, nearDropoffTime, baseTime);
                            result.columns.M = result.timestamps.M ? formatTime(result.timestamps.M) : '';
                        }
                    }
                }
            }
            result.formulas.push('M: Near Dropoff = ' + result.columns.M);
            
            // N: PDT - FIXED MULTILINE VERSION
            console.log('=== Searching for N: PDT ===');
            
            // Method 1: Use [\s\S]*? to match across multiple lines
            const pdtRegex1 = /PDT[\s\S]*?(\d{1,2}:\d{2}\s*[ap]m)/i;
            const pdtMatch1 = text.match(pdtRegex1);
            
            let pdtTime = null;
            if (pdtMatch1) {
                console.log('PDT regex 1 matched:', pdtMatch1[1]);
                console.log('Full match (first 100 chars):', pdtMatch1[0].substring(0, 100));
                pdtTime = parseTime(pdtMatch1[1]);
            }
            
            // Method 2: If first method fails, try a more specific pattern
            if (!pdtTime) {
                console.log('PDT regex 1 failed, trying method 2...');
                // Look for PDT, then optional whitespace/newlines, then date, then time
                const pdtRegex2 = /PDT\s*\n?\s*[^\n]*?\s*(\d{1,2}:\d{2}\s*[ap]m)/i;
                const pdtMatch2 = text.match(pdtRegex2);
                if (pdtMatch2) {
                    console.log('PDT regex 2 matched:', pdtMatch2[1]);
                    pdtTime = parseTime(pdtMatch2[1]);
                }
            }
            
            // Method 3: Manual search through lines
            if (!pdtTime) {
                console.log('PDT regex 2 failed, trying method 3 (line search)...');
                const lines = text.split('\n');
                for (let i = 0; i < lines.length; i++) {
                    if (lines[i].includes('PDT')) {
                        console.log('Found PDT on line', i, ':', lines[i]);
                        // Check current line for time
                        let timeMatch = lines[i].match(/(\d{1,2}:\d{2}\s*[ap]m)/i);
                        if (timeMatch) {
                            console.log('Found time on same line:', timeMatch[1]);
                            pdtTime = parseTime(timeMatch[1]);
                            break;
                        }
                        // Check next line
                        if (i + 1 < lines.length) {
                            timeMatch = lines[i + 1].match(/(\d{1,2}:\d{2}\s*[ap]m)/i);
                            if (timeMatch) {
                                console.log('Found time on next line:', timeMatch[1]);
                                pdtTime = parseTime(timeMatch[1]);
                                break;
                            }
                        }
                        // Check line after next
                        if (i + 2 < lines.length) {
                            timeMatch = lines[i + 2].match(/(\d{1,2}:\d{2}\s*[ap]m)/i);
                            if (timeMatch) {
                                console.log('Found time on line after next:', timeMatch[1]);
                                pdtTime = parseTime(timeMatch[1]);
                                break;
                            }
                        }
                    }
                }
            }
            
            // NEW METHOD 4: If no PDT found, search for "Promised delivery time"
            if (!pdtTime) {
                console.log('No PDT found, searching for "Promised delivery time"...');
                
                // Method 4a: Look for "Promised delivery time" followed by date and time
                const promisedRegex1 = /Promised\s+delivery\s+time\s*\n?\s*[^\n]*?\s*(\d{1,2}:\d{2}\s*[ap]m)/i;
                const promisedMatch1 = text.match(promisedRegex1);
                
                if (promisedMatch1) {
                    console.log('Promised delivery time regex 1 matched:', promisedMatch1[1]);
                    pdtTime = parseTime(promisedMatch1[1]);
                }
                
                // Method 4b: If that fails, do a line-by-line search
                if (!pdtTime) {
                    console.log('Promised delivery time regex failed, trying line search...');
                    const lines = text.split('\n');
                    for (let i = 0; i < lines.length; i++) {
                        if (lines[i].includes('Promised delivery time')) {
                            console.log('Found "Promised delivery time" on line', i, ':', lines[i]);
                            
                            // Check current line for time
                            let timeMatch = lines[i].match(/(\d{1,2}:\d{2}\s*[ap]m)/i);
                            if (timeMatch) {
                                console.log('Found time on same line:', timeMatch[1]);
                                pdtTime = parseTime(timeMatch[1]);
                                break;
                            }
                            
                            // Check next line
                            if (i + 1 < lines.length) {
                                timeMatch = lines[i + 1].match(/(\d{1,2}:\d{2}\s*[ap]m)/i);
                                if (timeMatch) {
                                    console.log('Found time on next line:', timeMatch[1]);
                                    pdtTime = parseTime(timeMatch[1]);
                                    break;
                                }
                            }
                            
                            // Check line after next
                            if (i + 2 < lines.length) {
                                timeMatch = lines[i + 2].match(/(\d{1,2}:\d{2}\s*[ap]m)/i);
                                if (timeMatch) {
                                    console.log('Found time on line after next:', timeMatch[1]);
                                    pdtTime = parseTime(timeMatch[1]);
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            
            if (pdtTime) {
                console.log('PDT/Promised time successfully parsed:', formatTime(pdtTime));
                result.timestamps.N = combineDateTime(baseDate, pdtTime, baseTime);
                result.columns.N = result.timestamps.N ? formatTime(result.timestamps.N) : '';
                
                // Check if we should apply Local Shop AE logic
                const country = result.columns.C;
                const applyLocalShopAE = isLocalShopAE && country === 'AE';
                const minutesToAdd = applyLocalShopAE ? 30 : 10;
                
                // Add note about the Local Shop AE adjustment
                if (applyLocalShopAE) {
                    result.formulas.push(`N: PDT/Promised time = ${result.columns.N} (Local Shop AE: Using 30 minutes for calculations)`);
                } else if (isLocalShopAE && country !== 'AE') {
                    result.formulas.push(`N: PDT/Promised time = ${result.columns.N} (Checkbox checked but Country is ${country}, not AE: Using 10 minutes)`);
                } else {
                    result.formulas.push(`N: PDT/Promised time = ${result.columns.N} (Using 10 minutes for calculations)`);
                }
                
                console.log('N: PDT/Promised time final result:', result.columns.N, `(+${minutesToAdd}min)`);
            } else {
                console.log('No PDT or Promised delivery time found after all attempts');
                result.columns.N = 'N/A';
                result.formulas.push('N: PDT/Promised delivery time = N/A');
            }
            
            // O: food_is_ready_at
            const foodReadyMatch = text.match(/Food\s+is\s+ready\s+at\s*[:]?\s*(\d{1,2}:\d{2}\s*[apm]+)/i);
            if (foodReadyMatch) {
                console.log('Food ready match found:', foodReadyMatch[1]);
                const foodReadyTime = parseTime(foodReadyMatch[1]);
                if (foodReadyTime) {
                    result.timestamps.O = combineDateTime(baseDate, foodReadyTime, baseTime);
                    result.columns.O = result.timestamps.O ? formatTime(result.timestamps.O) : '';
                }
            } else {
                // Try alternative pattern without "at"
                const foodReadyAltMatch = text.match(/Food\s+ready\s*[:]?\s*(\d{1,2}:\d{2}\s*[apm]+)/i);
                if (foodReadyAltMatch) {
                    console.log('Food ready alternative match found:', foodReadyAltMatch[1]);
                    const foodReadyTime = parseTime(foodReadyAltMatch[1]);
                    if (foodReadyTime) {
                        result.timestamps.O = combineDateTime(baseDate, foodReadyTime, baseTime);
                        result.columns.O = result.timestamps.O ? formatTime(result.timestamps.O) : '';
                    }
                }
            }
            result.formulas.push('O: food_is_ready_at = ' + result.columns.O);
            console.log('O: food_is_ready_at =', result.columns.O);
            
            // P: cancellation_time - UTC-BASED WITH COUNTRY OFFSETS
            const nowUTC = new Date(); // This is browser local, but we'll convert
            
            const countryUTCOffsets = {
                'AE': 4,  // UTC+4
                'EG': 2,  // UTC+2
                'KW': 3,  // UTC+3
                'QA': 3,  // UTC+3
                'IQ': 3,  // UTC+3
                'SA': 3,  // UTC+3
                'JO': 2,  // UTC+2 (Note: Jordan is UTC+2, but UTC+3 in summer)
                'BH': 3,  // UTC+3
                'OM': 4   // UTC+4
            };
            
            const countryCode = result.columns.C;
            const targetOffset = countryUTCOffsets[countryCode] || 4; // Default to UAE (UTC+4)
            
            // Convert browser local time to UTC
            const utcTime = nowUTC.getTime() + (nowUTC.getTimezoneOffset() * 60000);
            // Apply country offset to get country local time
            const countryTime = new Date(utcTime + (3600000 * targetOffset));
            
            result.columns.P = formatTime(countryTime);
            result.timestamps.P = countryTime; // Store as timestamp for use in W and T calculations
            result.formulas.push(`P: cancellation_time = UTC + ${targetOffset} hours (Country: ${countryCode}) = ${result.columns.P}`);
            console.log(`P: cancellation_time = ${result.columns.P} (UTC+${targetOffset} for country ${countryCode})`);
            
            // Q: old_cpt
            const oldCptMatch = text.match(/Pickup\s*[-]\s*Committed\s*[:]?\s*(\d{1,2}:\d{2}[apm]+)/i);
            if (oldCptMatch) {
                console.log('Old CPT match found:', oldCptMatch[1]);
                const oldCptTime = parseTime(oldCptMatch[1]);
                if (oldCptTime) {
                    result.timestamps.Q = combineDateTime(baseDate, oldCptTime, baseTime);
                    result.columns.Q = result.timestamps.Q ? formatTime(result.timestamps.Q) : '';
                }
            }
            result.formulas.push('Q: old_cpt = ' + result.columns.Q);
            console.log('Q: old_cpt =', result.columns.Q);
            
            // R: cpt =IF(J2>Q2,J2,Q2)
            if (result.timestamps.J && result.timestamps.Q) {
                result.timestamps.R = result.timestamps.J > result.timestamps.Q ? result.timestamps.J : result.timestamps.Q;
                result.columns.R = formatTime(result.timestamps.R);
            } else if (result.timestamps.J) {
                result.timestamps.R = result.timestamps.J;
                result.columns.R = formatTime(result.timestamps.J);
            } else if (result.timestamps.Q) {
                result.timestamps.R = result.timestamps.Q;
                result.columns.R = formatTime(result.timestamps.Q);
            }
            result.formulas.push('R: cpt = MAX(J, Q) = ' + result.columns.R);
            
            // S: is_wfa
            result.columns.S = text.includes("Scheduled") ? "TRUE" : "FALSE";
            result.formulas.push('S: is_wfa (Scheduled) = ' + result.columns.S);
            
            // T: Before PDT Check - MODIFIED VERSION (uses cancellation time as fallback)
            console.log('=== Calculating T: Before PDT Check (Modified) ===');
            result.columns.T = "";
            
            // Get dropoff time for T check (M if available, otherwise P as fallback)
            const dropoffTimeForT = result.timestamps.M || result.timestamps.P;
            
            if (dropoffTimeForT && result.timestamps.N) {
                // MODIFIED: Use 30 minutes if Local Shop AE checkbox is checked AND country is AE, otherwise 10 minutes
                const country = result.columns.C;
                const applyLocalShopAE = isLocalShopAE && country === 'AE';
                const minutesToAdd = applyLocalShopAE ? 30 : 10;
                const pdtPlusMinutes = new Date(result.timestamps.N.getTime() + (minutesToAdd * 60 * 1000));
                console.log(`T Check: Dropoff time = ${formatTime(dropoffTimeForT)}, PDT = ${formatTime(result.timestamps.N)}, PDT+${minutesToAdd}min = ${formatTime(pdtPlusMinutes)}`);
                
                if (dropoffTimeForT <= pdtPlusMinutes) {
                    result.columns.T = "Before PDT";
                    console.log(`T: Before PDT condition met (PDT + ${minutesToAdd}min)`);
                    
                    // Add note if using cancellation time
                    if (!result.timestamps.M && result.timestamps.P) {
                        result.formulas.push('T Note: Using cancellation_time for Before PDT check (Near Dropoff not available)');
                    }
                    
                    // Add note about buffer
                    if (applyLocalShopAE) {
                        result.formulas.push(`T: Using 30-minute buffer (Local Shop AE + Country AE)`);
                    } else if (isLocalShopAE && country !== 'AE') {
                        result.formulas.push(`T: Checkbox checked but Country is ${country}, not AE - Using 10-minute buffer`);
                    }
                } else {
                    console.log(`T: Dropoff time is after PDT+${minutesToAdd}min`);
                }
            } else {
                console.log(`T: Cannot check - Dropoff time: ${dropoffTimeForT ? 'Available' : 'Missing'}, PDT: ${result.timestamps.N ? 'Available' : 'Missing'}`);
            }
            result.formulas.push('T: Before PDT Check = ' + result.columns.T);
            
            // Helper: Convert datetime difference to seconds
            function datetimeToSeconds(date1, date2) {
                if (!date1 || !date2) return 0;
                return (date2 - date1) / 1000;
            }
            
            // U: System Late Duration - UPDATED FORMULA: IF(H<>"", (H-F)*86400, IF(P<>"", (P-F)*86400, 0))
            let U_seconds = 0;
            if (result.timestamps.H && result.timestamps.F) {
                // Use H-F if H exists
                U_seconds = datetimeToSeconds(result.timestamps.F, result.timestamps.H);
            } else if (result.columns.P && result.timestamps.F) {
                // Fallback to P-F if H doesn't exist but P does
                const P_time = parseTime(result.columns.P);
                if (P_time) {
                    U_seconds = datetimeToSeconds(result.timestamps.F, P_time);
                }
            }
            result.columns.U = Math.round(U_seconds) + "s";
            result.formulas.push('U: System Late Duration = IF(H<>"", (H-F)*86400, IF(P<>"", (P-F)*86400, 0)) = ' + result.columns.U);
            
            // V: Vendor Late Duration
            let V_seconds = 0;
            if (result.timestamps.K && result.timestamps.R) {
                V_seconds = datetimeToSeconds(result.timestamps.R, result.timestamps.K);
            }
            result.columns.V = Math.round(V_seconds) + "s";
            result.formulas.push('V: Vendor Late Duration = ' + result.columns.V);
            
            // W: Rider Delay After Pickup - MODIFIED VERSION
            console.log('=== Calculating W: Rider Delay After Pickup (Modified) ===');
            let W_seconds = 0;
            
            // Get the dropoff time (use near dropoff first, cancellation time as fallback)
            let dropoffTime = result.timestamps.M; // Near Dropoff
            
            // If near dropoff is not available, use cancellation time
            if (!dropoffTime && result.columns.P && result.columns.P !== 'N/A') {
                console.log('Near dropoff not available, using cancellation time as dropoff time');
                dropoffTime = result.timestamps.P;
                
                // Add note about using cancellation time
                result.formulas.push('W Note: Using cancellation_time as dropoff time (Near Dropoff not available)');
            }
            
            // Calculate delay if we have both dropoff time and estimated dropoff
            if (dropoffTime && result.timestamps.L && dropoffTime > result.timestamps.L) {
                W_seconds = datetimeToSeconds(result.timestamps.L, dropoffTime);
                console.log(`W calculated: Dropoff time (${formatTime(dropoffTime)}) - Est. Dropoff (${formatTime(result.timestamps.L)}) = ${W_seconds}s`);
                
                // Add specific note if using cancellation time
                if (!result.timestamps.M && result.timestamps.P) {
                    result.formulas.push(`W: Using cancellation_time (${result.columns.P}) instead of Near Dropoff (N/A)`);
                }
            } else if (dropoffTime && result.timestamps.L) {
                console.log(`No delay: Dropoff time (${formatTime(dropoffTime)}) <= Est. Dropoff (${formatTime(result.timestamps.L)})`);
            } else {
                console.log(`Cannot calculate W: Dropoff time or Est. Dropoff missing`);
            }
            
            result.columns.W = Math.round(W_seconds) + "s";
            result.formulas.push('W: Rider Delay After Pickup = (Dropoff Time - Est. Dropoff) = ' + result.columns.W);
            console.log('W: Rider Delay After Pickup final result =', result.columns.W);
            
            // X: Rider Delay Before Pickup - UPDATED FORMULA: =IF(AND(I<>"" , I>J), (I-J)*86400, IF(I = "",(P-H) *86400,0))
            let X_seconds = 0;
            // Primary condition: IF(AND(I<>"" , I>J), (I-J)*86400
            if (result.timestamps.I && result.timestamps.J && result.timestamps.I > result.timestamps.J) {
                X_seconds = datetimeToSeconds(result.timestamps.J, result.timestamps.I);
            }
            // Secondary condition: IF(I = "",(P-H) *86400,0)
            else if (!result.columns.I && result.columns.P && result.timestamps.H) {
                // If I is empty, calculate (P-H)
                const P_time = parseTime(result.columns.P);
                if (P_time) {
                    X_seconds = datetimeToSeconds(result.timestamps.H, P_time);
                    if (X_seconds < 0) {
                        X_seconds = 0; // Ensure non-negative
                    }
                }
            }
            result.columns.X = Math.round(X_seconds) + "s";
            result.formulas.push('X: Rider Delay Before Pickup = IF(AND(I<>"" , I>J), (I-J)*86400, IF(I = "",(P-H)*86400,0)) = ' + result.columns.X);
            
            // Y: Vendor Late (Near Pickup vs Picked Up)
            let Y_seconds = 0;
            if (result.columns.S === "FALSE" && result.timestamps.I && result.timestamps.J && result.timestamps.K && result.timestamps.R) {
                if (result.timestamps.I > result.timestamps.J && result.timestamps.K > result.timestamps.R) {
                    if (result.timestamps.K && result.timestamps.I) {
                        Y_seconds = datetimeToSeconds(result.timestamps.I, result.timestamps.K);
                    }
                }
            }
            result.columns.Y = Math.round(Y_seconds) + "s";
            result.formulas.push('Y: Vendor Late (Near Pickup vs Picked Up) = ' + result.columns.Y);
            
            // Z: Late Owner - EXACT GOOGLE SHEETS FORMULA LOGIC
            let Z_result = "";
            
            console.log("=== CALCULATING Z RESULT ===");
            console.log("T (Before PDT):", result.columns.T);
            console.log("M (Near Dropoff):", result.columns.M);
            console.log("N (PDT):", result.columns.N);
            console.log("I (Near Pickup):", result.columns.I);
            console.log("J (Est Pickup):", result.columns.J);
            console.log("K (Picked Up):", result.columns.K);
            console.log("R (CPT):", result.columns.R);
            console.log("S (Scheduled):", result.columns.S);
            console.log("U (System Late):", U_seconds);
            console.log("V (Vendor Late):", V_seconds);
            console.log("W (Rider After Pickup):", W_seconds);
            console.log("X (Rider Before Pickup):", X_seconds);
            console.log("Y (Vendor Near Pickup):", Y_seconds);
            
            // Check if we should apply Local Shop AE logic
            const country = result.columns.C;
            const applyLocalShopAE = isLocalShopAE && country === 'AE';
            
            // Convert to milliseconds based on checkbox AND country
            const minutesToAdd = applyLocalShopAE ? 30 : 10;
            const pdtBufferMs = minutesToAdd * 60 * 1000;
            
            console.log(`Using ${minutesToAdd} minutes buffer for PDT (Local Shop AE: ${isLocalShopAE}, Country: ${country}, Apply: ${applyLocalShopAE})`);
            
            // Check if dropoff > N + minutes (10 or 30 based on checkbox AND country)
            // Use dropoffTime (which could be M or P) instead of just M
            const dropoffAfterPdtPlusBuffer = dropoffTime && result.timestamps.N && 
                                       (dropoffTime.getTime() > (result.timestamps.N.getTime() + pdtBufferMs));
            
            console.log(`Dropoff > N + ${minutesToAdd}min?`, dropoffAfterPdtPlusBuffer);
            
            // Condition 1: Before PDT
            if (result.columns.T === "Before PDT") {
                Z_result = "Before PDT";
                console.log("Condition 1: Before PDT");
            }
            // Condition 2: Scheduled and vendor late
            else if (dropoffAfterPdtPlusBuffer && result.columns.S === "TRUE") {
                const foodOrCancelTime = result.timestamps.O || (result.columns.P ? new Date(baseDate.getTime() + parseTime(result.columns.P).getTime()) : null);
                if (foodOrCancelTime && foodOrCancelTime > result.timestamps.N) {
                    Z_result = "Vendor Late";
                    console.log("Condition 2: Scheduled and vendor late");
                }
            }
            // Condition 3: Vendor late (non-scheduled, I <= J, K > R, V > U, V > (X+W))
            else if (dropoffAfterPdtPlusBuffer && result.columns.S !== "TRUE" && 
                    result.timestamps.I && result.timestamps.J && result.timestamps.K && result.timestamps.R &&
                    result.timestamps.I <= result.timestamps.J && result.timestamps.K > result.timestamps.R &&
                    V_seconds > U_seconds && V_seconds > (X_seconds + W_seconds)) {
                Z_result = "Vendor Late";
                console.log("Condition 3: Vendor late (non-scheduled)");
            }
            // Condition 4: Rider late ((X+W) > U, (X+W) > V, (X+W) > Y)
            else if (dropoffAfterPdtPlusBuffer && (X_seconds + W_seconds) > U_seconds && 
                    (X_seconds + W_seconds) > V_seconds && (X_seconds + W_seconds) > Y_seconds) {
                Z_result = "Rider Late";
                console.log("Condition 4: Rider late");
            }
            // Condition 5: Long dispatch (U >= (X+W), U > V, U > Y)
            else if (dropoffAfterPdtPlusBuffer && U_seconds >= (X_seconds + W_seconds) && 
                    U_seconds > V_seconds && U_seconds > Y_seconds) {
                Z_result = "Long Dispatch";
                console.log("Condition 5: Long dispatch");
            }
            // Condition 6: Vendor late (I > J, K > R, non-scheduled)
            else if (dropoffAfterPdtPlusBuffer && result.columns.S !== "TRUE" && 
                    result.timestamps.I && result.timestamps.J && result.timestamps.K && result.timestamps.R &&
                    result.timestamps.I > result.timestamps.J && result.timestamps.K > result.timestamps.R &&
                    ((Y_seconds > U_seconds && Y_seconds > (X_seconds + W_seconds)) || 
                     (V_seconds > U_seconds && V_seconds > (X_seconds + W_seconds)))) {
                Z_result = "Vendor Late";
                console.log("Condition 6: Vendor late (I > J, K > R)");
            }
            // Default
            else {
                Z_result = "";
                console.log("Default: No condition met");
            }
            
            // If still empty, set to "On Time"
            if (!Z_result) {
                Z_result = "On Time";
            }
            
            result.columns.Z = Z_result;
            
            // Add note about buffer used
            if (applyLocalShopAE) {
                result.formulas.push(`Z: Late Owner = ${Z_result} (using 30-minute buffer - Local Shop AE + Country AE)`);
            } else if (isLocalShopAE && country !== 'AE') {
                result.formulas.push(`Z: Late Owner = ${Z_result} (checkbox checked but Country is ${country}, not AE - using 10-minute buffer)`);
            } else {
                result.formulas.push(`Z: Late Owner = ${Z_result} (using 10-minute buffer)`);
            }
            
            // Store whether Local Shop AE was applied
            result.applyLocalShopAE = applyLocalShopAE;
            result.isLocalShopAEChecked = isLocalShopAE;
            result.country = country;
            
            return result;
        }
        
        function updateResultDisplay(result) {
            const finalResult = document.getElementById('finalResult');
            const basicInfoGrid = document.getElementById('basicInfoGrid');
            
            // Set final result with appropriate styling
            finalResult.textContent = result.columns.Z || 'No Result';
            finalResult.className = 'final-result ';
            
            if (result.columns.Z === "Before PDT") {
                finalResult.classList.add('result-before-pdt');
            } else if (result.columns.Z.includes("Vendor Late")) {
                finalResult.classList.add('result-vendor-late');
            } else if (result.columns.Z.includes("Rider Late")) {
                finalResult.classList.add('result-rider-late');
            } else if (result.columns.Z.includes("Long Dispatch")) {
                finalResult.classList.add('result-long-dispatch');
            } else if (result.columns.Z.includes("Picked up by another rider")) {
                finalResult.classList.add('result-picked-up-another-rider');
            } else if (result.columns.Z !== "Before PDT") {
                // Get the numeric values for U, X, V (remove 's' and parse)
                const U_value = parseFloat(result.columns.U.replace('s', '') || 0);
                const X_value = parseFloat(result.columns.X.replace('s', '') || 0);
                const V_value = parseFloat(result.columns.V.replace('s', '') || 0);
                
                // Find the maximum value
                const maxValue = Math.max(U_value, X_value, V_value);
                
                // Determine which one is the max (with priority U > X > V)
                if (U_value === maxValue) {
                    finalResult.classList.add('result-long-dispatch'); // U corresponds to Long Dispatch
                    if (result.columns.Z !== "Long Dispatch") {
                        finalResult.textContent = "Long Dispatch";
                        result.columns.Z = "Long Dispatch"; // Update the result
                    }
                } else if (X_value === maxValue) {
                    finalResult.classList.add('result-rider-late'); // X corresponds to Rider Late
                    if (result.columns.Z !== "Rider Late") {
                        finalResult.textContent = "Rider Late";
                        result.columns.Z = "Rider Late"; // Update the result
                    }
                } else if (V_value === maxValue) {
                    finalResult.classList.add('result-vendor-late'); // V corresponds to Vendor Late
                    if (result.columns.Z !== "Vendor Late") {
                        finalResult.textContent = "Vendor Late";
                        result.columns.Z = "Vendor Late"; // Update the result
                    }
                } else {
                    // Fallback if no max found (shouldn't happen)
                    finalResult.classList.add('result-on-time');
                }
            } else {
                finalResult.classList.add('result-on-time');
            }
            
            // Get buffer information
            const isLocalShopAE = document.getElementById('localShopAE').checked;
            const country = result.columns.C;
            const applyLocalShopAE = isLocalShopAE && country === 'AE';
            
            // Create basic information cards - ONLY SHOWING SPECIFIC CARDS
            let cardsHTML = '';
            
            // Only show these specific cards
            const visibleCards = [
                {
                    label: 'Order ID',
                    value: result.columns.B || 'N/A',
                    icon: 'üî¢'
                },
                {
                    label: 'Country',
                    value: result.columns.C || 'N/A',
                    icon: 'üåç'
                },
                {
                    label: 'Order Date',
                    value: result.columns.D || 'N/A',
                    icon: 'üìÖ'
                }
            ];
            
            visibleCards.forEach(card => {
                cardsHTML += `
                    <div class="info-card">
                        <div class="info-label">
                            <span>${card.icon}</span>
                            ${card.label}
                        </div>
                        <div class="info-value">
                            ${card.value}
                        </div>
                    </div>
                `;
            });
            
            basicInfoGrid.innerHTML = cardsHTML;
        }
        
        // Initialize
        window.addEventListener('load', function() {
            document.getElementById('orderDetails').value = '';
        });
    </script>
</body>
</html>
